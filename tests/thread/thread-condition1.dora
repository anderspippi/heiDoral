//= vm-args "--gc=copy"

use std::Queue;

const THREADS: Int32 = 10i32;
const ITERATIONS: Int32 = 10_000i32;
const QUEUE_SIZE: Int64 = 20i64;

class_new SharedQueue[T] {
    capacity: Int64,
    mtx: std::Mutex,
    conditionNonEmpty: std::Condition,
    conditionNonFull: std::Condition,
    queue: Queue[T],
}

impl[T] SharedQueue[T] {
    @static fn new(capacity: Int64): SharedQueue[T] {
        SharedQueue[T](
            capacity,
            std::Mutex::new(),
            std::Condition::new(),
            std::Condition::new(),
            Queue[T]::new(),
        )
    }

    fn enqueue(value: T) {
        self.mtx.lock();

        while self.queue.size() == self.capacity {
            self.conditionNonFull.wait(self.mtx);
        }

        self.queue.enqueue(value);
        self.mtx.unlock();
        self.conditionNonEmpty.notifyAll();
    }

    fn dequeue(): T {
        self.mtx.lock();

        while self.queue.size() == 0i64 {
            self.conditionNonEmpty.wait(self.mtx);
        }

        let value = self.queue.dequeue();
        self.mtx.unlock();
        self.conditionNonFull.notifyAll();
        value
    }
}

class_old Producer(let queue: SharedQueue[Int32]): std::Thread {
    var sum: Int32 = 0i32;

    @override fn run() {
        var i = 0i32;

        while i < ITERATIONS {
            self.queue.enqueue(i);
            self.sum = self.sum + i;
            i = i + 1i32;
        }
    }
}

class_old Consumer(let queue: SharedQueue[Int32]): std::Thread {
    var sum: Int32 = 0i32;

    @override fn run() {
        while true {
            let value = self.queue.dequeue();

            if value == -1i32 {
                break;
            }

            self.sum = self.sum + value;
        }
    }
}

fn main() {
    var i = 0i32;
    let queue = SharedQueue[Int32]::new(QUEUE_SIZE);
    let producers = Vec[Producer]::new();

    while i < THREADS {
        let producer = Producer(queue);
        producer.start();
        producers.push(producer);
        i = i + 1i32;
    }

    let consumer = Consumer(queue);
    consumer.start();

    var producerSum = 0i32;

    for producer in producers {
        producer.join();
        producerSum = producerSum + producer.sum;
    }

    queue.enqueue(-1i32);
    consumer.join();

    assert(consumer.sum == producerSum);
}
