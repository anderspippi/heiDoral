//= vm-args "--gc=copy"

use std::Queue;

const THREADS: Int32 = 10i32;
const ITERATIONS: Int32 = 10_000i32;
const QUEUE_SIZE: Int64 = 20i64;

class SharedQueue[T](let capacity: Int64) {
    let mtx: std::Mutex = std::Mutex::new();
    let conditionNonEmpty: std::Condition = std::Condition::new();
    let conditionNonFull: std::Condition = std::Condition::new();
    let queue: Queue[T] = Queue[T]::new();

    fn enqueue(value: T) {
        self.mtx.lock();

        while self.queue.size() == self.capacity {
            self.conditionNonFull.wait(self.mtx);
        }

        self.queue.enqueue(value);
        self.mtx.unlock();
        self.conditionNonEmpty.notifyAll();
    }

    fn dequeue(): T {
        self.mtx.lock();

        while self.queue.size() == 0i64 {
            self.conditionNonEmpty.wait(self.mtx);
        }

        let value = self.queue.dequeue();
        self.mtx.unlock();
        self.conditionNonFull.notifyAll();
        value
    }
}

class Producer(let queue: SharedQueue[Int32]): std::Thread {
    var sum: Int32 = 0i32;

    @override fn run() {
        var i = 0i32;

        while i < ITERATIONS {
            self.queue.enqueue(i);
            self.sum = self.sum + i;
            i = i + 1i32;
        }
    }
}

class Consumer(let queue: SharedQueue[Int32]): std::Thread {
    var sum: Int32 = 0i32;

    @override fn run() {
        while true {
            let value = self.queue.dequeue();

            if value == -1i32 {
                break;
            }

            self.sum = self.sum + value;
        }
    }
}

fn main() {
    var i = 0i32;
    let queue = SharedQueue[Int32](QUEUE_SIZE);
    let producers = Vec[Producer]();

    while i < THREADS {
        let producer = Producer(queue);
        producer.start();
        producers.push(producer);
        i = i + 1i32;
    }

    let consumer = Consumer(queue);
    consumer.start();

    var producerSum = 0i32;

    for producer in producers {
        producer.join();
        producerSum = producerSum + producer.sum;
    }

    queue.enqueue(-1i32);
    consumer.join();

    assert(consumer.sum == producerSum);
}
