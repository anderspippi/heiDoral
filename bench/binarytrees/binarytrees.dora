fun main() {
  var maxDepth = 6I;

  if argc() > 0I {
    maxDepth = argv(0I).toInt32().unwrap();
  }

  if 6I > maxDepth {
    maxDepth = 6I;
  }

  let stretchDepth = maxDepth + 1I;
  println("stretch tree of depth " + stretchDepth.toString() +
          "\t check: " + checkTree(createTree(stretchDepth)).toString());

  trees(maxDepth);
}

fun trees(maxDepth: Int32) {
  let longLastingNode = createTree(maxDepth);
  var depth = 4I;

  while depth <= maxDepth {
    let iterations = 16I << (maxDepth - depth);

    loops(iterations, depth);
    depth = depth + 2I;
  }

  println("long lived tree of depth " + maxDepth.toString()
    + "\t check: " + checkTree(longLastingNode).toString());
}

fun loops(iterations: Int32, depth: Int32) {
  var check = 0I;
  var item = 0I;

  while item < iterations {
    check = check + checkTree(createTree(depth));
    item = item + 1I;
  }

  println(iterations.toString() + "\t trees of depth " +
    depth.toString() + "\t check: " + check.toString());
}

fun createTree(depth: Int32) -> TreeNode {
  var depth = depth;
  let node = TreeNode(0I, nil, nil);

  if depth > 0I {
    depth = depth - 1I;
    node.left = createTree(depth);
    node.right = createTree(depth);
  }

  return node;
}

fun checkTree(node: TreeNode) -> Int32 {
  if node.left === nil {
    return 1I;
  }

  return checkTree(node.left) + checkTree(node.right) + 1I;
}

class TreeNode(let item: Int32, var left: TreeNode, var right: TreeNode)
