class AssemblerBuffer {
    let buffer: Vec[Byte] = Vec[Byte]();
    let slow_paths: Vec[SlowPath] = Vec[SlowPath]();

    fun emitByte(value: Byte) {
        self.buffer.push(value);
    }

    fun addSlowPath(slow_path: SlowPath) {
        self.slow_paths.push(slow_path);
    }

    fun length() -> Int {
        self.buffer.length()
    }

    fun capacity() -> Int {
        self.buffer.capacity()
    }
}

@test fun add_to_assembler_buffer(_x: Testing) {
    let buffer = AssemblerBuffer();
    buffer.emitByte(0x01Y);
    buffer.emitByte(0x02Y);
    assert(buffer.length() == 2);
}

@open @abstract class SlowPath {
    @abstract fun emit(asm: Assembler);
}

@open @abstract class Assembler

class Register(let value: Int) {
    fun lowBits() -> Int {
        self.value & 0b111
    }

    fun needsRexBit() -> Bool {
        self.value > 7
    }
}

class AssemblerX64: Assembler {
    let buffer: AssemblerBuffer = AssemblerBuffer();

    fun pushq_r(reg: Register) {
        unimplemented();
    }

    fun emitRexIfNeeded(reg: Register) {
        if reg.needsRexBit() {
            self.emitRex(false, false, false, true);
        }
    }

    fun emitRex(w: Bool, r: Bool, x: Bool, b: Bool) {
        let opcode = 0x40 | w.toInt() << 3 | r.toInt() << 2 | x.toInt() << 1 | b.toInt();
        self.emitByte(opcode.toByte());
    }

    fun emitByte(value: Byte) {
        self.buffer.emitByte(value);
    }
}
