class AssemblerBuffer {
    let buffer: Vec[Byte] = Vec[Byte]();

    fun emitByte(value: Byte) {
        self.buffer.push(value);
    }

    fun emitInt32(value: Int) {
        self.emitByte((value & 0xFF).toByte());
        self.emitByte(((value >>> 8) & 0xFF).toByte());
        self.emitByte(((value >>> 16) & 0xFF).toByte());
        self.emitByte(((value >>> 24) & 0xFF).toByte());
    }

    fun emitInt64(value: Long) {
        self.emitInt32(value.toInt());
        self.emitInt32((value >>> 32).toInt());
    }

    fun length() -> Int {
        self.buffer.length()
    }

    fun capacity() -> Int {
        self.buffer.capacity()
    }

    fun toArray() -> Array[Byte] {
        self.buffer.toArray()
    }
}

@test fun testAssemblerBufferEmitByte(_x: Testing) {
    let buffer = AssemblerBuffer();
    buffer.emitByte(0x01Y);
    buffer.emitByte(0x02Y);
    assert(buffer.length() == 2);
}

@test fun testAssemblerBufferEmitInt(_x: Testing) {
    let asm = AssemblerBuffer();
    asm.emitInt32(0x11223344);
    let buffer = asm.toArray();
    assert(buffer(0) == 0x44Y);
    assert(buffer(1) == 0x33Y);
    assert(buffer(2) == 0x22Y);
    assert(buffer(3) == 0x11Y);
    assert(buffer.length() == 4);
}

@open @abstract class SlowPath {
    @abstract fun emit(asm: Assembler);
}

@open @abstract class Assembler

class Register(let value: Int) {
    fun equals(rhs: Register) -> Bool {
        self.value == rhs.value
    }
}

fun asm1(buffer: Array[Byte], index: Int, val: Byte) {
    if buffer(index) != val {
        println("expected ${val.toStringHex()} but got ${buffer(index).toStringHex()}")
    }
    assert(buffer(index) == val);
}

fun asm2(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2);
}

fun asm3(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte, val3: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 || buffer(index+2) != val3 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} ${val3.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()} ${buffer(index+2).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2 && buffer(index+2) == val3);
}

fun asm4(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte, val3: Byte, val4: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 || buffer(index+2) != val3 || buffer(index+3) != val4 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} ${val3.toStringHex()} ${val4.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()} ${buffer(index+2).toStringHex()} ${buffer(index+3).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2 && buffer(index+2) == val3 && buffer(index+3) == val4);
}

fun asmInt(buffer: Array[Byte], index: Int, value: Int) {
    let b1 = buffer(index).toInt();
    let b2 = buffer(index+1).toInt();
    let b3 = buffer(index+2).toInt();
    let b4 = buffer(index+3).toInt();

    let got = (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;

    if value != got {
        println("expected ${value.toStringHex()} but got ${got.toStringHex()}");
    }

    assert(value == got);
}

fun asmLong(buffer: Array[Byte], index: Int, value: Long) {
    asmInt(buffer, index, value.toInt());
    asmInt(buffer, index, (value >>> 32).toInt());
}

fun printBuffer(buffer: Array[Byte]) {
    var i = 0;

    while i < buffer.length() {
        let val = buffer(i);
        if i > 0 { print(" "); }
        print(intToHexString(val.toInt(), 2));
        i = i + 1;
    }
}

fun intToHexString(var val: Int, padding: Int) -> String {
    var result = "";

    while val != 0 {
        let digit = val & 0xF;
        val = val >>> 4;

        let digit = if digit < 10 {
            (48 + digit).toChar().unwrap()
        } else {
            (65 + digit - 10).toChar().unwrap()
        };

        result = "${digit}${result}";
    }

    if result.isEmpty() {
        result = "0";
    }

    while result.length() < padding {
        result = "0${result}";
    }

    return result;
}