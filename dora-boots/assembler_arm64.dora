let R0: Register = Register(0I);
let R1: Register = Register(1I);
let R2: Register = Register(2I);
let R3: Register = Register(3I);
let R4: Register = Register(4I);
let R5: Register = Register(5I);
let R6: Register = Register(6I);
let R7: Register = Register(7I);
let R8: Register = Register(8I);
let R9: Register = Register(9I);
let R10: Register = Register(10I);
let R11: Register = Register(11I);
let R12: Register = Register(12I);
let R13: Register = Register(13I);
let R14: Register = Register(14I);
let R15: Register = Register(15I);

let R16: Register = Register(16I);
let R17: Register = Register(17I);
let R18: Register = Register(18I);
let R19: Register = Register(19I);
let R20: Register = Register(20I);
let R21: Register = Register(21I);
let R22: Register = Register(22I);
let R23: Register = Register(23I);
let R24: Register = Register(24I);
let R25: Register = Register(25I);
let R26: Register = Register(26I);
let R27: Register = Register(27I);
let R28: Register = Register(28I);
let R29: Register = Register(29I);
let R30: Register = Register(30I);

let REG_ZERO: Register = Register(32I);
let REG_SP: Register = Register(33I);

let REG_FP: Register = R29;
let REG_LR: Register = R30;

struct NeonRegister(value: Int32)

impl NeonRegister {
    fn encoding(): Int32 {
        self.value
    }
}

let F0: NeonRegister = NeonRegister(0I);
let F1: NeonRegister = NeonRegister(1I);
let F2: NeonRegister = NeonRegister(2I);
let F3: NeonRegister = NeonRegister(3I);
let F4: NeonRegister = NeonRegister(4I);
let F5: NeonRegister = NeonRegister(5I);
let F6: NeonRegister = NeonRegister(6I);
let F7: NeonRegister = NeonRegister(7I);
let F8: NeonRegister = NeonRegister(8I);
let F9: NeonRegister = NeonRegister(9I);
let F10: NeonRegister = NeonRegister(10I);
let F11: NeonRegister = NeonRegister(11I);
let F12: NeonRegister = NeonRegister(12I);
let F13: NeonRegister = NeonRegister(13I);
let F14: NeonRegister = NeonRegister(14I);
let F15: NeonRegister = NeonRegister(15I);

let F16: NeonRegister = NeonRegister(16I);
let F17: NeonRegister = NeonRegister(17I);
let F18: NeonRegister = NeonRegister(18I);
let F19: NeonRegister = NeonRegister(19I);
let F20: NeonRegister = NeonRegister(20I);
let F21: NeonRegister = NeonRegister(21I);
let F22: NeonRegister = NeonRegister(22I);
let F23: NeonRegister = NeonRegister(23I);
let F24: NeonRegister = NeonRegister(24I);
let F25: NeonRegister = NeonRegister(25I);
let F26: NeonRegister = NeonRegister(26I);
let F27: NeonRegister = NeonRegister(27I);
let F28: NeonRegister = NeonRegister(28I);
let F29: NeonRegister = NeonRegister(29I);
let F30: NeonRegister = NeonRegister(30I);
let F31: NeonRegister = NeonRegister(31I);

class ForwardJump(let offset: Int32, let label: Label, let kind: JumpKind)

enum JumpKind {
    Unconditional,
    Conditional(CondCode),
    NonZero(Bool, Register),
}

enum CondCode {
    EQ, // equal
    NE, // not equal
    CS,
    HS, // carry set, unsigned higher or same
    CC,
    LO, // carry clear, unsigned lower
    MI, // negative
    PL, // positive or zero
    VS, // overflow
    VC, // no overflow
    HI, // unsigned higher
    LS, // unsigned lower or same
    GE, // signed greater than or equal
    LT, // signed less than
    GT, // signed greater than
    LE, // signed less than or equal
}

class AssemblerArm64: Assembler {
    let buffer: AssemblerBuffer = AssemblerBuffer();

    fn ret() {
        let inst = clsx::uncondBranchReg(0b0010I, 0b11111I, 0I, REG_LR, 0I);
        self.buffer.emitInt32(inst);
    }

    fn retReg(rn: Register) {
        let inst = clsx::uncondBranchReg(0b0010I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fn b(label: Label) {
        unreachable[()]();
    }

    fn bl(label: Label) {
        unreachable[()]();
    }

    fn blr(rn: Register) {
        let inst = clsx::uncondBranchReg(0b0001I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fn br(rn: Register) {
        let inst = clsx::uncondBranchReg(0b0000I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fn finalize(): Array[UInt8] {
        self.buffer.toArray()
    }

    fn finalizeTesting(): MachineCode {
        MachineCode(self.buffer.toArray())
    }
}

impl Register {
    fn isGpr(): Bool {
        self.value <= 30I
    }

    fn isGprOrZero(): Bool {
        self.isGpr() || self == REG_ZERO
    }

    fn isGprOrSp(): Bool {
        self.isGpr() || self == REG_SP
    }

    fn encoding(): Int32 {
        assert(self.isGpr());
        self.value
    }

    fn encodingZero(): Int32 {
        assert(self.isGprOrZero());

        if self.isGpr() {
            self.value
        } else {
            31I
        }
    }

    fn encodingSp(): Int32 {
        assert(self.isGprOrSp());

        if self.isGpr() {
            self.value
        } else {
            31I
        }
    }
}

mod clsx {
    use super::Register;

    @pub fn uncondBranchImm(op: Int32, imm26: Int32): Int32 {
        assert(fitsUnsigned(op, 1I));
        assert(fitsSigned(imm26, 26I));

        0b101I << 26I | op << 31I | (imm26 & 0x3FFFFFFI)
    }

    @pub fn uncondBranchReg(opc: Int32, op2: Int32, op3: Int32, rn: Register, op4: Int32): Int32 {
        assert(fitsUnsigned(opc, 4I));
        assert(fitsUnsigned(op2, 5I));
        assert(fitsUnsigned(op3, 6I));
        assert(rn.isGpr());
        assert(fitsUnsigned(op4, 5I));

        0b1101011I << 25I | opc << 21I | op2 << 16I | op3 << 10I | rn.encoding() << 5I | op4
    }

    fn fitsBit(value: Int32): Bool {
        value >= 0I && value < 2I
    }

    fn fitsSigned(value: Int32, bits: Int32): Bool {
        assert(bits > 0I && bits < 32I);
        -(1I << (bits - 1I)) <= value && value < (1I << (bits - 1I))
    }

    fn fitsUnsigned(value: Int32, bits: Int32): Bool {
        assert(bits > 0I && bits < 32I);
        value >= 0I && value < (1I << bits)
    }
}

@test fn testAsmRet(_x: Testing) {
    let asm = AssemblerArm64();
    asm.ret();
    asm.retReg(R0);
    asm.retReg(R10);
    let buffer = asm.finalizeTesting();

    assertAsm32(buffer, 0xd65f03c0I);
    assertAsm32(buffer, 0xd65f0000I);
    assertAsm32(buffer, 0xd65f0140I);
    assertAsmEnd(buffer);
}
