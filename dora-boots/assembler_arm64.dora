let R0: Register = Register(0I);
let R1: Register = Register(1I);
let R2: Register = Register(2I);
let R3: Register = Register(3I);
let R4: Register = Register(4I);
let R5: Register = Register(5I);
let R6: Register = Register(6I);
let R7: Register = Register(7I);
let R8: Register = Register(8I);
let R9: Register = Register(9I);
let R10: Register = Register(10I);
let R11: Register = Register(11I);
let R12: Register = Register(12I);
let R13: Register = Register(13I);
let R14: Register = Register(14I);
let R15: Register = Register(15I);

let R16: Register = Register(16I);
let R17: Register = Register(17I);
let R18: Register = Register(18I);
let R19: Register = Register(19I);
let R20: Register = Register(20I);
let R21: Register = Register(21I);
let R22: Register = Register(22I);
let R23: Register = Register(23I);
let R24: Register = Register(24I);
let R25: Register = Register(25I);
let R26: Register = Register(26I);
let R27: Register = Register(27I);
let R28: Register = Register(28I);
let R29: Register = Register(29I);
let R30: Register = Register(30I);

let REG_ZERO: Register = Register(32I);
let REG_SP: Register = Register(33I);

let REG_FP: Register = R29;
let REG_LR: Register = R30;

class AssemblerArm64: Assembler {
    let buffer: AssemblerBuffer = AssemblerBuffer();

    fun ret() {
        let inst = clsUncondBranchReg(0b0010I, 0b11111I, 0I, REG_LR, 0I);
        self.buffer.emitInt32(inst);
    }

    fun retReg(rn: Register) {
        let inst = clsUncondBranchReg(0b0010I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fun br(rn: Register) {
        let inst = clsUncondBranchReg(0b0000I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fun blr(rn: Register) {
        let inst = clsUncondBranchReg(0b0001I, 0b11111I, 0I, rn, 0I);
        self.buffer.emitInt32(inst);
    }

    fun finalize() -> Array[UInt8] {
        self.buffer.toArray()
    }
}

impl Register {
    fun isGpr() -> Bool {
        self.value <= 30I
    }

    fun isGprOrZero() -> Bool {
        self.isGpr() || self == REG_ZERO
    }

    fun isGprOrSp() -> Bool {
        self.isGpr() || self == REG_SP
    }

    fun int32() -> Int32 {
        if self == REG_ZERO || self == REG_SP {
            31I
        } else {
            assert(self.value <= 30I);
            self.value
        }
    }
}

fun clsUncondBranchReg(opc: Int32, op2: Int32, op3: Int32, rn: Register, op4: Int32) -> Int32 {
    assert(fitsUnsigned(opc, 4I));
    assert(fitsUnsigned(op2, 5I));
    assert(fitsUnsigned(op3, 6I));
    assert(rn.isGpr());
    assert(fitsUnsigned(op4, 5I));

    0b1101011I << 25I | opc << 21I | op2 << 16I | op3 << 10I | rn.int32() << 5I | op4
}

fun fitsUnsigned(value: Int32, bits: Int32) -> Bool {
    assert(bits < 32I);
    value >= 0I && value < (1I << bits)
}
