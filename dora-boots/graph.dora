class Graph {
    var entryBlock: Option[Block] = Option[Block]::None;
    var exitBlock: Option[Block] = Option[Block]::None;

    var blocks: Vec[Block] = Vec[Block]();
    var postOrder: Vec[Block] = Vec[Block]();

    var nextBlockIdValue: Int32 = 0;
    var nextInstIdValue: Int32 = 0;

    fun addBlock(block: Block) {
        assert(block.graph.isNone() && block.id == -1);

        block.graph = Option[Graph]::Some(self);
        block.id = self.nextBlockId();
        self.blocks.push(block);
    }

    fun getBlockWithId(id: Int32): Block {
        self.blocks(id.toInt64())
    }

    fun setEntryBlock(block: Block) {
        self.entryBlock = Option[Block]::Some(block);
    }

    fun getEntryBlock(): Block {
        self.entryBlock.unwrap()
    }

    fun setExitBlock(block: Block) {
        self.exitBlock = Option[Block]::Some(block);
    }

    fun getExitBlock(): Block {
        self.exitBlock.unwrap()
    }

    fun nextInstId(): Int32 {
        let id = self.nextInstIdValue;
        self.nextInstIdValue = id + 1;

        id
    }

    fun nextBlockId(): Int32 {
        let id = self.nextBlockIdValue;
        self.nextBlockIdValue = id + 1;

        id
    }

    fun numberBlocks(): Int32 {
        self.nextBlockIdValue
    }

    fun setPostOrder(postOrder: Vec[Block]) {
        self.postOrder = postOrder;

        for (idx, block) in self.postOrder.enumerate() {
            block.postOrderIdx = idx.toInt32();
        }
    }

    fun rebuildDominatorTree() {
        // TODO: clear data of dominance and loop analysis
        self.buildDominatorTree();
    }

    fun buildDominatorTree() {
        findBackEdges(self);
        computePostOrder(self);
        computeDominators(self);
    }

    fun insertionOrderIterator(): VecIter[Block] {
        self.blocks.makeIterator()
    }

    fun postOrderIterator(): PostOrderIterator {
        PostOrderIterator(self.postOrder)
    }

    fun reversePostOrderIterator(): ReversePostOrderIterator {
        ReversePostOrderIterator(self.postOrder)
    }
}

class PostOrderIterator(let postOrder: Vec[Block]) {
    var idx: Int64 = 0L;

    fun hasNext(): Bool {
        self.idx < self.postOrder.size()
    }

    fun next(): Block {
        let block = self.postOrder(self.idx);
        self.idx = self.idx + 1L;
        block
    }
}

class ReversePostOrderIterator(let postOrder: Vec[Block]) {
    var idx: Int64 = self.postOrder.size() - 1L;

    fun hasNext(): Bool {
        self.idx != -1L
    }

    fun next(): Block {
        let block = self.postOrder(self.idx);
        self.idx = self.idx - 1L;
        block
    }
}

class Block() {
    var id: Int32 = -1;

    var phis: InstLinkedList = InstLinkedList();
    var instructions: InstLinkedList = InstLinkedList();

    var graph: Option[Graph] = Option[Graph]::None;

    var dominator: Option[Block] = Option[Block]::None;
    var dominatedBlocks: Vec[Block] = Vec[Block]();

    var predecessors: Vec[Edge] = Vec[Edge]();
    var successors: Vec[Edge] = Vec[Edge]();

    var backwardPredecessors: Int32 = 0;
    var backwardSuccessors: Int32 = 0;

    var loopHeader: Option[LoopHeader] = Option[LoopHeader]::None;

    var postOrderIdx: Int32 = -1;

    fun getDominator(): Option[Block] {
        self.dominator
    }

    fun setDominator(block: Block) {
        self.dominator = Option[Block]::Some(block);
    }

    fun dominates(other: Block): Bool {
        if self == other {
            true
        } else {
            self.strictlyDominates(other)
        }
    }

    fun strictlyDominates(other: Block): Bool {
        var current = other.getDominator();

        while current.isSome() {
            if self === current.unwrap() { return true; }
            current = current.unwrap().getDominator();
        }

        false
    }

    fun getDominatedBlocks(): Vec[Block] {
        self.dominatedBlocks
    }

    fun addDominatedBlock(block: Block) {
        self.dominatedBlocks.push(block);
    }

    fun addSuccessor(block: Block): Edge {
        let edge = Edge(self, block);
        self.successors.push(edge);
        block.predecessors.push(edge);
        edge
    }

    fun appendPhi(phi: PhiInst): PhiInst {
        assert(phi.block.isNone() && phi.id == -1);

        phi.block = Option[Block]::Some(self);
        phi.id = self.graph.unwrap().nextInstId();

        self.phis.appendInst(phi);
        phi.registerUses();

        phi
    }

    fun appendInst(inst: Inst): Inst {
        assert(inst.block.isNone() && inst.id == -1);

        inst.block = Option[Block]::Some(self);
        inst.id = self.graph.unwrap().nextInstId();

        self.instructions.appendInst(inst);
        inst.registerUses();

        inst
    }

    fun addBackEdge(block: Block) {
        if self.loopHeader.isNone() {
            self.loopHeader = Option[LoopHeader]::Some(LoopHeader(self));
        }
        self.loopHeader.unwrap().addBackEdge(block);
    }

    fun isLoopHeader(): Bool {
        self.loopHeader.isSome()
    }

    fun getLoopHeader(): Option[LoopHeader] {
        self.loopHeader
    }

    fun isEntryBlock(): Bool {
        self.graph.unwrap().getEntryBlock() === self
    }

    fun isExitBlock(): Bool {
        self.graph.unwrap().getExitBlock() === self
    }

    fun instructionsIterator(): InstIterator {
        InstIterator(self)
    }

    fun reverseInstructionsIterator(): BackwardInstIterator {
        BackwardInstIterator(self)
    }

    fun phisIterator(): PhiInstIterator {
        PhiInstIterator(self)
    }

    fun firstInst(): Inst {
        self.instructions.firstInst()
    }

    fun lastInst(): Inst {
        self.instructions.lastInst()
    }

    fun removeInst(inst: Inst) {
        unimplemented();
    }

    fun removePhi(inst: PhiInst) {
        unimplemented();
    }
}

impl Hash for Block {
  fun hash(): Int32 = self.id.hash();
}

impl Equals for Block {
  fun equals(other: Block): Bool = self === other;
}

class LoopHeader(let header: Block) {
    var backEdges: Vec[Block] = Vec[Block]();

    fun getHeader(): Block {
        self.header
    }

    fun addBackEdge(block: Block) {
        self.backEdges.push(block);
    }

    fun numberBackEdges(): Int32 {
        self.backEdges.size().toInt32()
    }
}

class Input(var idx: Int32, var value: Inst, var usedBy: Inst) {
    var previousUse: Option[Input] = Option[Input]::None;
    var nextUse: Option[Input] = Option[Input]::None;
}

@abstract @open class Inst {
    var id: Int32 = -1;
    var block: Option[Block] = Option[Block]::None;

    var previous: Option[Inst] = Option[Inst]::None;
    var next: Option[Inst] = Option[Inst]::None;

    var ty: Type = typeUnit;

    var useListHead: Option[Input] = Option[Input]::None;
    var useListTail: Option[Input] = Option[Input]::None;

    var inputs: Vec[Input] = Vec[Input]();

    fun getType(): Type {
        return self.ty;
    }

    fun addInput(inst: Inst) {
        let input = Input(self.inputs.size().toInt32(), inst, self);
        self.inputs.push(input);
    }

    fun addUse(input: Input) {
        assert(input.value === self);

        if self.useListHead.isNone() {
            assert(self.useListTail.isNone());
            input.previousUse = Option[Input]::None;
            input.nextUse = Option[Input]::None;

            self.useListHead = Option[Input]::Some(input);
            self.useListTail = Option[Input]::Some(input);
        } else {
            assert(self.useListHead.isSome());
            assert(self.useListTail.isSome());

            self.useListTail.unwrap().nextUse = Option[Input]::Some(input);

            input.previousUse = self.useListTail;
            input.nextUse = Option[Input]::None;

            self.useListTail = Option[Input]::Some(input);
        }
    }

    fun removeUse(input: Input) {
        assert(input.value === self);

        if input.previousUse.isSome() {
            input.previousUse.unwrap().nextUse = input.nextUse;
        } else {
            self.useListHead = input.nextUse;
        }

        if input.nextUse.isSome() {
            input.nextUse.unwrap().previousUse = input.previousUse;
        } else {
            self.useListTail = input.previousUse;
        }

        assert(self.useListHead.isSome() == self.useListTail.isSome());

        input.previousUse = Option[Input]::None;
        input.nextUse = Option[Input]::None;
    }

    fun remove() {
        assert(!self.hasUses());
        assert(self.block.isSome());

        self.removeAsUser();
        let block = self.block.unwrap();

        if self is PhiInst {
            block.phis.removeInst(self);
        } else {
            block.instructions.removeInst(self);
        }

        self.block = Option[Block]::None;
    }

    fun registerUses() {
        for input in self.inputs {
            input.value.addUse(input);
        }
    }

    fun removeAsUser() {
        for input in self.inputs {
            input.value.removeUse(input);
        }
    }

    fun hasUses(): Bool {
        let result = self.useListHead.isSome();
        assert(result == self.useListTail.isSome());
        result
    }

    fun replaceWith(replacement: Inst) {
        while self.useListHead.isSome() {
            let input = self.useListHead.unwrap();
            input.usedBy.replaceInput(replacement, input.idx);
        }
    }

    fun replaceInput(replacement: Inst, idx: Int32) {
        let input = self.inputs(idx.toInt64());

        if input.value === replacement {
            return;
        }

        input.value.removeUse(input);
        input.value = replacement;
        replacement.addUse(input);
    }

    fun users(): Array[Inst] {
        let data = Vec[Inst]();
        var current = self.useListHead;

        while current.isSome() {
            let cur = current.unwrap();
            data.push(cur.usedBy);
            current = cur.nextUse;
        }

        data.toArray()
    }

    fun isDeadAndRemovable(): Bool {
        false
    }

    @open @abstract fun dumpName(): String;
}

@abstract @open class Const extends Inst

class NullConst(let value: UInt8) extends Const {
    @override fun dumpName(): String { "Null" }
}

class Int32Const(let value: Int32) extends Const {
    @override fun dumpName(): String { "Int32(${self.value})" }
}

class Int64Const(let value: Int64) extends Const {
    @override fun dumpName(): String { "Int64(${self.value})" }
}

class Float32Const(let value: Float32) extends Const {
    @override fun dumpName(): String { "Float32(${self.value})" }
}

class Float64Const(let value: Float64) extends Const {
    @override fun dumpName(): String { "Float64(${self.value})" }
}

class LoadGlobalInst(ty: Type, let global: GlobalId) extends Inst {
    self.ty = ty;

    @override fun dumpName(): String { "LoadGlobal.${self.ty}(${self.global.value})" }
}

class StoreGlobalInst(ty: Type, let global: GlobalId, let value: Inst) extends Inst {
    self.addInput(value);
    self.ty = ty;

    @override fun dumpName(): String { "StoreGlobal.${self.ty}(${self.global.value})" }
}


class UnaryInst(let op: UnOp, ty: Type, let opnd: Inst) extends Inst {
    self.addInput(opnd);
    self.ty = ty;

    @override fun dumpName(): String { "${unOpName(self.op)}.${self.ty}" }
}

class BinaryInst(let op: BinOp, ty: Type, let lhs: Inst, let rhs: Inst) extends Inst {
    self.addInput(lhs);
    self.addInput(rhs);
    self.ty = ty;

    @override fun dumpName(): String { "${binOpName(self.op)}.${self.ty}" }
}

class TestInst(let op: TestOp, ty: Type, let lhs: Inst, let rhs: Inst) extends Inst {
    self.addInput(lhs);
    self.addInput(rhs);
    self.ty = ty;

    @override fun dumpName(): String { "${self.op.name()}.${self.ty}" }
}

class UndefInst extends Inst {
    @override fun dumpName(): String { "Undef" }
}

class PhiInst extends Inst {
    @override fun dumpName(): String { "Phi" }
}

class BoundsCheck(let index: Inst, let length: Inst) extends Inst {
    self.addInput(index);
    self.addInput(length);

    @override fun dumpName(): String { "BoundsCheck" }
}

class ArrayGet(let array: Inst, let index: Inst) extends Inst {
    self.addInput(array);
    self.addInput(index);

    @override fun dumpName(): String { "ArrayGet" }
}

class ArraySet(let array: Inst, let index: Inst, let value: Inst) extends Inst {
    self.addInput(array);
    self.addInput(index);
    self.addInput(value);

    @override fun dumpName(): String { "ArraySet" }
}

class ArrayLength(let array: Inst) extends Inst {
    self.addInput(array);

    @override fun dumpName(): String { "ArrayLength" }
}

class ArgInst(let index: Int32, ty: Type) extends Inst {
    self.ty = ty;

    @override fun dumpName(): String { "Arg.${self.ty}(${self.index})" }
}

class ReturnInst(let value: Inst, ty: Type) extends Inst {
    self.ty = ty;
    self.addInput(value);

    @override fun dumpName(): String { "Ret.${self.ty}" }
}

class ReturnVoidInst extends Inst {
    @override fun dumpName(): String { "Ret.Void" }
}

class IfInst(let cond: Inst, let true_block: Block, let false_block: Block) extends Inst {
    self.addInput(cond);

    @override fun dumpName(): String { "If(${self.true_block.id}, ${self.false_block.id})" }
}

class GotoInst(let block: Block) extends Inst {
    @override fun dumpName(): String { "Goto(${self.block.id})" }
}

enum BinOp {
    Add, Sub, Mul, Div, Mod, And, Or, Xor, Shl, Shr, Sar
}

fun binOpName(op: BinOp): String {
    if op == BinOp::Add {
        "Add"
    } else if op == BinOp::Sub {
        "Sub"
    } else if op == BinOp::Mul {
        "Mul"
    } else if op == BinOp::Div {
        "Div"
    } else if op == BinOp::Mod {
        "Mod"
    } else if op == BinOp::And {
        "And"
    } else if op == BinOp::Or {
        "Or"
    } else if op == BinOp::Xor {
        "Xor"
    } else if op == BinOp::Shl {
        "Shl"
    } else if op == BinOp::Shr {
        "Shr"
    } else if op == BinOp::Sar {
        "Sar"
    } else {
        unreachable[String]()
    }
}

enum TestOp {
    Equal,
    NotEqual,
    Greater,
    GreaterOrEqual,
    Less,
    LessOrEqual
}

impl TestOp {
    fun name(): String {
        if self == TestOp::Equal {
            "Equal"
        } else if self == TestOp::NotEqual {
            "NotEqual"
        } else if self == TestOp::Greater {
            "Greater"
        } else if self == TestOp::GreaterOrEqual {
            "GreaterOrEqual"
        } else if self == TestOp::Less {
            "Less"
        } else if self == TestOp::LessOrEqual {
            "LessOrEqual"
        } else {
            unreachable[String]()
        }
    }
}

enum UnOp {
    Neg, FNeg, Not,
}

fun unOpName(op: UnOp): String {
    if op == UnOp::Neg {
        "Neg"
    } else if op == UnOp::Not {
        "Not"
    } else {
        unreachable[String]()
    }
}

class InstLinkedList {
    var first: Option[Inst] = Option[Inst]::None;
    var last: Option[Inst] = Option[Inst]::None;

    fun isEmpty(): Bool {
        self.first.isNone()
    }

    fun firstInst(): Inst {
        self.first.unwrap()
    }

    fun lastInst(): Inst {
        self.last.unwrap()
    }

    fun appendInst(inst: Inst) {
        if self.first.isNone() {
            inst.previous = Option[Inst]::None;
            inst.next = Option[Inst]::None;

            self.first = Option[Inst]::Some(inst);
            self.last = Option[Inst]::Some(inst);
        } else {
            self.last.unwrap().next = Option[Inst]::Some(inst);

            inst.previous = self.last;
            inst.next = Option[Inst]::None;

            self.last = Option[Inst]::Some(inst);
        }
    }

    fun removeInst(inst: Inst) {
        if inst.previous.isSome() {
            let previous = inst.previous.unwrap();
            previous.next = inst.next;
        } else {
            self.first = inst.next;
        }

        if inst.next.isSome() {
            let next = inst.next.unwrap();
            next.previous = inst.previous;
        } else {
            self.last = inst.previous;
        }
    }
}

class InstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.first;

    fun hasNext(): Bool {
        self.current.isSome()
    }

    fun next(): Inst {
        let inst = self.current.unwrap();
        self.current = inst.next;
        inst
    }
}

class PhiInstIterator(block: Block) {
    var current: Option[Inst] = block.phis.first;

    fun hasNext(): Bool {
        self.current.isSome()
    }

    fun next(): Inst {
        let inst = self.current.unwrap();
        self.current = inst.next;
        inst
    }
}

class BackwardInstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.last;

    fun hasNext(): Bool {
        self.current.isSome()
    }

    fun next(): Inst {
        let inst = self.current.unwrap();
        self.current = inst.previous;
        inst
    }
}

class Edge(let from: Block, let to: Block) {
    var backward: Bool = false;

    fun markAsBackwardEdge() {
        assert(!self.backward);
        self.backward = true;

        self.from.backwardSuccessors = self.from.backwardSuccessors + 1;
        self.to.backwardPredecessors = self.to.backwardPredecessors + 1;
    }
}
