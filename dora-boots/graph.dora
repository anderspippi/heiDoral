class Graph {
    var entryBlock: Block;
    var exitBlock: Block;

    var blocks: Vec[Block] = Vec[Block]();
    var reversePostOrder: Vec[Block] = Vec[Block]();

    var nextBlockIdValue: Int = 0;
    var nextInstIdValue: Int = 0;

    fun addBlock(block: Block) {
        assert(block.graph === nil && block.id == -1);

        block.graph = self;
        block.id = self.nextBlockId();
        self.blocks.push(block);
    }

    fun setEntryBlock(block: Block) {
        self.entryBlock = block;
    }

    fun setExitBlock(block: Block) {
        self.exitBlock = block;
    }

    fun nextInstId() -> Int {
        let id = self.nextInstIdValue;
        self.nextInstIdValue = id + 1;

        id
    }

    fun nextBlockId() -> Int {
        let id = self.nextBlockIdValue;
        self.nextBlockIdValue = id + 1;

        id
    }

    fun numberBlocks() -> Int {
        self.nextBlockIdValue
    }
}

class Block() {
    var id: Int = -1;

    var phis: Vec[Inst] = Vec[Inst]();
    var instructions: InstLinkedList = InstLinkedList();

    var graph: Graph;

    var dominator: Block = nil;
    var dominatedBlocks: Vec[Block] = Vec[Block]();

    var predecessors: Vec[Block] = Vec[Block]();
    var successors: Vec[Block] = Vec[Block]();

    var loopHeader: Option[LoopHeader] = none[LoopHeader]();

    fun getDominator() -> Block {
        self.dominator
    }

    fun setDominator(block: Block) {
        self.dominator = block;
    }

    fun dominates(other: Block) -> Bool {
        var current = other;

        while current !== nil {
            if self === current { return true; }
            current = current.getDominator();
        }

        false
    }

    fun getDominatedBlocks() -> Vec[Block] {
        self.dominatedBlocks
    }

    fun addDominatedBlock(block: Block) {
        self.dominatedBlocks.push(block);
    }

    fun addPredecessor(block: Block) {
        self.predecessors.push(block);
        block.successors.push(block);
    }

    fun addSuccessor(block: Block) {
        self.successors.push(block);
        block.predecessors.push(block);
    }

    fun appendPhi(phi: PhiInst) -> PhiInst {
        assert(phi.block === nil && phi.id == -1);

        phi.block = self;
        phi.id = self.graph.nextInstId();

        self.phis.push(phi);
        phi.registerUses();

        phi
    }

    fun appendInst(inst: Inst) -> Inst {
        assert(inst.block === nil && inst.id == -1);

        inst.block = self;
        inst.id = self.graph.nextInstId();

        self.instructions.appendInst(inst);

        inst.registerUses();
        return inst;
    }

    fun addBackEdge(block: Block) {
        if self.loopHeader.isNone() {
            self.loopHeader = some[LoopHeader](LoopHeader());
        }
        self.loopHeader.unwrap().addBackEdge(block);
    }
}

impl Hash for Block {
  fun hash() -> Int = self.id.hash();
}

impl Equals for Block {
  fun equals(other: Block) -> Bool = self === other;
}

class LoopHeader {
    var backEdges: Vec[Block] = Vec[Block]();

    fun addBackEdge(block: Block) {
        self.backEdges.push(block);
    }
}

class Input {
    var idx: Int;

    var value: Inst;
    var used_by: Inst;

    var previous_use: Input;
    var next_use: Input;
}

@abstract @open class Inst {
    var id: Int = -1;
    var block: Block = nil;

    var previous: Inst = nil;
    var next: Inst = nil;

    var ty: Type = nil;

    var useListHead: Input = nil;
    var useListTail: Input = nil;

    var inputs: Vec[Input] = Vec[Input]();

    fun getType() -> Type {
        return self.ty;
    }

    fun addInput(inst: Inst) {
        let input = Input();
        input.value = inst;
        input.used_by = self;
        input.idx = self.inputs.length();

        self.inputs.push(input);
    }

    fun addUse(input: Input) {
        if self.useListHead === nil {
            input.previous_use = nil;
            input.next_use = nil;

            self.useListHead = input;
            self.useListTail = input;
        } else {
            input.previous_use = self.useListTail;
            input.next_use = nil;

            self.useListTail = input;
        }
    }

    fun registerUses() {
        let inputs = self.inputs.length();
        var idx = 0;

        while idx < inputs {
            let input = self.inputs.get(idx);
            input.value.addUse(input);
            idx = idx + 1;
        }
    }

    fun hasUses() -> Bool {
        self.useListHead !== nil
    }
}

@abstract @open class Const: Inst
class IntConst(let value: Int): Const
class LongConst(let value: Long): Const
class FloatConst(let value: Float): Const
class DoubleConst(let value: Double): Const

class UnaryInst(let op: UnOp, let opnd: Inst): Inst {
    self.addInput(opnd);
}

class BinaryInst(let op: BinOp, let lhs: Inst, let rhs: Inst): Inst {
    self.addInput(lhs);
    self.addInput(rhs);
}

class PhiInst(): Inst {
    let inputs: Vec[PhiArg] = Vec[PhiArg]();
}
class PhiArg(let value: Inst, let block: Block)

class ArrayGet(let array: Inst, let index: Inst): Inst {
    self.addInput(array);
    self.addInput(index);
}

class ArraySet(let array: Inst, let index: Inst, let value: Inst): Inst {
    self.addInput(array);
    self.addInput(index);
    self.addInput(value);
}

class ArrayLength(let array: Inst): Inst {
    self.addInput(array);
}

class ParamInst(let index: Int, ty: Type): Inst {
    self.ty = ty;
}

class ReturnInst(let value: Inst): Inst {
    self.addInput(value);
}

class ReturnVoidInst: Inst

class CondInst(let cond: Inst, let true_block: Block, let false_block: Block): Inst {
    self.addInput(cond);
}

class GotoInst(let block: Block): Inst

enum BinOp {
    Add, Sub, Mul, Div, Mod,
    FAdd, FSub, FMul, FDiv,
}

enum UnOp {
    Neg, FNeg, Not,
}

class InstLinkedList {
    var first_inst: Inst;
    var last_inst: Inst;

    fun isEmpty() -> Bool {
        self.first_inst === nil
    }

    fun firstInst() -> Inst {
        self.first_inst
    }

    fun lastInst() -> Inst {
        self.last_inst
    }

    fun appendInst(inst: Inst) {
        if self.first_inst === nil {
            inst.previous = nil;
            inst.next = nil;

            self.first_inst = inst;
            self.last_inst = inst;
        } else {
            self.last_inst.next = inst;

            inst.previous = self.last_inst;
            inst.next = nil;

            self.last_inst = inst;
        }
    }
}

class InstIterator(block: Block) {
    var inst: Inst = block.instructions.firstInst();

    fun current() -> Inst { self.inst }
    fun isDone() -> Bool { self.inst === nil }
    fun next() {
        if self.inst !== nil {
            self.inst = self.inst.next;
        }
    }
}

class BackwardInstIterator(block: Block) {
    var inst: Inst = block.instructions.lastInst();

    fun current() -> Inst { self.inst }
    fun isDone() -> Bool { self.inst === nil }
    fun next() {
        if self.inst !== nil {
            self.inst = self.inst.previous;
        }
    }
}

class BlockIterator(graph: Graph) {
    let blocks: Vec[Block] = graph.blocks;
    var idx: Int = 0;

    fun current() -> Block { self.blocks.get(self.idx) }
    fun isDone() -> Bool { self.idx >= self.blocks.length() }
    fun next() {
        self.idx = self.idx + 1;
    }
}
