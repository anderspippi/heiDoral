class Graph {
    var entryBlock: Option[Block] = None;

    var blocks: Vec[Option[Block]] = Vec();
    var postOrder: Vec[Block] = Vec();

    var nextBlockIdValue: Int32 = 0i32;
    var nextInstIdValue: Int32 = 0i32;

    fn addBlock(block: Block) {
        assert(block.graph.isNone() && block.id == -1i32);

        block.graph = Some(self);
        block.id = self.nextBlockId().value;
        self.blocks.push(Some[Block](block));
    }

    fn getBlockWithId(id: Int32): Block {
        self.blocks(id.toInt64()).getOrPanic()
    }

    fn setEntryBlock(block: Block) {
        self.entryBlock = Some(block);
    }

    fn getEntryBlock(): Block {
        self.entryBlock.getOrPanic()
    }

    fn nextInstId(): Int32 {
        let id = self.nextInstIdValue;
        self.nextInstIdValue = id + 1i32;

        id
    }

    fn nextBlockId(): BlockId {
        let id = self.nextBlockIdValue;
        self.nextBlockIdValue = id + 1i32;

        BlockId(id)
    }

    fn blockCount(): Int32 {
        self.nextBlockIdValue
    }

    fn setPostOrder(postOrder: Vec[Block]) {
        self.postOrder = postOrder;

        for (idx, block) in self.postOrder.enumerate() {
            block.postOrderIdx = idx.toInt32();
        }
    }

    fn rebuildDominatorTree() {
        // TODO: clear data of dominance and loop analysis
        self.buildDominatorTree();
    }

    fn buildDominatorTree() {
        buildDominatorTree(self);
    }

    fn insertionOrderIterator(): InsertionOrderIterator {
        InsertionOrderIterator(self.blocks.toArray())
    }

    fn postOrderIterator(): PostOrderIterator {
        PostOrderIterator(self.postOrder.toArray())
    }

    fn reversePostOrderIterator(): ReversePostOrderIterator {
        ReversePostOrderIterator(self.postOrder.toArray())
    }
}

class InsertionOrderIterator(let blocks: Array[Option[Block]]) {
    var idx: Int64 = 0;

    fn next(): Option[Block] {
        self.findNextBlock();

        if self.idx < self.blocks.size() {
            let block = self.blocks(self.idx).getOrPanic();
            self.idx = self.idx + 1i64;
            Some[Block](block)
        } else {
            None[Block]
        }
    }

    fn findNextBlock() {
        while self.idx < self.blocks.size() {
            let block = self.blocks(self.idx);

            if block.isSome() {
                break;
            }

            self.idx = self.idx + 1i64;
        }
    }
}

class PostOrderIterator(let postOrder: Array[Block]) {
    var idx: Int64 = 0i64;

    fn next(): Option[Block] {
        if self.idx < self.postOrder.size() {
            let block = self.postOrder(self.idx);
            self.idx = self.idx + 1i64;
            Some[Block](block)
        } else {
            None[Block]
        }
    }
}

class ReversePostOrderIterator(let postOrder: Array[Block]) {
    var idx: Int64 = self.postOrder.size() - 1i64;

    fn next(): Option[Block] {
        if self.idx != -1 {
            let block = self.postOrder(self.idx);
            self.idx = self.idx - 1i64;
            Some[Block](block)
        } else {
            None[Block]
        }
    }
}

struct BlockId(value: Int32)

class Block() {
    var id: Int32 = -1i32;

    var phis: InstLinkedList = InstLinkedList();
    var instructions: InstLinkedList = InstLinkedList();

    var graph: Option[Graph] = None;

    var dominator: Option[Block] = None;
    var dominatedBlocks: Vec[Block] = Vec();

    var predecessors: Vec[Edge] = Vec();
    var successors: Vec[Edge] = Vec();

    var loopData: Option[LoopData] = None;

    var postOrderIdx: Int32 = -1i32;

    fn getDominator(): Option[Block] = self.dominator;

    fn setDominator(block: Block) {
        self.dominator = Some(block);
    }

    fn dominates(other: Block): Bool =
        if self == other {
            true
        } else {
            self.strictlyDominates(other)
        };

    fn strictlyDominates(other: Block): Bool {
        var current = other.getDominator();

        while current.isSome() {
            if self === current.getOrPanic() { return true; }
            current = current.getOrPanic().getDominator();
        }

        false
    }

    fn getDominatedBlocks(): Vec[Block] = self.dominatedBlocks;

    fn addDominatedBlock(block: Block) {
        self.dominatedBlocks.push(block);
    }

    fn addSuccessor(block: Block): Edge {
        let edge = Edge(self, block);
        self.successors.push(edge);
        block.predecessors.push(edge);
        edge
    }

    fn appendPhi(phi: Inst): Inst {
        assert(phi.block.isNone() && phi.id == -1i32);

        phi.block = Some(self);
        phi.id = self.graph.getOrPanic().nextInstId();

        self.phis.appendInst(phi);
        phi.registerUses();

        phi
    }

    fn appendInst(inst: Inst): Inst {
        assert(inst.block.isNone() && inst.id == -1i32);

        inst.block = Some(self);
        inst.id = self.graph.getOrPanic().nextInstId();

        self.instructions.appendInst(inst);
        inst.registerUses();

        inst
    }

    fn addBackEdge(block: Block) {
        if self.loopData.isNone() {
            self.loopData = Some(LoopData(self));
        }
        self.loopData.getOrPanic().addBackEdge(block);
    }

    fn isLoopHeader(): Bool {
        self.loopData.isSome() && self.loopData.getOrPanic().header === self
    }

    fn getLoopData(): Option[LoopData] {
        self.loopData
    }

    fn setLoopData(loop: LoopData) {
        self.loopData = Some(loop);
    }

    fn clearLoopData() {
        self.loopData = None;
    }

    fn isEntryBlock(): Bool {
        self.graph.getOrPanic().getEntryBlock() === self
    }

    fn instructionsIterator(): InstIterator {
        InstIterator(self)
    }

    fn reverseInstructionsIterator(): BackwardInstIterator {
        BackwardInstIterator(self)
    }

    fn phisIterator(): PhiInstIterator {
        PhiInstIterator(self)
    }

    fn firstInst(): Inst {
        self.instructions.firstInst()
    }

    fn lastInst(): Inst {
        self.instructions.lastInst()
    }

    fn removePhi(inst: Inst) {
        unimplemented();
    }
}

impl Hash for Block {
  fn hash(): Int32 = self.id.hash();
}

impl Equals for Block {
  fn equals(other: Block): Bool = self === other;
}

use std::BitVec;

class LoopData(let header: Block) {
    var backEdges: Vec[Block] = Vec();
    let blocks: BitVec = BitVec();

    fn getHeader(): Block {
        self.header
    }

    fn addBackEdge(block: Block) {
        self.backEdges.push(block);
    }

    fn numberBackEdges(): Int32 {
        self.backEdges.size().toInt32()
    }

    fn addBlock(block: Block) {
        self.blocks.insert(block.id.toInt64());
    }

    fn containsBlock(block: Block): Bool {
        self.blocks.contains(block.id.toInt64())
    }

    fn containsLoop(other: LoopData): Bool {
        self.containsBlock(other.header)
    }
}

class Input(var idx: Int32, var value: Inst, var usedBy: Inst) {
    var previousUse: Option[Input] = None;
    var nextUse: Option[Input] = None;
}

enum Op {
    NullConst,
    
    Int32Const,
    Int64Const,

    Float32Const,
    Float64Const,

    LoadGlobal,
    StoreGlobal,

    Undef,

    BoundsCheck,
    Goto,
    If,
    Return,

    Neg,
    Not,

    Add,
    Sub,
    Mul,
    Div,
    Mod, 
    And,
    Or,
    Xor,
    Shl,
    Shr,
    Sar,

    Equal,
    NotEqual,
    Greater,
    GreaterOrEqual,
    Less,
    LessOrEqual,

    Phi,
    DivZeroCheck,
    ArrayGet,
    ArraySet,
    ArrayLength,

    FieldGet,
    FieldSet,
    Arg,
}

fn opName(op: Op): String {
    match op {
        Op::NullConst => "Const.Null",
        Op::Int32Const => "Const.Int32",
        Op::Int64Const => "Const.Int64",
        Op::Float32Const => "Const.Float32",
        Op::Float64Const => "Const.Float64",
        Op::LoadGlobal => "LoadGlobal",
        Op::StoreGlobal => "StoreGlobal",
        Op::Undef => "Undef",
        Op::BoundsCheck => "BoundsCheck",
        Op::Goto => "Goto",
        Op::If => "If",
        Op::Return => "Return",
        Op::Neg => "Neg",
        Op::Not => "Not",
        Op::Add => "Add",
        Op::Sub => "Sub",
        Op::Mul => "Mul",
        Op::Div => "Div",
        Op::Mod => "Mod",
        Op::And => "And",
        Op::Or => "Or",
        Op::Xor => "Xor",
        Op::Shl => "Shl",
        Op::Shr => "Shr",
        Op::Sar => "Sar",
        Op::Equal => "Equal",
        Op::NotEqual => "NotEqual",
        Op::Greater => "Greater",
        Op::GreaterOrEqual => "GreaterOrEqual",
        Op::Less => "Less",
        Op::LessOrEqual => "LessOrEqual",
        Op::Phi => "Phi",
        Op::DivZeroCheck => "DivZeroCheck",
        Op::ArrayGet => "ArrayGet",
        Op::ArraySet => "ArraySet",
        Op::ArrayLength => "ArrayLength",
        Op::FieldGet => "FieldGet",
        Op::FieldSet => "FieldSet",
        Op::Arg => "Arg",
    }
}

class Inst {
    var id: Int32 = -1i32;
    var block: Option[Block] = None;

    var op: Option[Op] = None;

    var aux: Int64 = 0;

    var previous: Option[Inst] = None;
    var next: Option[Inst] = None;

    var ty: Type = Type::Unit;

    var useListHead: Option[Input] = None;
    var useListTail: Option[Input] = None;

    var inputs: Vec[Input] = Vec();
    var block1: Option[Block] = None;
    var block2: Option[Block] = None;

    fn isPhi(): Bool {
        self.op.getOrPanic() == Op::Phi
    }

    fn getType(): Type {
        return self.ty;
    }

    fn addInput(inst: Inst) {
        let input = Input(self.inputs.size().toInt32(), inst, self);
        self.inputs.push(input);
    }

    fn addUse(input: Input) {
        assert(input.value === self);

        if self.useListHead.isNone() {
            assert(self.useListTail.isNone());
            input.previousUse = None;
            input.nextUse = None;

            self.useListHead = Some(input);
            self.useListTail = Some(input);
        } else {
            assert(self.useListHead.isSome());
            assert(self.useListTail.isSome());

            self.useListTail.getOrPanic().nextUse = Some(input);

            input.previousUse = self.useListTail;
            input.nextUse = None;

            self.useListTail = Some(input);
        }
    }

    fn remove() {
        assert(!self.hasUses());
        assert(self.block.isSome());

        self.removeAsUser();
        let block = self.block.getOrPanic();

        if self.isPhi() {
            block.phis.removeInst(self);
        } else {
            block.instructions.removeInst(self);
        }

        self.block = None;
    }

    fn registerUses() {
        for input in self.inputs {
            input.value.addUse(input);
        }
    }

    fn removeAsUser() {
        for input in self.inputs {
            removeUse(input);
        }
    }

    fn hasUses(): Bool {
        let result = self.useListHead.isSome();
        assert(result == self.useListTail.isSome());
        result
    }

    fn replaceWith(replacement: Inst) {
        while self.useListHead.isSome() {
            let input = self.useListHead.getOrPanic();
            input.usedBy.replaceInput(replacement, input.idx);
        }
    }

    fn replaceInput(replacement: Inst, idx: Int32) {
        let input = self.inputs(idx.toInt64());

        if input.value === replacement {
            return;
        }

        removeUse(input);
        input.value = replacement;
        replacement.addUse(input);
    }

    fn users(): Array[Inst] {
        let data = Vec[Inst]();
        var current = self.useListHead;

        while current.isSome() {
            let cur = current.getOrPanic();
            data.push(cur.usedBy);
            current = cur.nextUse;
        }

        data.toArray()
    }

    fn uses(): UseIterator {
        UseIterator(self)
    }

    fn dominates(other: Inst): Bool {
        let sblock = self.block.getOrPanic();
        let oblock = other.block.getOrPanic();

        if sblock === oblock {
            var current = self.next;

            while current.isSome() {
                let currentInst = current.getOrPanic();

                if currentInst === other {
                    return true;
                }

                current = currentInst.next;
            }

            false
        } else {
            sblock.dominates(oblock)
        }
    }

    fn isTerminator(): Bool {
        match self.op.getOrPanic() {
            Op::Goto => true,
            Op::If => true,
            Op::Return => true,
            _ => false,
        }
    }

    fn auxAsInt32(): Int32 {
        let op = self.op.getOrPanic();

        assert(
            op == Op::Int32Const ||
            op == Op::LoadGlobal ||
            op == Op::StoreGlobal ||
            op == Op::Arg
        );
        self.aux.toInt32()
    }

    fn auxAsInt64(): Int64 {
        assert(self.op.getOrPanic() == Op::Int64Const);
        self.aux
    }

    fn auxAsFloat32(): Float32 {
        assert(self.op.getOrPanic() == Op::Float32Const);
        self.aux.toInt32().asFloat32()
    }

    fn auxAsFloat64(): Float64 {
        assert(self.op.getOrPanic() == Op::Float64Const);
        self.aux.asFloat64()
    }

    fn hasSideEffects(): Bool {
        match self.op.getOrPanic() {
            Op::NullConst => false,
            Op::Int32Const => false,
            Op::Int64Const => false,
            Op::Float32Const => false,
            Op::Float64Const => false,
            Op::LoadGlobal => true,
            Op::StoreGlobal => true,
            Op::Undef => false,
            Op::BoundsCheck => true,
            Op::Goto => true,
            Op::If => true,
            Op::Return => true,
            Op::Neg => false,
            Op::Not => false,
            Op::Add => false,
            Op::Sub => false,
            Op::Mul => false,
            Op::Div => false,
            Op::Mod => false,
            Op::And => false,
            Op::Or => false,
            Op::Xor => false,
            Op::Shl => false,
            Op::Shr => false,
            Op::Sar => false,
            Op::Equal => false,
            Op::NotEqual => false,
            Op::Greater => false,
            Op::GreaterOrEqual => false,
            Op::Less => false,
            Op::LessOrEqual => false,
            Op::Phi => true,
            Op::DivZeroCheck => true,
            Op::ArrayGet => false,
            Op::ArraySet => true,
            Op::ArrayLength => false,
            Op::FieldGet => false,
            Op::FieldSet => true,
            Op::Arg => false,
        }
    }
}

class UseIterator(inst: Inst) {
    var current: Option[Input] = inst.useListHead;

    fn next(): Option[Input] {
        if self.current.isSome() {
            let input = self.current.getOrPanic();
            self.current = input.nextUse;
            Some[Input](input)
        } else {
            None[Input]
        }
    }
}

fn removeUse(input: Input) {
    let inst = input.value;

    if input.previousUse.isSome() {
        input.previousUse.getOrPanic().nextUse = input.nextUse;
    } else {
        inst.useListHead = input.nextUse;
    }

    if input.nextUse.isSome() {
        input.nextUse.getOrPanic().previousUse = input.previousUse;
    } else {
        inst.useListTail = input.previousUse;
    }

    assert(inst.useListHead.isSome() == inst.useListTail.isSome());

    input.previousUse = None;
    input.nextUse = None;
}

fn createNullConst(value: UInt8): Inst {
    let inst = Inst();
    inst.op = Some(Op::NullConst);
    inst
}

fn createInt32Const(value: Int32): Inst {
    let inst = Inst();
    inst.op = Some(Op::Int32Const);
    inst.aux = value.toInt64();
    inst
}

fn createInt64Const(value: Int64): Inst {
    let inst = Inst();
    inst.op = Some(Op::Int64Const);
    inst.aux = value;
    inst
}

fn createFloat32Const(value: Float32): Inst {
    let inst = Inst();
    inst.op = Some(Op::Float32Const);
    inst.aux = value.asInt32().toInt64();
    inst
}

fn createFloat64Const(value: Float64): Inst {
    let inst = Inst();
    inst.op = Some(Op::Float64Const);
    inst.aux = value.asInt64();
    inst
}

fn createLoadGlobalInst(ty: Type, global: GlobalId): Inst {
    let inst = Inst();
    inst.op = Some(Op::LoadGlobal);
    inst.ty = ty;
    inst.aux = global.value.toInt64();
    inst
}

fn createStoreGlobalInst(ty: Type, global: GlobalId, value: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::StoreGlobal);
    inst.aux = global.value.toInt64();
    inst.addInput(value);
    inst.ty = ty;
    inst
}


fn createUnaryInst(op: Op, ty: Type, opnd: Inst): Inst {
    let inst = Inst();
    inst.op = Some(op);
    inst.addInput(opnd);
    inst.ty = ty;
    inst
}

fn createBinaryInst(op: Op, ty: Type, lhs: Inst, rhs: Inst): Inst {
    let inst = Inst();
    inst.op = Some(op);
    inst.addInput(lhs);
    inst.addInput(rhs);
    inst.ty = ty;
    inst
}

fn createTestInst(opcode: Op, ty: Type, lhs: Inst, rhs: Inst): Inst {
    let inst = Inst();
    inst.op = Some(opcode);
    inst.addInput(lhs);
    inst.addInput(rhs);
    inst.ty = ty;
    inst
}

fn createUndefInst(): Inst {
    let inst = Inst();
    inst.op = Some(Op::Undef);
    inst
}

fn createPhiInst(): Inst {
    let inst = Inst();
    inst.op = Some(Op::Phi);
    inst
}

fn createBoundsCheck(index: Inst, length: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::BoundsCheck);
    inst.addInput(index);
    inst.addInput(length);
    inst
}

fn createDivZeroCheck(value: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::DivZeroCheck);
    inst.addInput(value);
    inst
}

fn createArrayGet(array: Inst, index: Inst, ty: Type): Inst {
    let inst = Inst();
    inst.op = Some(Op::ArrayGet);
    inst.ty = ty;
    inst.addInput(array);
    inst.addInput(index);
    inst
}

fn createArraySet(array: Inst, index: Inst, value: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::ArraySet);
    inst.addInput(array);
    inst.addInput(index);
    inst.addInput(value);
    inst
}

fn createArrayLength(array: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::ArrayLength);
    inst.addInput(array);
    inst
}

class FieldInfo(let offset: Int32, let volatile: Bool)

fn createFieldGet(obj: Inst, field: FieldInfo, ty: Type): Inst {
    let inst = Inst();
    inst.op = Some(Op::FieldGet);
    inst.ty = ty;
    inst.addInput(obj);
    inst
}

fn createFieldSet(obj: Inst, field: FieldInfo, value: Inst): Inst {
    let inst = Inst();
    inst.op = Some(Op::FieldSet);
    inst.addInput(obj);
    inst.addInput(value);
    inst
}

fn createArgInst(index: Int32, ty: Type): Inst {
    let inst = Inst();
    inst.op = Some(Op::Arg);
    inst.ty = ty;
    inst.aux = index.toInt64();
    inst
}

fn createReturnInst(value: Inst, ty: Type): Inst {
    let inst = Inst();
    inst.op = Some(Op::Return);
    inst.ty = ty;
    inst.addInput(value);
    inst
}

fn createReturnVoidInst(): Inst {
    let inst = Inst();
    inst.op = Some(Op::Return);
    inst.ty = Type::Unit;
    inst
}

fn createIfInst(cond: Inst, thenBlock: Block, elseBlock: Block): Inst {
    let inst = Inst();
    inst.op = Some(Op::If);
    inst.block1 = Some(thenBlock);
    inst.block2 = Some(elseBlock);
    inst.addInput(cond);
    inst
}

fn createGotoInst(block: Block): Inst {
    let inst = Inst();
    inst.op = Some(Op::Goto);
    inst.block1 = Some(block);
    inst
}

class InstLinkedList {
    var first: Option[Inst] = None;
    var last: Option[Inst] = None;

    fn isEmpty(): Bool {
        self.first.isNone()
    }

    fn firstInst(): Inst {
        self.first.getOrPanic()
    }

    fn lastInst(): Inst {
        self.last.getOrPanic()
    }

    fn appendInst(inst: Inst) {
        if self.first.isNone() {
            inst.previous = None;
            inst.next = None;

            self.first = Some(inst);
            self.last = Some(inst);
        } else {
            self.last.getOrPanic().next = Some(inst);

            inst.previous = self.last;
            inst.next = None;

            self.last = Some(inst);
        }
    }

    fn removeInst(inst: Inst) {
        if inst.previous.isSome() {
            let previous = inst.previous.getOrPanic();
            previous.next = inst.next;
        } else {
            self.first = inst.next;
        }

        if inst.next.isSome() {
            let next = inst.next.getOrPanic();
            next.previous = inst.previous;
        } else {
            self.last = inst.previous;
        }
    }
}

class InstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.first;

    fn next(): Option[Inst] {
        if self.current.isSome() {
            let inst = self.current.getOrPanic();
            self.current = inst.next;
            Some[Inst](inst)
        } else {
            None[Inst]
        }
    }
}

class PhiInstIterator(block: Block) {
    var current: Option[Inst] = block.phis.first;

    fn next(): Option[Inst] {
        if self.current.isSome() {
            let inst = self.current.getOrPanic();
            self.current = inst.next;
            Some[Inst](inst)
        } else {
            None[Inst]
        }
    }
}

class BackwardInstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.last;

    fn next(): Option[Inst] {
        if self.current.isSome() {
            let inst = self.current.getOrPanic();
            self.current = inst.previous;
            Some[Inst](inst)
        } else {
            None[Inst]
        }
    }
}

class Edge(let source: Block, let target: Block) {
    var backward: Bool = false;

    fn markAsBackwardEdge() {
        assert(!self.backward);
        self.backward = true;
    }
}
