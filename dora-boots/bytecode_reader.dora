fn readBytecode(code: Array[UInt8], visitor: BytecodeVisitor) {
    BytecodeReader(code, visitor).read();
}

@open @abstract class BytecodeVisitor {
    @open fn visitInstruction(offset: Int32) {}

    @open fn visitAdd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitSub(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitNeg(dest: BytecodeRegister, src: BytecodeRegister) { unimplemented(); }
    @open fn visitMul(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitDiv(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    @open fn visitMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitAnd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitOr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitXor(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitNot(dest: BytecodeRegister, src: BytecodeRegister) { unimplemented(); }
    @open fn visitShl(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitShr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitSar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    @open fn visitInstanceOf(dest: BytecodeRegister, src: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitCheckedCast(src: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitMov(dest: BytecodeRegister, src: BytecodeRegister) { unimplemented(); }

    @open fn visitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitStoreField(src: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) { unimplemented(); }
    @open fn visitStoreGlobal(src: BytecodeRegister, glob: GlobalId) { unimplemented(); }

    @open fn visitPushRegister(src: BytecodeRegister) { unimplemented(); }

    @open fn visitConstTrue(dest: BytecodeRegister) { unimplemented(); }
    @open fn visitConstFalse(dest: BytecodeRegister) { unimplemented(); }
    @open fn visitConstUInt8(dest: BytecodeRegister, value: UInt8) { unimplemented(); }
    @open fn visitConstChar(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitConstInt32(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitConstInt64(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitConstFloat32(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitConstFloat64(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitConstString(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitTestIdentity(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestEq(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestNe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestGt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestGe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestLt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @open fn visitTestLe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    @open fn visitLoopStart() { unimplemented(); }
    @open fn visitJumpLoop(offset: Int32) { unimplemented(); }

    @open fn visitJumpIfFalse(opnd: BytecodeRegister, offset: Int32) { unimplemented(); }
    @open fn visitJumpIfFalseConst(opnd: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitJumpIfTrue(opnd: BytecodeRegister, offset: Int32) { unimplemented(); }
    @open fn visitJumpIfTrueConst(opnd: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitJump(offset: Int32) { unimplemented(); }
    @open fn visitJumpConst(idx: ConstPoolId) { unimplemented(); }

    @open fn visitInvokeDirectVoid(idx: ConstPoolId) { unimplemented(); }
    @open fn visitInvokeDirect(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitInvokeVirtualVoid(idx: ConstPoolId) { unimplemented(); }
    @open fn visitInvokeVirtual(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitInvokeStaticVoid(idx: ConstPoolId) { unimplemented(); }
    @open fn visitInvokeStatic(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @open fn visitNewObject(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @open fn visitNewArray(dest: BytecodeRegister, idx: ConstPoolId, length: BytecodeRegister) { unimplemented(); }
    
    @open fn visitNilCheck(obj: BytecodeRegister) { unimplemented(); }

    @open fn visitArrayLength(dest: BytecodeRegister, arr: BytecodeRegister) { unimplemented(); }
    @open fn visitArrayBoundCheck(arr: BytecodeRegister, idx: BytecodeRegister) { unimplemented(); }

    @open fn visitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { unimplemented(); }
    @open fn visitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { unimplemented(); }

    @open fn visitRetVoid() { unimplemented(); }
    @open fn visitRet(opnd: BytecodeRegister) { unimplemented(); }
}

@open @abstract class EmptyBytecodeVisitor: BytecodeVisitor {
    @override fn visitAdd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitSub(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitNeg(dest: BytecodeRegister, src: BytecodeRegister) {}
    @override fn visitMul(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitDiv(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitAnd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitOr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitXor(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitNot(dest: BytecodeRegister, src: BytecodeRegister) {}
    @override fn visitShl(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitShr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitSar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}

    @override fn visitInstanceOf(dest: BytecodeRegister, src: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitCheckedCast(src: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitMov(dest: BytecodeRegister, src: BytecodeRegister) {}

    @override fn visitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitStoreField(src: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) {}
    @override fn visitStoreGlobal(src: BytecodeRegister, glob: GlobalId) {}

    @override fn visitPushRegister(src: BytecodeRegister) {}

    @override fn visitConstTrue(dest: BytecodeRegister) {}
    @override fn visitConstFalse(dest: BytecodeRegister) {}
    @override fn visitConstUInt8(dest: BytecodeRegister, value: UInt8) {}
    @override fn visitConstChar(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitConstInt32(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitConstInt64(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitConstFloat32(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitConstFloat64(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitConstString(dest: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitTestIdentity(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestEq(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestNe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestGt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestGe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestLt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}
    @override fn visitTestLe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {}

    @override fn visitLoopStart() {}
    @override fn visitJumpLoop(offset: Int32) {}

    @override fn visitJumpIfFalse(opnd: BytecodeRegister, offset: Int32) {}
    @override fn visitJumpIfFalseConst(opnd: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitJumpIfTrue(opnd: BytecodeRegister, offset: Int32) {}
    @override fn visitJumpIfTrueConst(opnd: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitJump(offset: Int32) {}
    @override fn visitJumpConst(idx: ConstPoolId) {}

    @override fn visitInvokeDirectVoid(idx: ConstPoolId) {}
    @override fn visitInvokeDirect(dest: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitInvokeVirtualVoid(idx: ConstPoolId) {}
    @override fn visitInvokeVirtual(dest: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitInvokeStaticVoid(idx: ConstPoolId) {}
    @override fn visitInvokeStatic(dest: BytecodeRegister, idx: ConstPoolId) {}

    @override fn visitNewObject(dest: BytecodeRegister, idx: ConstPoolId) {}
    @override fn visitNewArray(dest: BytecodeRegister, idx: ConstPoolId, length: BytecodeRegister) {}

    @override fn visitNilCheck(obj: BytecodeRegister) {}

    @override fn visitArrayLength(dest: BytecodeRegister, arr: BytecodeRegister) {}
    @override fn visitArrayBoundCheck(arr: BytecodeRegister, idx: BytecodeRegister) {}

    @override fn visitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {}
    @override fn visitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {}

    @override fn visitRetVoid() {}
    @override fn visitRet(opnd: BytecodeRegister) {}
}

class BytecodeReader(let data: Array[UInt8], let visitor: BytecodeVisitor) {
    var pos: Int32 = 0;
    var length: Int32 = data.size().toInt32();

    fn read() {
        while self.pos < self.length {
            self.visitor.visitInstruction(self.pos);
            let wide = self.hasWideOperands();
            let opcode = self.readOpcode();
            self.readInstruction(wide, opcode);
        }
    }

    fn readInstruction(wide: Bool, opcode: Int32) {
        if opcode == BC_WIDE {
            fatalError("unexpected WIDE");

        } else if opcode == BC_ADD {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitAdd(dest, lhs, rhs);

        } else if opcode == BC_SUB {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitSub(dest, lhs, rhs);

        } else if opcode == BC_NEG {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            self.visitor.visitNeg(dest, src);

        } else if opcode == BC_MUL {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitMul(dest, lhs, rhs);

        } else if opcode == BC_DIV {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitDiv(dest, lhs, rhs);

        } else if opcode == BC_MOD {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitMod(dest, lhs, rhs);

        } else if opcode == BC_AND {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitAnd(dest, lhs, rhs);

        } else if opcode == BC_OR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitOr(dest, lhs, rhs);

        } else if opcode == BC_XOR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitXor(dest, lhs, rhs);

        } else if opcode == BC_NOT {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            self.visitor.visitNot(dest, src);

        } else if opcode == BC_SHL {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitShl(dest, lhs, rhs);
        } else if opcode == BC_SHR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitShr(dest, lhs, rhs);
        } else if opcode == BC_SAR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitSar(dest, lhs, rhs);

        } else if opcode == BC_INSTANCE_OF {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitInstanceOf(dest, src, idx);

        } else if opcode == BC_CHECKED_CAST {
            let src = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitCheckedCast(src, idx);

        } else if opcode == BC_MOV {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            self.visitor.visitMov(dest, src);

        } else if opcode == BC_LOAD_FIELD {
            let dest = self.readRegister(wide);
            let obj = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitLoadField(dest, obj, idx);
        } else if opcode == BC_STORE_FIELD {
            let src = self.readRegister(wide);
            let obj = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitStoreField(src, obj, idx);

        } else if opcode == BC_LOAD_GLOBAL {
            let dest = self.readRegister(wide);
            let glob = self.readGlobalId(wide);
            self.visitor.visitLoadGlobal(dest, glob);
        } else if opcode == BC_STORE_GLOBAL {
            let src = self.readRegister(wide);
            let glob = self.readGlobalId(wide);
            self.visitor.visitStoreGlobal(src, glob);

        } else if opcode == BC_PUSH_REGISTER {
            let src = self.readRegister(wide);
            self.visitor.visitPushRegister(src);

        } else if opcode == BC_CONST_TRUE {
            let dest = self.readRegister(wide);
            self.visitor.visitConstTrue(dest);
        } else if opcode == BC_CONST_FALSE {
            let dest = self.readRegister(wide);
            self.visitor.visitConstFalse(dest);
        } else if opcode == BC_CONST_UINT8 {
            let dest = self.readRegister(wide);
            let value = self.readByte().toUInt8();
            self.visitor.visitConstUInt8(dest, value);
        } else if opcode == BC_CONST_CHAR {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstChar(dest, idx);
        } else if opcode == BC_CONST_INT32 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstInt32(dest, idx);
        } else if opcode == BC_CONST_INT64 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstInt64(dest, idx);
        } else if opcode == BC_CONST_FLOAT32{
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstFloat32(dest, idx);
        } else if opcode == BC_CONST_FLOAT64 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstFloat64(dest, idx);
        } else if opcode == BC_CONST_STRING {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitConstString(dest, idx);

        } else if opcode == BC_TEST_EQ {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestEq(dest, lhs, rhs);
        } else if opcode == BC_TEST_NE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestNe(dest, lhs, rhs);
        } else if opcode == BC_TEST_GT {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestGt(dest, lhs, rhs);
        } else if opcode == BC_TEST_GE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestGe(dest, lhs, rhs);
        } else if opcode == BC_TEST_LT {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestLt(dest, lhs, rhs);
        } else if opcode == BC_TEST_LE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            self.visitor.visitTestLe(dest, lhs, rhs);

        } else if opcode == BC_LOOP_START {
            self.visitor.visitLoopStart();

        } else if opcode == BC_JUMP_LOOP {
            let offset = self.readOffset(wide);
            self.visitor.visitJumpLoop(offset);

        } else if opcode == BC_JUMP_IF_FALSE {
            let opnd = self.readRegister(wide);
            let offset = self.readOffset(wide);
            self.visitor.visitJumpIfFalse(opnd, offset);
        } else if opcode == BC_JUMP_IF_FALSE_CONST {
            let opnd = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitJumpIfFalseConst(opnd, idx);
        } else if opcode == BC_JUMP_IF_TRUE {
            let opnd = self.readRegister(wide);
            let offset = self.readOffset(wide);
            self.visitor.visitJumpIfTrue(opnd, offset);
        } else if opcode == BC_JUMP_IF_TRUE_CONST {
            let opnd = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitJumpIfTrueConst(opnd, idx);
        } else if opcode == BC_JUMP {
            let offset = self.readOffset(wide);
            self.visitor.visitJump(offset);
        } else if opcode == BC_JUMP_CONST {
            let idx = self.readConstPoolId(wide);
            self.visitor.visitJumpConst(idx);

        } else if opcode == BC_INVOKE_DIRECT_VOID {
            let idx = self.readConstPoolId(wide);
            self.visitor.visitInvokeDirectVoid(idx);
        } else if opcode == BC_INVOKE_DIRECT {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitInvokeDirect(dest, idx);

        } else if opcode == BC_INVOKE_VIRTUAL_VOID {
            let fct = self.readConstPoolId(wide);
            self.visitor.visitInvokeVirtualVoid(fct);
        } else if opcode == BC_INVOKE_VIRTUAL {
            let dest = self.readRegister(wide);
            let fct = self.readConstPoolId(wide);
            self.visitor.visitInvokeVirtual(dest, fct);

        } else if opcode == BC_INVOKE_STATIC_VOID {
            let fct = self.readConstPoolId(wide);
            self.visitor.visitInvokeStaticVoid(fct);
        } else if opcode == BC_INVOKE_STATIC {
            let dest = self.readRegister(wide);
            let fct = self.readConstPoolId(wide);
            self.visitor.visitInvokeStatic(dest, fct);

        } else if opcode == BC_NEW_OBJECT {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            self.visitor.visitNewObject(dest, idx);
        } else if opcode == BC_NEW_ARRAY {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            let length = self.readRegister(wide);
            self.visitor.visitNewArray(dest, idx, length);

        } else if opcode == BC_NIL_CHECK {
            let obj = self.readRegister(wide);
            self.visitor.visitNilCheck(obj);
        } else if opcode == BC_ARRAY_BOUND_CHECK {
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            self.visitor.visitArrayBoundCheck(arr, idx);
        } else if opcode == BC_ARRAY_LENGTH {
            let dest = self.readRegister(wide);
            let arr = self.readRegister(wide);
            self.visitor.visitArrayLength(dest, arr);

        } else if opcode == BC_LOAD_ARRAY {
            let dest = self.readRegister(wide);
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            self.visitor.visitLoadArray(dest, arr, idx);

        } else if opcode == BC_STORE_ARRAY {
            let src = self.readRegister(wide);
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            self.visitor.visitStoreArray(src, arr, idx);

        } else if opcode == BC_RET_VOID {
            self.visitor.visitRetVoid();
        } else if opcode == BC_RET {
            let opnd = self.readRegister(wide);
            self.visitor.visitRet(opnd);

        } else {
            fatalError("unkown opcode ${opcode} ${bytecodeName(opcode)}");
        }
    }

    fn readRegister(wide: Bool): BytecodeRegister {
        BytecodeRegister(self.readIndex(wide))
    }

    fn hasWideOperands(): Bool {
        let data = self.data;
        let value = data(self.pos.toInt64());

        if value.toInt32() == BC_WIDE {
            self.pos = self.pos + 1i32;
            true
        } else {
            false
        }
    }

    fn readOpcode(): Int32 {
        let first = self.readByte();

        if first == 255i32 {
            let second = self.readByte();
            second + 255i32
        } else {
            first
        }
    }

    fn readGlobalId(wide: Bool): GlobalId {
        GlobalId(self.readIndex(wide))
    }

    fn readConstPoolId(wide: Bool): ConstPoolId {
        ConstPoolId(self.readIndex(wide))
    }

    fn readOffset(wide: Bool): Int32 {
        self.readIndex(wide)
    }

    fn readIndex(wide: Bool): Int32 {
        if wide {
            self.readInt32()
        } else {
            self.readByte()
        }
    }

    fn readByte(): Int32 {
        let data = self.data;
        let value = data(self.pos.toInt64());
        self.pos = self.pos + 1i32;

        value.toInt32()
    }

    fn readInt32(): Int32 {
        let by1 = self.readByte();
        let by2 = self.readByte();
        let by3 = self.readByte();
        let by4 = self.readByte();

        (by4 << 24i32) | (by3 << 16i32) | (by2 << 8i32) | by1
    }
}

class BytecodeIterator(let data: Array[UInt8]) {
    var pos: Int64 = 0;
    var length: Int64 = data.size();

    fn readInstruction(): Option[InstructionData] {
        if self.pos == self.length {
            return None;
        }

        let start = self.pos;
        let (wide, opcode) = self.readOpcode();

        let inst = if opcode == BC_WIDE {
            fatalError("unexpected WIDE");
            unreachable[BytecodeInstruction]()

        } else if opcode == BC_ADD {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Add(dest, lhs, rhs)

        } else if opcode == BC_SUB {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Sub(dest, lhs, rhs)

        } else if opcode == BC_NEG {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            BytecodeInstruction::Neg(dest, src)

        } else if opcode == BC_MUL {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Mul(dest, lhs, rhs)

        } else if opcode == BC_DIV {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Div(dest, lhs, rhs)

        } else if opcode == BC_MOD {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Mod(dest, lhs, rhs)

        } else if opcode == BC_AND {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::And(dest, lhs, rhs)

        } else if opcode == BC_OR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Or(dest, lhs, rhs)

        } else if opcode == BC_XOR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Xor(dest, lhs, rhs)

        } else if opcode == BC_NOT {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            BytecodeInstruction::Not(dest, src)

        } else if opcode == BC_SHL {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Shl(dest, lhs, rhs)

        } else if opcode == BC_SHR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Shr(dest, lhs, rhs)

        } else if opcode == BC_SAR {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::Sar(dest, lhs, rhs)

        } else if opcode == BC_INSTANCE_OF {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::InstanceOf(dest, src, idx)

        } else if opcode == BC_CHECKED_CAST {
            let src = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::CheckedCast(src, idx)

        } else if opcode == BC_MOV {
            let dest = self.readRegister(wide);
            let src = self.readRegister(wide);
            BytecodeInstruction::Mov(dest, src)

        } else if opcode == BC_LOAD_FIELD {
            let dest = self.readRegister(wide);
            let obj = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::LoadField(dest, obj, idx)
        } else if opcode == BC_STORE_FIELD {
            let src = self.readRegister(wide);
            let obj = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::StoreField(src, obj, idx)

        } else if opcode == BC_LOAD_GLOBAL {
            let dest = self.readRegister(wide);
            let glob = self.readGlobalId(wide);
            BytecodeInstruction::LoadGlobal(dest, glob)
        } else if opcode == BC_STORE_GLOBAL {
            let src = self.readRegister(wide);
            let glob = self.readGlobalId(wide);
            BytecodeInstruction::StoreGlobal(src, glob)

        } else if opcode == BC_PUSH_REGISTER {
            let src = self.readRegister(wide);
            BytecodeInstruction::PushRegister(src)

        } else if opcode == BC_CONST_TRUE {
            let dest = self.readRegister(wide);
            BytecodeInstruction::ConstTrue(dest)
        } else if opcode == BC_CONST_FALSE {
            let dest = self.readRegister(wide);
            BytecodeInstruction::ConstFalse(dest)
        } else if opcode == BC_CONST_UINT8 {
            let dest = self.readRegister(wide);
            let value = self.readByte().toUInt8();
            BytecodeInstruction::ConstUInt8(dest, value)
        } else if opcode == BC_CONST_CHAR {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstChar(dest, idx)
        } else if opcode == BC_CONST_INT32 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstInt32(dest, idx)
        } else if opcode == BC_CONST_INT64 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstInt64(dest, idx)
        } else if opcode == BC_CONST_FLOAT32{
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstFloat32(dest, idx)
        } else if opcode == BC_CONST_FLOAT64 {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstFloat64(dest, idx)
        } else if opcode == BC_CONST_STRING {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::ConstString(dest, idx)

        } else if opcode == BC_TEST_EQ {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestEq(dest, lhs, rhs)
        } else if opcode == BC_TEST_NE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestNe(dest, lhs, rhs)
        } else if opcode == BC_TEST_GT {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestGt(dest, lhs, rhs)
        } else if opcode == BC_TEST_GE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestGe(dest, lhs, rhs)
        } else if opcode == BC_TEST_LT {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestLt(dest, lhs, rhs)
        } else if opcode == BC_TEST_LE {
            let dest = self.readRegister(wide);
            let lhs = self.readRegister(wide);
            let rhs = self.readRegister(wide);
            BytecodeInstruction::TestLe(dest, lhs, rhs)

        } else if opcode == BC_LOOP_START {
            BytecodeInstruction::LoopStart

        } else if opcode == BC_JUMP_LOOP {
            let offset = self.readOffset(wide);
            BytecodeInstruction::JumpLoop(offset)

        } else if opcode == BC_JUMP_IF_FALSE {
            let opnd = self.readRegister(wide);
            let offset = self.readOffset(wide);
            BytecodeInstruction::JumpIfFalse(opnd, offset)
        } else if opcode == BC_JUMP_IF_FALSE_CONST {
            let opnd = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::JumpIfFalseConst(opnd, idx)
        } else if opcode == BC_JUMP_IF_TRUE {
            let opnd = self.readRegister(wide);
            let offset = self.readOffset(wide);
            BytecodeInstruction::JumpIfTrue(opnd, offset)
        } else if opcode == BC_JUMP_IF_TRUE_CONST {
            let opnd = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::JumpIfTrueConst(opnd, idx)
        } else if opcode == BC_JUMP {
            let offset = self.readOffset(wide);
            BytecodeInstruction::Jump(offset)
        } else if opcode == BC_JUMP_CONST {
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::JumpConst(idx)

        } else if opcode == BC_INVOKE_DIRECT_VOID {
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeDirectVoid(fct)
        } else if opcode == BC_INVOKE_DIRECT {
            let dest = self.readRegister(wide);
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeDirect(dest, fct)

        } else if opcode == BC_INVOKE_VIRTUAL_VOID {
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeVirtualVoid(fct)
        } else if opcode == BC_INVOKE_VIRTUAL {
            let dest = self.readRegister(wide);
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeVirtual(dest, fct)

        } else if opcode == BC_INVOKE_STATIC_VOID {
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeStaticVoid(fct)
        } else if opcode == BC_INVOKE_STATIC {
            let dest = self.readRegister(wide);
            let fct = self.readConstPoolId(wide);
            BytecodeInstruction::InvokeStatic(dest, fct)

        } else if opcode == BC_NEW_OBJECT {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            BytecodeInstruction::NewObject(dest, idx)
        } else if opcode == BC_NEW_ARRAY {
            let dest = self.readRegister(wide);
            let idx = self.readConstPoolId(wide);
            let length = self.readRegister(wide);
            BytecodeInstruction::NewArray(dest, idx, length)

        } else if opcode == BC_NIL_CHECK {
            let obj = self.readRegister(wide);
            BytecodeInstruction::NilCheck(obj)
        } else if opcode == BC_ARRAY_BOUND_CHECK {
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            BytecodeInstruction::ArrayBoundCheck(arr, idx)
        } else if opcode == BC_ARRAY_LENGTH {
            let dest = self.readRegister(wide);
            let arr = self.readRegister(wide);
            BytecodeInstruction::ArrayLength(dest, arr)

        } else if opcode == BC_LOAD_ARRAY {
            let dest = self.readRegister(wide);
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            BytecodeInstruction::LoadArray(dest, arr, idx)

        } else if opcode == BC_STORE_ARRAY {
            let src = self.readRegister(wide);
            let arr = self.readRegister(wide);
            let idx = self.readRegister(wide);
            BytecodeInstruction::StoreArray(src, arr, idx)

        } else if opcode == BC_RET_VOID {
            BytecodeInstruction::RetVoid
        } else if opcode == BC_RET {
            let opnd = self.readRegister(wide);
            BytecodeInstruction::Ret(opnd)

        } else {
            fatalError("unkown opcode ${opcode} ${bytecodeName(opcode)}");
            unreachable[BytecodeInstruction]()
        };

        let size = self.pos - start;
        Some(InstructionData(start, opcode, size, inst))
    }

    fn readRegister(wide: Bool): BytecodeRegister {
        BytecodeRegister(self.readIndex(wide))
    }

    fn readOpcode(): (Bool, Int32) {
        let opcode = self.readByte();

        if opcode == BC_WIDE {
            let opcode = self.readByte();
            (true, opcode)
        } else {
            (false, opcode)
        }
    }

    fn readGlobalId(wide: Bool): GlobalId {
        GlobalId(self.readIndex(wide))
    }

    fn readConstPoolId(wide: Bool): ConstPoolId {
        ConstPoolId(self.readIndex(wide))
    }

    fn readOffset(wide: Bool): Int32 {
        self.readIndex(wide)
    }

    fn readIndex(wide: Bool): Int32 {
        if wide {
            self.readInt32()
        } else {
            self.readByte()
        }
    }

    fn readByte(): Int32 {
        let value = self.data(self.pos);
        self.pos = self.pos + 1;

        value.toInt32()
    }

    fn readInt32(): Int32 {
        let by1 = self.readByte();
        let by2 = self.readByte();
        let by3 = self.readByte();
        let by4 = self.readByte();

        (by4 << 24i32) | (by3 << 16i32) | (by2 << 8i32) | by1
    }
}

struct InstructionData {
    start: Int64,
    opcode: Int32,
    size: Int64,
    inst: BytecodeInstruction,
}