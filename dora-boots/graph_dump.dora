fn dumpGraph(graph: Graph): String {
    GraphDumper(graph).dump()
}

class GraphDumper(let graph: Graph) {
    let buffer: StringBuffer = StringBuffer();

    fn dump(): String {
        for block in self.graph.insertionOrderIterator() {
            self.dumpBlock(block);
        }

        self.buffer.toString()
    }

    fn dumpBlock(block: Block) {
        self.buffer.append("@${block.id}:");

        if !block.predecessors.isEmpty() {
            self.buffer.append(" pred = [");
            var first: Bool = true;

            for pred in block.predecessors {
                if first {
                    self.buffer.append("@${pred.source.id}");
                } else {
                    self.buffer.append(", @${pred.source.id}");
                }

                first = false;
            }

            self.buffer.append("]");
        }

        if !block.successors.isEmpty() {
            self.buffer.append(" succ = [");
            var first: Bool = true;

            for succ in block.successors {
                if first {
                    self.buffer.append("@${succ.target.id}");
                } else {
                    self.buffer.append(", @${succ.target.id}");
                }

                first = false;
            }

            self.buffer.append("]");
        }

        self.buffer.appendNewline();

        for inst in block.phisIterator() {
            self.dumpInst(inst);
        }

        for inst in block.instructionsIterator() {
            self.dumpInst(inst);
        }
    }

    fn dumpInst(inst: Inst) {
        self.buffer.append("  %${inst.id}: ${dumpInstName(inst)}");

        if !inst.inputs.isEmpty() {
            var first = true;

            for inp in inst.inputs {
                if first {
                    self.buffer.append(" %${inp.value.id}");
                } else {
                    self.buffer.append(", %${inp.value.id}");
                }

                first = false;
            }
        }

        if inst.hasUses() {
            var current = inst.useListHead;

            self.buffer.append(" [");
            var first = true;

            while current.isSome() {
                let c = current.getOrPanic();

                if first {
                    self.buffer.append("%${c.usedBy.id}");
                } else {
                    self.buffer.append(", %${c.usedBy.id}");
                }

                current = c.nextUse;
                first = false;
            }

            self.buffer.append("]");
        }

        self.buffer.appendNewline();
    }
}

fn dumpInstName(inst: Inst): String {
    let op = inst.op.getOrPanic();
    match op {
        Op::NullConst => "Const.Null",
        Op::Int32Const => "Const.Int32(#${inst.auxAsInt32()})",
        Op::Int64Const => "Const.Int64(#${inst.auxAsInt64()})",
        Op::Float32Const => "Const.Float32(#${inst.auxAsFloat32()})",
        Op::Float64Const => "Const.Float64(#${inst.auxAsFloat64()})",
        Op::LoadGlobal => "LoadGlobal.${inst.ty}(${inst.auxAsInt32()})",
        Op::StoreGlobal => "StoreGlobal.${inst.ty}(${inst.auxAsInt32()})",
        Op::Undef => "Undef",
        Op::BoundsCheck => "BoundsCheck",
        Op::Goto => {
            "Goto(@${inst.block1.getOrPanic().id})"
        },
        Op::If => {
            "If(@${inst.block1.getOrPanic().id}, @${inst.block2.getOrPanic().id})"
        },
        Op::Return => {
            if inst.ty.isUnit() {
                "Ret.Void"
            } else {
                "Ret.${inst.ty}"
            }
        },
        Op::Neg => "Neg.${inst.ty}",
        Op::Not => "Not.${inst.ty}",
        Op::Add => "Add.${inst.ty}",
        Op::Sub => "Sub.${inst.ty}",
        Op::Mul => "Mul.${inst.ty}",
        Op::Div => "Div.${inst.ty}",
        Op::Mod => "Mod.${inst.ty}",
        Op::And => "And.${inst.ty}",
        Op::Or => "Or.${inst.ty}",
        Op::Xor => "Xor.${inst.ty}",
        Op::Shl => "Shl.${inst.ty}",
        Op::Shr => "Shr.${inst.ty}",
        Op::Sar => "Sar.${inst.ty}",
        Op::Equal => "Equal.${inst.ty}",
        Op::NotEqual => "NotEqual.${inst.ty}",
        Op::Greater => "Greater.${inst.ty}",
        Op::GreaterOrEqual => "GreaterOrEqual.${inst.ty}",
        Op::Less => "Less.${inst.ty}",
        Op::LessOrEqual => "LessOrEqual.${inst.ty}",
        Op::Phi => "Phi",
        Op::DivZeroCheck => "DivZeroCheck",
        Op::ArrayGet => "ArrayGet.${inst.ty}",
        Op::ArraySet => "ArraySet",
        Op::ArrayLength => "ArrayLength",
        Op::FieldGet => "FieldGet.${inst.ty}",
        Op::FieldSet => "FieldSet",
        Op::Arg => "Arg.${inst.ty}(${inst.auxAsInt32()})",
    }
}

fn assertGraph(graph: Graph, output: String) {
    let graphOutput = dumpGraph(graph);

    if !compareStrings(graphOutput, output) {
        println("got: \"${graphOutput}\"");
        println("expected: \"${output}\"");

        for idx in range(0i32, graphOutput.size().toInt32()) {
            let value = graphOutput.getByte(idx.toInt64());
            print("${value.toInt32().toStringHex()} ");
        }

        println("");

        for idx in range(0i32, output.size().toInt32()) {
            let value = output.getByte(idx.toInt64());
            print("${value.toInt32().toStringHex()} ");
        }

        println("");

        fatalError("output does not match");
    }
}

fn compareStrings(lhs: String, rhs: String): Bool {
    var lhsIterator = lhs.codePoints();
    var rhsIterator = rhs.codePoints();

    skipWhite(lhsIterator);
    skipWhite(rhsIterator);

    while true {
        if !lhsIterator.hasNext() && !rhsIterator.hasNext() {
            return true;
        } else if !lhsIterator.hasNext() || !rhsIterator.hasNext() {
            return false;
        }

        var lhsChar = lhsIterator.next();
        var rhsChar = rhsIterator.next();

        if lhsChar == rhsChar {
            continue;
        }

        if lhsChar == 0xDu8.toChar() && lhsIterator.hasNext() && lhsIterator.peek() == 0xAu8.toChar() {
            lhsChar = lhsIterator.next();
        }

        if rhsChar == 0xDu8.toChar() && rhsIterator.hasNext() && rhsIterator.peek() == 0xAu8.toChar() {
            rhsChar = rhsIterator.next();
        }

        if lhsChar != rhsChar {
            return false;
        }
    }

    false
}

fn skipWhite(it: CodepointIterator) {
    while it.hasNext() {
        let ch = it.peek();

        if isWhite(ch) {
            it.next();
        } else {
            break;
        }
    }
}

fn isWhite(ch: Char): Bool {
    ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'
}