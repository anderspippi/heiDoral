class BytecodeFunction(let code: Array[UInt8], let const_pool: Array[ConstPoolEntry], let registers: Array[BytecodeType], let registers2: Array[BytecodeType2], let arguments: Int32) {
    fun constPool(idx: ConstPoolId): ConstPoolEntry {
        self.const_pool(idx.value.toInt64())
    }

    fun codeAt(idx: Int32): Int32 {
        self.code(idx.toInt64()).toInt32()
    }

    fun codeInt32At(idx: Int32): Int32 {
        let byte1 = self.codeAt(idx);
        let byte2 = self.codeAt(idx+1);
        let byte3 = self.codeAt(idx+2);
        let byte4 = self.codeAt(idx+3);

        (byte4 << 24) | (byte3 << 16) | (byte2 << 8) | byte1
    }
}

enum ConstPoolEntry {
    Int32(Int32),
    Int64(Int64),
    Float32(Float32),
    Float64(Float64),
    Char(Char),
    String(String),
}

impl ConstPoolEntry {
    fun toInt32(): Option[Int32] {
        match self {
            ConstPoolEntry::Int32(value) => Some(value),
            _ => None,
        }
    }

    fun toInt64(): Option[Int64] {
        match self {
            ConstPoolEntry::Int64(value) => Some(value),
            _ => None,
        }
    }

    fun toFloat32(): Option[Float32] {
        match self {
            ConstPoolEntry::Float32(value) => Some(value),
            _ => None,
        }
    }

    fun toFloat64(): Option[Float64] {
        match self {
            ConstPoolEntry::Float64(value) => Some(value),
            _ => None,
        }
    }
}

impl Stringable for ConstPoolEntry {
    fun toString(): String {
        match self {
            ConstPoolEntry::Int32(value) => "Int32 ${value}",
            ConstPoolEntry::Int64(value) => "Int64 ${value}",
            ConstPoolEntry::Float32(value) => "Float32 ${value}",
            ConstPoolEntry::Float64(value) => "Float64 ${value}",
            ConstPoolEntry::Char(value) => "Char ${value}",
            ConstPoolEntry::String(value) => "String ${value}",
        }
    }
}

enum SourceType {
    Unit,
    UInt8,
    Bool,
    Char,
    Int32,
    Int64,
    Float32,
    Float64,
    Class(Int32, Array[SourceType]),
    Struct(Int32, Array[SourceType]),
    Trait(Int32, Array[SourceType]),
    Tuple(Array[SourceType]),
    TypeParam(Int32),
}

struct BytecodeRegister(value: Int32)

impl Equals for BytecodeRegister {
    fun equals(other: BytecodeRegister): Bool {
        self.value == other.value
    }
}

impl Hash for BytecodeRegister {
    fun hash(): Int32 {
        self.value
    }
}

impl Stringable for BytecodeRegister {
    fun toString(): String = "r${self.value}";
}

struct ClassDefId(value: Int32)
struct FieldId(value: Int32)
struct GlobalId(value: Int32)
struct ConstPoolId(value: Int32)

impl ConstPoolId {
    fun equals(rhs: ConstPoolId): Bool {
        self.value == rhs.value
    }
}

struct FctId { value: Int32 }

enum BytecodeType2 {
    Ptr,
    UInt8,
    Bool,
    Char,
    Int32,
    Int64,
    Float32,
    Float64,
    Struct(Int32, Array[SourceType]),
    Tuple(Array[SourceType]),
    TypeParam(Int32),
}

impl Stringable for BytecodeType2 {
    fun toString(): String {
        match self {
            BytecodeType2::Ptr => "Ptr",
            BytecodeType2::UInt8 => "UInt8",
            BytecodeType2::Bool => "Bool",
            BytecodeType2::Char => "Char",
            BytecodeType2::Int32 => "Int32",
            BytecodeType2::Int64 => "Int64",
            BytecodeType2::Float32 => "Float32",
            BytecodeType2::Float64 => "Float64",
            BytecodeType2::Struct(id, params) => "Struct(${id}, <type params>)",
            BytecodeType2::Tuple(types) => "Tuple(<type params>)",
            BytecodeType2::TypeParam(idx) => "TypeParam(${idx})",
        }
    }
}

struct BytecodeType(value: Int32)

impl BytecodeType {
    fun isBool(): Bool {
        self.value == BC_TYPE_BOOL
    }

    fun isUInt8(): Bool {
        self.value == BC_TYPE_U_INT8
    }

    fun isChar(): Bool {
        self.value == BC_TYPE_CHAR
    }

    fun isInt32(): Bool {
        self.value == BC_TYPE_INT32
    }

    fun isInt64(): Bool {
        self.value == BC_TYPE_INT64
    }

    fun isFloat32(): Bool {
        self.value == BC_TYPE_FLOAT32
    }

    fun isFloat64(): Bool {
        self.value == BC_TYPE_FLOAT64
    }

    fun isPtr(): Bool {
        self.value == BC_TYPE_PTR
    }

    @static fun bool(): BytecodeType {
        BytecodeType(BC_TYPE_BOOL)
    }

    @static fun uint8(): BytecodeType {
        BytecodeType(BC_TYPE_U_INT8)
    }

    @static fun char(): BytecodeType {
        BytecodeType(BC_TYPE_CHAR)
    }

    @static fun int32(): BytecodeType {
        BytecodeType(BC_TYPE_INT32)
    }

    @static fun int64(): BytecodeType {
        BytecodeType(BC_TYPE_INT64)
    }

    @static fun float32(): BytecodeType {
        BytecodeType(BC_TYPE_FLOAT32)
    }

    @static fun float64(): BytecodeType {
        BytecodeType(BC_TYPE_FLOAT64)
    }

    @static fun ptr(): BytecodeType {
        BytecodeType(BC_TYPE_PTR)
    }
}

impl Stringable for BytecodeType {
    fun toString(): String { bytecodeTypeName(self.value) }
}
