class Graph {
    var start_block: Block;
    var end_block: Block;

    var blocks: Vec[Block];
    var reverse_post_order: Vec[Block];

    fun create_block() -> Block {
        let block = Block(self);
        self.blocks.push(block);
        return block;
    }
}

class Block(graph: Graph) {
    var phis: Vec[Inst] = Vec[Inst]();
    var instructions: InstLinkedList = InstLinkedList();
    var graph: Graph = graph;
    var dominator: Block;
    var dominated_blocks: Vec[Block];
    var predecessors: Vec[Block] = Vec[Block]();
    var successors: Vec[Block] = Vec[Block]();

    fun append_inst(inst: Inst) -> Inst {
        self.instructions.append_inst(inst);
        return inst;
    }
}

class Input {
    var inst: Inst;

    var used_by: Inst;
    var idx: Int;

    var previous_use: Inst;
    var next_use: Inst;
}

@abstract @open class Inst {
    var block: Block;

    var previous: Inst;
    var next: Inst;

    var ty: Type;

    var use_list_first: Inst;
    var use_list_last: Inst;

    fun getType() -> Type {
        return self.ty;
    }
}

@abstract @open class Const: Inst
class IntConst(let value: Int): Const
class FloatConst(let value: Float): Const
class DoubleConst(let value: Double): Const
class LongConst(let value: Long): Const

class PrologInst: Inst
class EpilogInst: Inst
class UnaryInst(let op: UnOp, let opnd: Inst): Inst
class BinaryInst(let op: BinOp, let lhs: Inst, let rhs: Inst): Inst
class ArgInst(let idx: Int): Inst

class PhiInst(let inputs: Vec[PhiArg]): Inst
class PhiArg(let value: Inst, let block: Block)

@abstract @open class Terminator: Inst

class ReturnInst(let value: Inst): Terminator
class ReturnVoidInst: Terminator
class CondInst(let cond: Inst, let true_succ: Block, let false_succ: Block): Terminator
class GotoInst(let succ: Block): Terminator

enum BinOp {
    Add, Sub, Mul, Div, Mod,
    FAdd, FSub, FMul, FDiv,
}

enum UnOp {
    Neg, FNeg, Not,
}

class InstLinkedList {
    var first_inst: Inst;
    var last_inst: Inst;

    fun isEmpty() -> Bool {
        self.first_inst === nil
    }

    fun firstInst() -> Inst {
        self.first_inst
    }

    fun lastInst() -> Inst {
        self.last_inst
    }

    fun append_inst(inst: Inst) {
        if self.first_inst === nil {
            inst.previous = nil;
            inst.next = nil;

            self.first_inst = inst;
            self.last_inst = inst;
        } else {
            self.last_inst.next = inst;

            inst.previous = self.last_inst;
            inst.next = nil;

            self.last_inst = inst;
        }
    }
}

class InstIterator(block: Block) {
    var inst: Inst = block.instructions.firstInst();

    fun current() -> Inst { self.inst }
    fun isDone() -> Bool { self.inst === nil }
    fun next() {
        if self.inst !== nil {
            self.inst = self.inst.next;
        }
    }
}

class BackwardInstIterator(block: Block) {
    var inst: Inst = block.instructions.lastInst();

    fun current() -> Inst { self.inst }
    fun isDone() -> Bool { self.inst === nil }
    fun next() {
        if self.inst !== nil {
            self.inst = self.inst.previous;
        }
    }
}