class BytecodeBuilder {
    let code: Vec[UInt8] = Vec();
    let constPool: Vec[ConstPoolEntry] = Vec();
    let registers: Vec[BytecodeType] = Vec();
    let unresolvedJumps: Vec[UnresolvedJump] = Vec();
    var arguments: Int32 = 0I;

    fn addRegister(ty: BytecodeType): BytecodeRegister {
        self.registers.push(ty);
        BytecodeRegister(self.registers.size().toInt32() - 1I)
    }

    fn createLabel(): BytecodeLabel {
        BytecodeLabel()
    }

    fn defineLabel(): BytecodeLabel {
        BytecodeLabel().bindTo(self.code.size().toInt32())
    }

    fn bindLabel(lbl: BytecodeLabel) {
        lbl.bindTo(self.code.size().toInt32());
    }

    fn setArguments(arguments: Int32) {
        self.arguments = arguments;
    }

    fn emitAddInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ADD_INT32, dest, lhs, rhs);
    }

    fn emitAddInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ADD_INT64, dest, lhs, rhs);
    }

    fn emitAddFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ADD_FLOAT32, dest, lhs, rhs);
    }

    fn emitAddFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ADD_FLOAT64, dest, lhs, rhs);
    }

    fn emitSubInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SUB_INT32, dest, lhs, rhs);
    }

    fn emitSubInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SUB_INT64, dest, lhs, rhs);
    }

    fn emitSubFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SUB_FLOAT32, dest, lhs, rhs);
    }

    fn emitSubFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SUB_FLOAT64, dest, lhs, rhs);
    }

    fn emitNegInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NEG_INT32, dest, src);
    }

    fn emitNegInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NEG_INT64, dest, src);
    }

    fn emitNegFloat32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NEG_FLOAT32, dest, src);
    }

    fn emitNegFloat64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NEG_FLOAT64, dest, src);
    }

    fn emitMulInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MUL_INT32, dest, lhs, rhs);
    }

    fn emitMulInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MUL_INT64, dest, lhs, rhs);
    }

    fn emitMulFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MUL_FLOAT32, dest, lhs, rhs);
    }

    fn emitMulFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MUL_FLOAT64, dest, lhs, rhs);
    }

    fn emitDivInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_DIV_INT32, dest, lhs, rhs);
    }

    fn emitDivInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_DIV_INT64, dest, lhs, rhs);
    }

    fn emitDivFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_DIV_FLOAT32, dest, lhs, rhs);
    }

    fn emitDivFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_DIV_FLOAT64, dest, lhs, rhs);
    }

    fn emitModInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MOD_INT32, dest, lhs, rhs);
    }

    fn emitModInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_MOD_INT64, dest, lhs, rhs);
    }

    fn emitAndInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_AND_INT32, dest, lhs, rhs);
    }

    fn emitAndInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_AND_INT64, dest, lhs, rhs);
    }

    fn emitOrInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_OR_INT32, dest, lhs, rhs);
    }

    fn emitOrInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_OR_INT64, dest, lhs, rhs);
    }

    fn emitXorInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_XOR_INT32, dest, lhs, rhs);
    }

    fn emitXorInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_XOR_INT64, dest, lhs, rhs);
    }

    fn emitNotBool(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NOT_BOOL, dest, src);
    }

    fn emitNotInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NOT_INT32, dest, src);
    }

    fn emitNotInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_NOT_INT64, dest, src);
    }

    fn emitShlInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SHL_INT32, dest, lhs, rhs);
    }

    fn emitShrInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SHR_INT32, dest, lhs, rhs);
    }

    fn emitSarInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SAR_INT32, dest, lhs, rhs);
    }

    fn emitShlInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SHL_INT64, dest, lhs, rhs);
    }

    fn emitShrInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SHR_INT64, dest, lhs, rhs);
    }

    fn emitSarInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_SAR_INT64, dest, lhs, rhs);
    }

    fn emitRolInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ROL_INT32, dest, lhs, rhs);
    }

    fn emitRorInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ROR_INT32, dest, lhs, rhs);
    }

    fn emitRolInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ROL_INT64, dest, lhs, rhs);
    }

    fn emitRorInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_ROR_INT64, dest, lhs, rhs);
    }

    fn emitExtendByteToChar(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_EXTEND_UINT8_TO_CHAR, dest, src);
    }

    fn emitExtendByteToInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_EXTEND_UINT8_TO_INT32, dest, src);
    }

    fn emitExtendByteToInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_EXTEND_UINT8_TO_INT64, dest, src);
    }

    fn emitExtendInt32ToInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_EXTEND_INT32_TO_INT64, dest, src);
    }

    fn emitExtendCharToInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_EXTEND_CHAR_TO_INT64, dest, src);
    }

    fn emitCastCharToInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_CHAR_TO_INT32, dest, src);
    }

    fn emitCastInt32ToUInt8(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_INT32_TO_UINT8, dest, src);
    }

    fn emitCastInt32ToChar(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_INT32_TO_CHAR, dest, src);
    }

    fn emitCastInt64toUInt8(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_INT64_TO_UINT8, dest, src);
    }

    fn emitCastInt64ToChar(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_INT64_TO_CHAR, dest, src);
    }

    fn emitCastInt64ToInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_CAST_INT64_TO_INT32, dest, src);
    }

    fn emitInstanceOf(dest: BytecodeRegister, src: BytecodeRegister, cls: ClassDefId) {
        self.emitReg2AndCls(BC_INSTANCE_OF, dest, src, cls);
    }

    fn emitCheckedCast(src: BytecodeRegister, cls: ClassDefId) {
        self.emitReg1AndCls(BC_CHECKED_CAST, src, cls);
    }

    fn emitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitReg2(BC_MOV, dest, src);
    }

    fn emitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, cls: ClassDefId, field: FieldId) {
        self.emitField(BC_LOAD_FIELD, dest, obj, cls, field);
    }

    fn emitStoreField(src: BytecodeRegister, obj: BytecodeRegister, cls: ClassDefId, field: FieldId) {
        self.emitField(BC_STORE_FIELD, src, obj, cls, field);
    }

    fn emitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) {
        self.emitGlobal(BC_LOAD_GLOBAL, dest, glob);
    }

    fn emitStoreGlobal(src: BytecodeRegister, glob: GlobalId) {
        self.emitGlobal(BC_STORE_GLOBAL, src, glob);
    }

    fn emitPushRegister(src: BytecodeRegister) {
        self.emitReg1(BC_PUSH_REGISTER, src);
    }

    fn emitConstTrue(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_TRUE, dest);
    }

    fn emitConstFalse(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_FALSE, dest);
    }

    fn emitConstZeroByte(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_UINT8, dest);
    }

    fn emitConstZeroChar(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_CHAR, dest);
    }

    fn emitConstZeroInt32(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_INT32, dest);
    }

    fn emitConstZeroInt64(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_INT64, dest);
    }

    fn emitConstZeroFloat32(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_FLOAT32, dest);
    }

    fn emitConstZeroFloat64(dest: BytecodeRegister) {
        self.emitReg1(BC_CONST_ZERO_FLOAT64, dest);
    }

    fn emitConstByte(dest: BytecodeRegister, value: UInt8) {
        self.emitReg1AndByte(BC_CONST_UINT8, dest, value);
    }

    fn emitConstChar(dest: BytecodeRegister, value: Char) {
        let idx = self.addConst(ConstPoolEntry::Char(value));
        self.emitReg1AndIdx(BC_CONST_CHAR, dest, idx);
    }

    fn emitConstInt32(dest: BytecodeRegister, value: Int32) {
        let idx = self.addConst(ConstPoolEntry::Int32(value));
        self.emitReg1AndIdx(BC_CONST_INT32, dest, idx);
    }

    fn emitConstInt64(dest: BytecodeRegister, value: Int64) {
        let idx = self.addConst(ConstPoolEntry::Int64(value));
        self.emitReg1AndIdx(BC_CONST_INT64, dest, idx);
    }

    fn emitConstFloat32(dest: BytecodeRegister, value: Float32) {
        let idx = self.addConst(ConstPoolEntry::Float32(value));
        self.emitReg1AndIdx(BC_CONST_FLOAT32, dest, idx);
    }

    fn emitConstFloat64(dest: BytecodeRegister, value: Float64) {
        let idx = self.addConst(ConstPoolEntry::Float64(value));
        self.emitReg1AndIdx(BC_CONST_FLOAT64, dest, idx);
    }

    fn emitConstString(dest: BytecodeRegister, value: String) {
        let idx = self.addConst(ConstPoolEntry::String(value));
        self.emitReg1AndIdx(BC_CONST_STRING, dest, idx);
    }

    fn emitTestEqBool(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_BOOL, dest, lhs, rhs);
    }

    fn emitTestNeBool(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_BOOL, dest, lhs, rhs);
    }

    fn emitTestEqByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_UINT8, dest, lhs, rhs);
    }

    fn emitTestNeByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_UINT8, dest, lhs, rhs);
    }

    fn emitTestGtByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_UINT8, dest, lhs, rhs);
    }

    fn emitTestGeByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_UINT8, dest, lhs, rhs);
    }

    fn emitTestLtByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_UINT8, dest, lhs, rhs);
    }

    fn emitTestLeByte(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_UINT8, dest, lhs, rhs);
    }

    fn emitTestEqChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_CHAR, dest, lhs, rhs);
    }

    fn emitTestNeChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_CHAR, dest, lhs, rhs);
    }

    fn emitTestGtChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_CHAR, dest, lhs, rhs);
    }

    fn emitTestGeChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_CHAR, dest, lhs, rhs);
    }

    fn emitTestLtChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_CHAR, dest, lhs, rhs);
    }

    fn emitTestLeChar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_CHAR, dest, lhs, rhs);
    }

    fn emitTestEqEnum(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_ENUM, dest, lhs, rhs);
    }

    fn emitTestNeEnum(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_ENUM, dest, lhs, rhs);
    }

    fn emitTestEqInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_INT32, dest, lhs, rhs);
    }

    fn emitTestNeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_INT32, dest, lhs, rhs);
    }

    fn emitTestGtInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_INT32, dest, lhs, rhs);
    }

    fn emitTestGeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_INT32, dest, lhs, rhs);
    }

    fn emitTestLtInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_INT32, dest, lhs, rhs);
    }

    fn emitTestLeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_INT32, dest, lhs, rhs);
    }

    fn emitTestEqInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_INT64, dest, lhs, rhs);
    }

    fn emitTestNeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_INT64, dest, lhs, rhs);
    }

    fn emitTestGtInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_INT64, dest, lhs, rhs);
    }

    fn emitTestGeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_INT64, dest, lhs, rhs);
    }

    fn emitTestLtInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_INT64, dest, lhs, rhs);
    }

    fn emitTestLeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_INT64, dest, lhs, rhs);
    }

    fn emitTestEqFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestNeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestGtFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestGeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestLtFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestLeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_FLOAT32, dest, lhs, rhs);
    }

    fn emitTestEqFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_EQ_FLOAT64, dest, lhs, rhs);
    }

    fn emitTestNeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_NE_FLOAT64, dest, lhs, rhs);
    }

    fn emitTestGtFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GT_FLOAT64, dest, lhs, rhs);
    }

    fn emitTestGeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_GE_FLOAT64, dest, lhs, rhs);
    }

    fn emitTestLtFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LT_FLOAT64, dest, lhs, rhs);
    }

    fn emitTestLeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitReg3(BC_TEST_LE_FLOAT64, dest, lhs, rhs);
    }

    fn emitAssert(value: BytecodeRegister) {
        self.emitReg1(BC_ASSERT, value);
    }

    fn emitJumpLoop(lbl: BytecodeLabel) {
        assert(lbl.isBound());
        let offset = self.code.size().toInt32() - lbl.offset();
        self.emitJmp(BC_JUMP_LOOP, offset);
    }

    fn emitJumpIfFalse(opnd: BytecodeRegister, lbl: BytecodeLabel) {
        assert(!lbl.isBound());
        self.emitJmpForward(BC_JUMP_IF_FALSE, BC_JUMP_IF_FALSE_CONST, Some[BytecodeRegister](opnd), lbl);
    }

    fn emitJumpIfTrue(opnd: BytecodeRegister, lbl: BytecodeLabel) {
        assert(!lbl.isBound());
        self.emitJmpForward(BC_JUMP_IF_TRUE, BC_JUMP_IF_TRUE_CONST, Some[BytecodeRegister](opnd), lbl);
    }

    fn emitJump(lbl: BytecodeLabel) {
        assert(!lbl.isBound());
        self.emitJmpForward(BC_JUMP, BC_JUMP_CONST, None[BytecodeRegister], lbl);
    }

    fn emitInvokeDirectVoid(fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFctVoid(BC_INVOKE_DIRECT_VOID, fct, start, count);
    }

    fn emitInvokeDirectBool(dest: BytecodeRegister, fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFct(BC_INVOKE_DIRECT, dest, fct, start, count);
    }

    fn emitInvokeVirtualVoid(fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFctVoid(BC_INVOKE_VIRTUAL_VOID, fct, start, count);
    }

    fn emitInvokeVirtual(dest: BytecodeRegister, fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFct(BC_INVOKE_VIRTUAL, dest, fct, start, count);
    }

    fn emitInvokeStaticVoid(fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFctVoid(BC_INVOKE_STATIC_VOID, fct, start, count);
    }

    fn emitInvokeStatic(dest: BytecodeRegister, fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitFct(BC_INVOKE_STATIC, dest, fct, start, count);
    }

    fn emitNewObject(dest: BytecodeRegister, cls: ClassDefId) {
        self.emitVal3(BC_NEW_OBJECT, dest.value, cls.value);
    }

    fn emitRetVoid() {
        self.emitInst(BC_RET_VOID);
    }

    fn emitRet(opnd: BytecodeRegister) {
        self.emitReg1(BC_RET, opnd);
    }

    fn generate(): BytecodeFunction {
        self.resolveJumps();
        let code = self.code.toArray();
        let constPool = self.constPool.toArray();
        let registers = self.registers.toArray();
        let arguments = self.arguments;
        assert(arguments.toInt64() <= registers.size());
        BytecodeFunction(code, constPool, registers, arguments)
    }

    fn resolveJumps() {
        for jump in self.unresolvedJumps {
            assert(jump.label.isBound());

            assert(jump.label.offset() > jump.inst);
            let offset = jump.label.offset() - jump.inst;

            let opcode = self.code(jump.inst.toInt64()).toInt32();

            if opcode == BC_WIDE {
                // wide is guaranteed to not use constant pool
                self.patchInt32(jump.target, offset);
            } else if isWide(offset) {
                // Need to update const pool entry
                let idx = self.code(jump.target.toInt64());
                self.constPool(idx.toInt64()) = ConstPoolEntry::Int32(offset);
            } else {
                // Offset fits into byte, replace instruction with jump+immediate
                let opcode = if opcode == BC_JUMP_CONST {
                    BC_JUMP
                } else if opcode == BC_JUMP_IF_FALSE_CONST {
                    BC_JUMP_IF_FALSE
                } else if opcode == BC_JUMP_IF_TRUE_CONST {
                    BC_JUMP_IF_TRUE
                } else {
                    fatalError("unexpected opcode ${bytecodeName(opcode)} (${opcode})");
                    unreachable[Int32]()
                };

                self.code(jump.inst.toInt64()) = opcode.toUInt8();
                self.code(jump.target.toInt64()) = offset.toUInt8();
            }
        }

        self.unresolvedJumps.clear();
    }

    fn emitFctVoid(inst: Int32, fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitVal4(inst, fct.value, start.value, count);
    }

    fn emitFct(inst: Int32, dest: BytecodeRegister, fct: FctId, start: BytecodeRegister, count: Int32) {
        self.emitVal5(inst, dest.value, fct.value, start.value, count);
    }

    fn emitJmp(inst: Int32, offset: Int32) {
        self.emitVal2(inst, offset);
    }

    fn emitJmpForward(inst: Int32, instConst: Int32, opnd: Option[BytecodeRegister], lbl: BytecodeLabel) {
        assert(!isWide(inst));
        assert(!isWide(instConst));
        let start = self.code.size().toInt32();
        var target = 0I;

        if (opnd.isSome() && isWide(opnd.getOrPanic().value)) || isWide(self.constPool.size().toInt32()) {
            self.emitWide();
            self.emitOpcode(inst);
            if opnd.isSome() {
                self.emitInt32(opnd.getOrPanic().value);
            }
            target = self.code.size().toInt32();
            self.emitInt32(0I);
        } else {
            self.emitOpcode(instConst);
            if opnd.isSome() {
                self.emitByte(opnd.getOrPanic().value);
            }
            let idx = self.addConst(ConstPoolEntry::Int32(0I));
            target = self.code.size().toInt32();
            self.emitByte(idx.value);
        }

        self.unresolvedJumps.push(UnresolvedJump(start, target, lbl));
    }

    fn emitInst(inst: Int32) {
        self.emitVal1(inst);
    }

    fn addConst(entry: ConstPoolEntry): ConstPoolId {
        self.constPool.push(entry);
        ConstPoolId(self.constPool.size().toInt32() - 1I)
    }

    fn emitReg1(inst: Int32, r1: BytecodeRegister) {
        self.emitVal2(inst, r1.value);
    }

    fn emitReg1AndIdx(inst: Int32, r1: BytecodeRegister, idx: ConstPoolId) {
        self.emitVal3(inst, r1.value, idx.value);
    }

    fn emitReg1AndByte(inst: Int32, r1: BytecodeRegister, offset: UInt8) {
        self.emitVal2(inst, r1.value);
        self.emitByte(offset.toInt32());
    }

    fn emitReg1AndCls(inst: Int32, r1: BytecodeRegister, cls: ClassDefId) {
        self.emitVal3(inst, r1.value, cls.value);
    }

    fn emitReg2(inst: Int32, r1: BytecodeRegister, r2: BytecodeRegister) {
        self.emitVal3(inst, r1.value, r2.value);
    }

    fn emitReg2AndCls(inst: Int32, r1: BytecodeRegister, r2: BytecodeRegister, cls: ClassDefId) {
        self.emitVal4(inst, r1.value, r2.value, cls.value);
    }

    fn emitReg3(inst: Int32, r1: BytecodeRegister, r2: BytecodeRegister, r3: BytecodeRegister) {
        self.emitVal4(inst, r1.value, r2.value, r3.value);
    }

    fn emitGlobal(inst: Int32, r1: BytecodeRegister, glob: GlobalId) {
        self.emitVal3(inst, r1.value, glob.value);
    }

    fn emitField(
        inst: Int32,
        r1: BytecodeRegister,
        r2: BytecodeRegister,
        cls: ClassDefId,
        field: FieldId,
    ) {
        self.emitVal5(inst, r1.value, r2.value, cls.value, field.value);
    }

    fn emitVal1(opcode: Int32) {
        self.emitOpcode(opcode);
    }

    fn emitVal2(opcode: Int32, v1: Int32) {
        if isWide(v1) {
            self.emitWide();
            self.emitOpcode(opcode);
            self.emitInt32(v1);
        } else {
            self.emitOpcode(opcode);
            self.emitByte(v1);
        }
    }

    fn emitVal3(opcode: Int32, v1: Int32, v2: Int32) {
        if isWide(v1) || isWide(v2) {
            self.emitWide();
            self.emitOpcode(opcode);
            self.emitInt32(v1);
            self.emitInt32(v2);
        } else {
            self.emitOpcode(opcode);
            self.emitByte(v1);
            self.emitByte(v2);
        }
    }

    fn emitVal4(opcode: Int32, v1: Int32, v2: Int32, v3: Int32) {
        if isWide(v1) || isWide(v2) || isWide(v3) {
            self.emitWide();
            self.emitOpcode(opcode);
            self.emitInt32(v1);
            self.emitInt32(v2);
            self.emitInt32(v3);
        } else {
            self.emitOpcode(opcode);
            self.emitByte(v1);
            self.emitByte(v2);
            self.emitByte(v3);
        }
    }

    fn emitVal5(opcode: Int32, v1: Int32, v2: Int32, v3: Int32, v4: Int32) {
        if isWide(v1) || isWide(v2) || isWide(v3) || isWide(v4) {
            self.emitWide();
            self.emitOpcode(opcode);
            self.emitInt32(v1);
            self.emitInt32(v2);
            self.emitInt32(v3);
            self.emitInt32(v4);
        } else {
            self.emitOpcode(opcode);
            self.emitByte(v1);
            self.emitByte(v2);
            self.emitByte(v3);
            self.emitByte(v4);
        }
    }

    fn emitWide() {
        self.emitByte(BC_WIDE);
    }

    fn emitOpcode(opcode: Int32) {
        if opcode >= 255I {
            self.emitByte(255I);
            assert(opcode < 512I);
            self.emitByte(opcode - 255I);
        } else {
            self.emitByte(opcode);
        }
    }

    fn emitByte(val: Int32) {
        assert(val >= 0I && val <= 255I);
        self.code.push(val.toUInt8());
    }

    fn emitInt32(val: Int32) {
        assert(val >= 0I);
        self.emitByte(val & 0xFFI);
        self.emitByte((val >>> 8I) & 0xFFI);
        self.emitByte((val >>> 16I) & 0xFFI);
        self.emitByte((val >>> 24I) & 0xFFI);
    }

    fn patchInt32(idx: Int32, val: Int32) {
        assert(val >= 0I);
        let idx = idx.toInt64();
        self.code(idx) = (val & 0xFFI).toUInt8();
        self.code(idx + 1L) = ((val >>> 8I) & 0xFFI).toUInt8();
        self.code(idx + 2L) = ((val >>> 16I) & 0xFFI).toUInt8();
        self.code(idx + 3L) = ((val >>> 24I) & 0xFFI).toUInt8();
    }
}

fn isWide(val: Int32): Bool = val > 255I;

class BytecodeLabel {
    var off: Int32 = -1I;

    fn bindTo(offset: Int32): BytecodeLabel {
        assert(offset >= 0I);
        self.off = offset;
        self
    }

    fn isBound(): Bool = self.off >= 0I;

    fn offset(): Int32 {
        assert(self.isBound());
        self.off
    }
}

class UnresolvedJump(let inst: Int32, let target: Int32, let label: BytecodeLabel)
