fn createGraph(bc: BytecodeFunction): Graph {
    let graph = Graph();

    // Create basic blocks and edges between them
    let blockMap = createBlocksWithEdgesFromBytecode(graph, bc);

    // Fill basic blocks with instructions
    let ssagen = SsaGen(graph, bc, blockMap);
    ssagen.run();

    graph
}

class SsaGen(let graph: Graph, let bc: BytecodeFunction, let blockMap: BlockMap): BytecodeVisitor {
    var currentBlock: Option[Block] = None;
    var offset: Int32 = 0i32;
    var currentDef: Array[HashMap[Block, Inst]] = Array[HashMap[Block, Inst]]::empty();
    var blockTerminated: Bool = false;

    // a block is considered filled when all instructions are inserted
    var filledBlocks: BitSet = BitSet(0i64);

    // block is considered sealed when the set of predecessors is final
    var sealedBlocks: BitSet = BitSet(0i64);

    // tracks all incomplete phi instructions inserted into unsealed blocks
    let incompletePhis: HashMap[Block, HashMap[BytecodeRegister, Inst]] = HashMap();

    fn run() {
        self.prepare();
        self.setupArguments();

        readBytecode(self.bc.code, self);
        assert(self.blockTerminated);
    }

    fn prepare() {
        self.currentBlock = None;
        let blockCount = self.graph.blockCount();

        self.filledBlocks = BitSet(blockCount.toInt64());
        self.sealedBlocks = BitSet(blockCount.toInt64());

        let data = Vec[HashMap[Block, Inst]]();

        for i in range(0i32, self.bc.registers.size().toInt32()) {
            data.push(HashMap[Block, Inst]());
        }

        self.currentDef = data.toArray();
    }

    fn setupArguments() {
        var i = 0i32;
        let entryBlock = self.graph.getEntryBlock();
        while i < self.bc.arguments {
            let ty = Type::fromBytecodeType(self.bc.registers(i.toInt64()));
            let argInst = createArgInst(i, ty);
            entryBlock.appendInst(argInst);
            self.writeVariable(BytecodeRegister(i), entryBlock, argInst);
            i = i + 1i32;
        }
    }

    fn current(): Block = self.currentBlock.getOrPanic();

    fn writeVariable(register: BytecodeRegister, block: Block, value: Inst) {
        self.currentDef(register.value.toInt64()).insert(block, value);
    }

    fn readVariable(register: BytecodeRegister, block: Block): Inst =
        if self.currentDef(register.value.toInt64()).contains(block) {
            self.currentDef(register.value.toInt64())(block).getOrPanic()
        } else {
            self.readVariableRecursive(register, block)
        };

    fn readVariableRecursive(register: BytecodeRegister, block: Block): Inst {
        let value: Inst = if !self.sealedBlocks.contains(block.id.toInt64()) {
            // While all blocks are created with predecessors and successors before
            // this pass in the BlockBuilder already, we still need to handle unsealed blocks.
            // E.g. Register is accessed in while header and updated in the while body.
            // In this case the while header is filled before the while body. If we wouldn't
            // handle unsealed blocks we wouldn't create a Phi instruction, since the
            // while body predecessor is still empty.
            let incomplete = createPhiInst();
            block.appendPhi(incomplete);

            if self.incompletePhis.contains(block) {
                self.incompletePhis(block).getOrPanic().insert(register, incomplete);
            } else {
                let map = HashMap[BytecodeRegister, Inst]();
                map.insert(register, incomplete);
                self.incompletePhis.insert(block, map);
            }

            incomplete as Inst
        } else if block.predecessors.size() == 1i64 {
            self.readVariable(register, block.predecessors.first().getOrPanic().source)
        } else {
            let phi = createPhiInst();
            block.appendPhi(phi);
            self.writeVariable(register, block, phi);
            self.addPhiOperands(register, phi)
        };

        self.writeVariable(register, block, value);
        value
    }

    fn addPhiOperands(register: BytecodeRegister, phi: Inst): Inst {
        for pred in phi.block.getOrPanic().predecessors {
            let inst = self.readVariable(register, pred.source);
            phi.addInput(inst);
        }
        phi.registerUses();
        self.tryRemoveTrivialPhi(phi)
    }

    fn tryRemoveTrivialPhi(phi: Inst): Inst {
        var same = None[Inst];

        for inp in phi.inputs {
            let op = inp.value;

            if (same.isSome() && same.getOrPanic() === op) || op === phi {
                continue;
            }

            if same.isSome() {
                return phi;
            }

            same = Some(op);
        }

        if same.isNone() {
            same = Some(createUndefInst());
        }

        let users = phi.users();

        phi.replaceWith(same.getOrPanic());
        phi.remove();

        for i in range(0i32, users.size().toInt32()) {
            let user = users(i.toInt64());

            if user === phi {
                continue;
            }

            if user.isPhi() {
                self.tryRemoveTrivialPhi(user);
            }
        }

        same.getOrPanic()
    }

    fn markBlockTerminated() {
        self.blockTerminated = true;
    }

    @override fn visitInstruction(offset: Int32) {
        self.offset = offset;

        let block = self.blockMap.blockAt(offset);

        if block.isSome() {
            if self.currentBlock.isSome() {
                self.blockEndReached(block);
            } else {
                self.currentBlock = block;
            }
        }

        self.blockTerminated = false;
    }

    fn blockEndReached(next: Option[Block]) {
        let block = self.current();

        if !self.blockTerminated {
            let gotoInst = createGotoInst(next.getOrPanic());
            block.appendInst(gotoInst);
        }

        // We change the current block, that means all instructions
        // are inserted. The block is now filled.
        self.fillBlock(block);

        // We don't really know when to seal a block from the bytecode
        // Try to seal this block if all predecessors are filled.
        self.trySealBlock(block);

        // This block might have a back edge to a loop header. Since this
        // block is now filled, we might be able to seal another block.
        for succ in block.successors {
            self.trySealBlock(succ.target);
        }

        self.currentBlock = next;
    }

    fn fillBlock(block: Block) {
        assert(!self.filledBlocks.contains(block.id.toInt64()));
        self.filledBlocks.insert(block.id.toInt64());
    }

    fn trySealBlock(block: Block) {
        if self.sealedBlocks.contains(block.id.toInt64()) {
            return;
        }

        // all predecessors need to be filled
        for edge in block.predecessors {
            if !self.filledBlocks.contains(edge.source.id.toInt64()) {
                return;
            }
        }

        self.sealBlock(block);
    }

    fn sealBlock(block: Block) {
        assert(!self.sealedBlocks.contains(block.id.toInt64()));
        self.sealedBlocks.insert(block.id.toInt64());

        let map = self.incompletePhis(block);
        if map.isNone() { return; }

        for variableAndPhi in map.getOrPanic() {
            self.addPhiOperands(variableAndPhi.0, variableAndPhi.1);
        }
    }

    @override fn visitAdd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Add);
    }

    fn emitBin(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(lhs.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let destInst = createBinaryInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitSub(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Sub);
    }

    @override fn visitNeg(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, Op::Neg);
    }

    fn emitUn(dest: BytecodeRegister, src: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(dest.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let srcInst = self.readVariable(src, self.current());
        let destInst = createUnaryInst(op, ty, srcInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitMul(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Mul);
    }

    @override fn visitDiv(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, Op::Div);
    }

    fn emitDivMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(dest.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };
        
        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let divZeroCheck = createDivZeroCheck(rhsInst);
        self.current().appendInst(divZeroCheck);
        let destInst = createBinaryInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, Op::Mod);
    }

    @override fn visitAnd(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::And);
    }

    @override fn visitOr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Or);
    }

    @override fn visitXor(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Xor);
    }

    @override fn visitNot(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, Op::Not);
    }

    @override fn visitShl(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Shl);
    }
    @override fn visitShr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Shl);
    }
    @override fn visitSar(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, Op::Shl);
    }

    @override fn visitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitMov(dest, src);
    }

    fn emitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        self.writeVariable(dest, self.current(), srcInst);
    }

    @override fn visitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @override fn visitStoreField(src: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) {
        self.emitLoadGlobal(dest, glob, Type::bool());
    }

    fn emitLoadGlobal(dest: BytecodeRegister, glob: GlobalId, ty: Type) {
        let globInst = createLoadGlobalInst(ty, glob);
        self.current().appendInst(globInst);
        self.writeVariable(dest, self.current(), globInst);
    }

    @override fn visitStoreGlobal(src: BytecodeRegister, glob: GlobalId) {
        self.emitStoreGlobal(src, glob, Type::bool());
    }

    fn emitStoreGlobal(src: BytecodeRegister, glob: GlobalId, ty: Type) {
        let srcInst = self.readVariable(src, self.current());
        let globInst = createStoreGlobalInst(ty, glob, srcInst);
        self.current().appendInst(globInst);
    }

    @override fn visitPushRegister(src: BytecodeRegister) { unimplemented(); }

    @override fn visitConstTrue(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstFalse(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstUInt8(dest: BytecodeRegister, value: UInt8) { unimplemented(); }
    @override fn visitConstChar(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @override fn visitConstInt32(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toInt32().getOrPanic();
        let inst = createInt32Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstInt64(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toInt64().getOrPanic();
        let inst = createInt64Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstFloat32(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toFloat32().getOrPanic();
        let inst = createFloat32Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstFloat64(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toFloat64().getOrPanic();
        let inst = createFloat64Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstString(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitTestEq(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::Equal);
    }
    @override fn visitTestNe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::NotEqual);
    }
    @override fn visitTestGt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::Greater);
    }
    @override fn visitTestGe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::GreaterOrEqual);
    }
    @override fn visitTestLt(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::Less);
    }
    @override fn visitTestLe(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, Op::LessOrEqual);
    }

    fn emitTest(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(lhs.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let destInst = createTestInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitLoopStart() {
        // nothing to do
    }

    @override fn visitJumpLoop(offset: Int32) {
        let targetBlock = self.blockMap.blockAt(self.offset - offset).getOrPanic();
        let gotoInst = createGotoInst(targetBlock);
        self.current().appendInst(gotoInst);
        self.markBlockTerminated();
    }

    @override fn visitJumpIfFalse(opnd: BytecodeRegister, offset: Int32) {
        self.emitConditionalJump(opnd, offset, false);
    }
    @override fn visitJumpIfFalseConst(opnd: BytecodeRegister, idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitConditionalJump(opnd, offset, false);
    }
    @override fn visitJumpIfTrue(opnd: BytecodeRegister, offset: Int32) {
        self.emitConditionalJump(opnd, offset, true);
    }
    @override fn visitJumpIfTrueConst(opnd: BytecodeRegister, idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitConditionalJump(opnd, offset, true);
    }
    @override fn visitJump(offset: Int32) {
        self.emitJump(offset);
    }
    @override fn visitJumpConst(idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitJump(offset);
    }

    fn emitJump(offset: Int32) {
        let targetBlock = self.blockMap.blockAt(self.offset + offset).getOrPanic();
        let gotoInst = createGotoInst(targetBlock);
        self.current().appendInst(gotoInst);
        self.markBlockTerminated();
    }

    fn emitConditionalJump(opnd: BytecodeRegister, offset: Int32, value: Bool) {
        let opndInst = self.readVariable(opnd, self.current());
        let targetBlock = self.blockMap.blockAt(self.offset + offset).getOrPanic();
        let fallthroughBlock = self.blockMap.nextBlockAt(self.offset+1i32).getOrPanic();

        let cond = if value {
            createIfInst(opndInst, targetBlock, fallthroughBlock)
        } else {
            createIfInst(opndInst, fallthroughBlock, targetBlock)
        };

        self.current().appendInst(cond);
        self.markBlockTerminated();
    }

    @override fn visitInvokeDirectVoid(idx: ConstPoolId) { unimplemented(); }
    @override fn visitInvokeDirect(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitInvokeVirtualVoid(idx: ConstPoolId) { unimplemented(); }
    @override fn visitInvokeVirtual(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitInvokeStaticVoid(idx: ConstPoolId) { unimplemented(); }
    @override fn visitInvokeStatic(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitNewObject(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @override fn visitNewArray(dest: BytecodeRegister, idx: ConstPoolId, length: BytecodeRegister) { unimplemented(); }

    @override fn visitNilCheck(obj: BytecodeRegister) { unimplemented(); }

    @override fn visitArrayLength(dest: BytecodeRegister, arr: BytecodeRegister) { unimplemented(); }
    @override fn visitArrayBoundCheck(arr: BytecodeRegister, idx: BytecodeRegister) { unimplemented(); }

    @override fn visitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { self.emitLoadArray(dest, arr, idx); }

    fn emitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = createArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = createBoundsCheck(idxInst, arrayLengthInst);
        self.current().appendInst(boundsCheckInst);

        let arrayGetInst = createArrayGet(arrInst, idxInst, Type::Int32);
        self.current().appendInst(arrayGetInst);

        self.writeVariable(dest, self.current(), arrayGetInst);
    }

    @override fn visitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { self.emitStoreArray(src, arr, idx); }

    fn emitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = createArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = createBoundsCheck(idxInst, arrayLengthInst);
        self.current().appendInst(boundsCheckInst);

        let arraySetInst = createArraySet(arrInst, idxInst, srcInst);
        self.current().appendInst(arraySetInst);
    }

    @override fn visitRetVoid() {
        let inst = createReturnVoidInst();
        self.current().appendInst(inst);
        self.markBlockTerminated();
    }

    @override fn visitRet(opnd: BytecodeRegister) {
        let ty = self.bc.registers(opnd.value.toInt64());
        let ty = Type::fromBytecodeType(ty);
        self.emitRet(opnd, ty);
    }

    fn emitRet(opnd: BytecodeRegister, ty: Type) {
        let value = self.readVariable(opnd, self.current());
        let inst = createReturnInst(value, ty);
        self.current().appendInst(inst);
        self.markBlockTerminated();
    }
}
