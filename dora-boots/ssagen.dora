fn createGraph(bc: BytecodeFunction): Graph {
    let graph = Graph();

    // Create basic blocks and edges between them
    let blockMap = createBlocksWithEdgesFromBytecode(graph, bc);

    // Fill basic blocks with instructions
    let ssagen = SsaGen(graph, bc, blockMap);
    ssagen.run();

    graph
}

class SsaGen(let graph: Graph, let bc: BytecodeFunction, let blockMap: BlockMap): BytecodeVisitor {
    var currentBlock: Option[Block] = None;
    var offset: Int32 = 0i32;
    var currentDef: Array[HashMap[Block, Inst]] = Array[HashMap[Block, Inst]]::empty();
    var blockTerminated: Bool = false;

    // a block is considered filled when all instructions are inserted
    var filledBlocks: BitSet = BitSet(0i64);

    // block is considered sealed when the set of predecessors is final
    var sealedBlocks: BitSet = BitSet(0i64);

    // tracks all incomplete phi instructions inserted into unsealed blocks
    let incompletePhis: HashMap[Block, HashMap[BytecodeRegister, PhiInst]] = HashMap();

    fn run() {
        self.prepare();
        self.setupArguments();

        readBytecode(self.bc.code, self);
        assert(self.blockTerminated);
    }

    fn prepare() {
        self.currentBlock = None;
        let blockCount = self.graph.blockCount();

        self.filledBlocks = BitSet(blockCount.toInt64());
        self.sealedBlocks = BitSet(blockCount.toInt64());

        let data = Vec[HashMap[Block, Inst]]();

        for i in range(0i32, self.bc.registers.size().toInt32()) {
            data.push(HashMap[Block, Inst]());
        }

        self.currentDef = data.toArray();
    }

    fn setupArguments() {
        var i = 0i32;
        let entryBlock = self.graph.getEntryBlock();
        while i < self.bc.arguments {
            let ty = Type::fromBytecodeType(self.bc.registers(i.toInt64()));
            let argInst = ArgInst(i, ty);
            entryBlock.appendInst(argInst);
            self.writeVariable(BytecodeRegister(i), entryBlock, argInst);
            i = i + 1i32;
        }
    }

    fn current(): Block = self.currentBlock.getOrPanic();

    fn writeVariable(register: BytecodeRegister, block: Block, value: Inst) {
        self.currentDef(register.value.toInt64()).insert(block, value);
    }

    fn readVariable(register: BytecodeRegister, block: Block): Inst =
        if self.currentDef(register.value.toInt64()).contains(block) {
            self.currentDef(register.value.toInt64())(block).getOrPanic()
        } else {
            self.readVariableRecursive(register, block)
        };

    fn readVariableRecursive(register: BytecodeRegister, block: Block): Inst {
        let value: Inst = if !self.sealedBlocks.contains(block.id.toInt64()) {
            // While all blocks are created with predecessors and successors before
            // this pass in the BlockBuilder already, we still need to handle unsealed blocks.
            // E.g. Register is accessed in while header and updated in the while body.
            // In this case the while header is filled before the while body. If we wouldn't
            // handle unsealed blocks we wouldn't create a Phi instruction, since the
            // while body predecessor is still empty.
            let incomplete = PhiInst();
            block.appendPhi(incomplete);

            if self.incompletePhis.contains(block) {
                self.incompletePhis(block).getOrPanic().insert(register, incomplete);
            } else {
                let map = HashMap[BytecodeRegister, PhiInst]();
                map.insert(register, incomplete);
                self.incompletePhis.insert(block, map);
            }

            incomplete as Inst
        } else if block.predecessors.size() == 1i64 {
            self.readVariable(register, block.predecessors.first().getOrPanic().source)
        } else {
            let phi = PhiInst();
            block.appendPhi(phi);
            self.writeVariable(register, block, phi);
            self.addPhiOperands(register, phi)
        };

        self.writeVariable(register, block, value);
        value
    }

    fn addPhiOperands(register: BytecodeRegister, phi: PhiInst): Inst {
        for pred in phi.block.getOrPanic().predecessors {
            let inst = self.readVariable(register, pred.source);
            phi.addInput(inst);
        }
        phi.registerUses();
        self.tryRemoveTrivialPhi(phi)
    }

    fn tryRemoveTrivialPhi(phi: PhiInst): Inst {
        var same = None[Inst];

        for inp in phi.inputs {
            let op = inp.value;

            if (same.isSome() && same.getOrPanic() === op) || op === phi {
                continue;
            }

            if same.isSome() {
                return phi;
            }

            same = Some(op);
        }

        if same.isNone() {
            same = Some(UndefInst());
        }

        let users = phi.users();

        phi.replaceWith(same.getOrPanic());
        phi.remove();

        for i in range(0i32, users.size().toInt32()) {
            let user = users(i.toInt64());

            if user === phi {
                continue;
            }

            if user is PhiInst {
                self.tryRemoveTrivialPhi(user as PhiInst);
            }
        }

        same.getOrPanic()
    }

    fn markBlockTerminated() {
        self.blockTerminated = true;
    }

    @override fn visitInstruction(offset: Int32) {
        self.offset = offset;

        let block = self.blockMap.blockAt(offset);

        if block.isSome() {
            if self.currentBlock.isSome() {
                self.blockEndReached(block);
            } else {
                self.currentBlock = block;
            }
        }

        self.blockTerminated = false;
    }

    fn blockEndReached(next: Option[Block]) {
        let block = self.current();

        if !self.blockTerminated {
            let gotoInst = GotoInst(next.getOrPanic());
            block.appendInst(gotoInst);
        }

        // We change the current block, that means all instructions
        // are inserted. The block is now filled.
        self.fillBlock(block);

        // We don't really know when to seal a block from the bytecode
        // Try to seal this block if all predecessors are filled.
        self.trySealBlock(block);

        // This block might have a back edge to a loop header. Since this
        // block is now filled, we might be able to seal another block.
        for succ in block.successors {
            self.trySealBlock(succ.target);
        }

        self.currentBlock = next;
    }

    fn fillBlock(block: Block) {
        assert(!self.filledBlocks.contains(block.id.toInt64()));
        self.filledBlocks.insert(block.id.toInt64());
    }

    fn trySealBlock(block: Block) {
        if self.sealedBlocks.contains(block.id.toInt64()) {
            return;
        }

        // all predecessors need to be filled
        for edge in block.predecessors {
            if !self.filledBlocks.contains(edge.source.id.toInt64()) {
                return;
            }
        }

        self.sealBlock(block);
    }

    fn sealBlock(block: Block) {
        assert(!self.sealedBlocks.contains(block.id.toInt64()));
        self.sealedBlocks.insert(block.id.toInt64());

        let map = self.incompletePhis(block);
        if map.isNone() { return; }

        for variableAndPhi in map.getOrPanic() {
            self.addPhiOperands(variableAndPhi.0, variableAndPhi.1);
        }
    }

    @override fn visitAddInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Add, Type::int32());
    }
    @override fn visitAddInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Add, Type::int64());
    }
    @override fn visitAddFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Add, Type::float32());
    }
    @override fn visitAddFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Add, Type::float64());
    }

    fn emitBin(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: BinOp, ty: Type) {
        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let destInst = BinaryInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitSubInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sub, Type::int32());
    }
    @override fn visitSubInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sub, Type::int64());
    }
    @override fn visitSubFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sub, Type::float32());
    }
    @override fn visitSubFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sub, Type::float64());
    }

    @override fn visitNegInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Neg, Type::int32());
    }
    @override fn visitNegInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Neg, Type::int64());
    }
    @override fn visitNegFloat32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Neg, Type::float32());
    }
    @override fn visitNegFloat64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Neg, Type::float64());
    }

    fn emitUn(dest: BytecodeRegister, src: BytecodeRegister, op: UnOp, ty: Type) {
        let srcInst = self.readVariable(src, self.current());
        let destInst = UnaryInst(op, ty, srcInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitMulInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Mul, Type::int32());
    }
    @override fn visitMulInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Mul, Type::int64());
    }
    @override fn visitMulFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Mul, Type::float32());
    }
    @override fn visitMulFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Mul, Type::float64());
    }

    @override fn visitDivInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, BinOp::Div, Type::int32());
    }
    @override fn visitDivInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, BinOp::Div, Type::int64());
    }

    fn emitDivMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: BinOp, ty: Type) {
        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let divZeroCheck = DivZeroCheck(rhsInst);
        self.current().appendInst(divZeroCheck);
        let destInst = BinaryInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitDivFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Div, Type::float32());
    }
    @override fn visitDivFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Div, Type::float64());
    }

    @override fn visitModInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, BinOp::Mod, Type::int32());
    }
    @override fn visitModInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitDivMod(dest, lhs, rhs, BinOp::Mod, Type::int64());
    }

    @override fn visitAndInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::And, Type::int32());
    }
    @override fn visitAndInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::And, Type::int64());
    }

    @override fn visitOrInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Or, Type::int32());
    }
    @override fn visitOrInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Or, Type::int64());
    }

    @override fn visitXorInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Xor, Type::int32());
    }
    @override fn visitXorInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Xor, Type::int64());
    }

    @override fn visitNotBool(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Not, Type::bool());
    }
    @override fn visitNotInt32(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Not, Type::int32());
    }
    @override fn visitNotInt64(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitUn(dest, src, UnOp::Not, Type::int64());
    }

    @override fn visitShlInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Shl, Type::int32());
    }
    @override fn visitShrInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Shr, Type::int32());
    }
    @override fn visitSarInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sar, Type::int32());
    }

    @override fn visitShlInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Shl, Type::int64());
    }
    @override fn visitShrInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Shr, Type::int64());
    }
    @override fn visitSarInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitBin(dest, lhs, rhs, BinOp::Sar, Type::int64());
    }

    @override fn visitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        self.emitMov(dest, src);
    }

    fn emitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        self.writeVariable(dest, self.current(), srcInst);
    }

    @override fn visitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, cls: ClassDefId, field: FieldId) { unimplemented(); }
    @override fn visitStoreField(src: BytecodeRegister, obj: BytecodeRegister, cls: ClassDefId, field: FieldId) { unimplemented(); }

    @override fn visitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) {
        self.emitLoadGlobal(dest, glob, Type::bool());
    }

    fn emitLoadGlobal(dest: BytecodeRegister, glob: GlobalId, ty: Type) {
        let globInst = LoadGlobalInst(ty, glob);
        self.current().appendInst(globInst);
        self.writeVariable(dest, self.current(), globInst);
    }

    @override fn visitStoreGlobal(src: BytecodeRegister, glob: GlobalId) {
        self.emitStoreGlobal(src, glob, Type::bool());
    }

    fn emitStoreGlobal(src: BytecodeRegister, glob: GlobalId, ty: Type) {
        let srcInst = self.readVariable(src, self.current());
        let globInst = StoreGlobalInst(ty, glob, srcInst);
        self.current().appendInst(globInst);
    }

    @override fn visitPushRegister(src: BytecodeRegister) { unimplemented(); }

    @override fn visitConstTrue(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstFalse(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstZeroUInt8(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstZeroChar(dest: BytecodeRegister) { unimplemented(); }
    @override fn visitConstZeroInt32(dest: BytecodeRegister) {
        let inst = Int32Const(0i32);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstZeroInt64(dest: BytecodeRegister) {
        let inst = Int64Const(0i64);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstZeroFloat32(dest: BytecodeRegister) {
        let inst = Float32Const(0.0f32);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstZeroFloat64(dest: BytecodeRegister) {
        let inst = Float64Const(0.0);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstUInt8(dest: BytecodeRegister, value: UInt8) { unimplemented(); }
    @override fn visitConstChar(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }
    @override fn visitConstInt32(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toInt32().getOrPanic();
        let inst = Int32Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstInt64(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toInt64().getOrPanic();
        let inst = Int64Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstFloat32(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toFloat32().getOrPanic();
        let inst = Float32Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstFloat64(dest: BytecodeRegister, idx: ConstPoolId) {
        let value = self.bc.constPool(idx).toFloat64().getOrPanic();
        let inst = Float64Const(value);
        self.current().appendInst(inst);
        self.writeVariable(dest, self.current(), inst);
    }
    @override fn visitConstString(dest: BytecodeRegister, idx: ConstPoolId) { unimplemented(); }

    @override fn visitTestEqPtr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::Equal, Type::ptr());
    }
    @override fn visitTestNePtr(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::NotEqual, Type::ptr());
    }

    @override fn visitTestEqInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::Equal, Type::int32());
    }
    @override fn visitTestNeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::NotEqual, Type::int32());
    }
    @override fn visitTestGtInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::Greater, Type::int32());
    }
    @override fn visitTestGeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::GreaterOrEqual, Type::int32());
    }
    @override fn visitTestLtInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::Less, Type::int32());
    }
    @override fn visitTestLeInt32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) {
        self.emitTest(dest, lhs, rhs, TestOp::LessOrEqual, Type::int32());
    }

    @override fn visitTestEqInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestNeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGtInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLtInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLeInt64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    @override fn visitTestEqFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestNeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGtFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLtFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLeFloat32(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    @override fn visitTestEqFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestNeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGtFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestGeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLtFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }
    @override fn visitTestLeFloat64(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister) { unimplemented(); }

    fn emitTest(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: TestOp, ty: Type) {
        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let destInst = TestInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    @override fn visitLoopStart() {
        // nothing to do
    }

    @override fn visitJumpLoop(offset: Int32) {
        let targetBlock = self.blockMap.blockAt(self.offset - offset).getOrPanic();
        let gotoInst = GotoInst(targetBlock);
        self.current().appendInst(gotoInst);
        self.markBlockTerminated();
    }

    @override fn visitJumpIfFalse(opnd: BytecodeRegister, offset: Int32) {
        self.emitConditionalJump(opnd, offset, false);
    }
    @override fn visitJumpIfFalseConst(opnd: BytecodeRegister, idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitConditionalJump(opnd, offset, false);
    }
    @override fn visitJumpIfTrue(opnd: BytecodeRegister, offset: Int32) {
        self.emitConditionalJump(opnd, offset, true);
    }
    @override fn visitJumpIfTrueConst(opnd: BytecodeRegister, idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitConditionalJump(opnd, offset, true);
    }
    @override fn visitJump(offset: Int32) {
        self.emitJump(offset);
    }
    @override fn visitJumpConst(idx: ConstPoolId) {
        let offset = self.bc.constPool(idx).toInt32().getOrPanic();
        self.emitJump(offset);
    }

    fn emitJump(offset: Int32) {
        let targetBlock = self.blockMap.blockAt(self.offset + offset).getOrPanic();
        let gotoInst = GotoInst(targetBlock);
        self.current().appendInst(gotoInst);
        self.markBlockTerminated();
    }

    fn emitConditionalJump(opnd: BytecodeRegister, offset: Int32, value: Bool) {
        let opndInst = self.readVariable(opnd, self.current());
        let targetBlock = self.blockMap.blockAt(self.offset + offset).getOrPanic();
        let fallthroughBlock = self.blockMap.nextBlockAt(self.offset+1i32).getOrPanic();

        let cond = if value {
            IfInst(opndInst, targetBlock, fallthroughBlock)
        } else {
            IfInst(opndInst, fallthroughBlock, targetBlock)
        };

        self.current().appendInst(cond);
        self.markBlockTerminated();
    }

    @override fn visitInvokeDirectVoid(fct: FctId) { unimplemented(); }
    @override fn visitInvokeDirect(dest: BytecodeRegister, fct: FctId) { unimplemented(); }

    @override fn visitInvokeVirtualVoid(fct: FctId) { unimplemented(); }
    @override fn visitInvokeVirtual(dest: BytecodeRegister, fct: FctId) { unimplemented(); }

    @override fn visitInvokeStaticVoid(fct: FctId) { unimplemented(); }
    @override fn visitInvokeStatic(dest: BytecodeRegister, fct: FctId) { unimplemented(); }

    @override fn visitNewObject(dest: BytecodeRegister, cls: ClassDefId) { unimplemented(); }
    @override fn visitNewArray(dest: BytecodeRegister, cls: ClassDefId, length: BytecodeRegister) { unimplemented(); }

    @override fn visitNilCheck(obj: BytecodeRegister) { unimplemented(); }

    @override fn visitArrayLength(dest: BytecodeRegister, arr: BytecodeRegister) { unimplemented(); }
    @override fn visitArrayBoundCheck(arr: BytecodeRegister, idx: BytecodeRegister) { unimplemented(); }

    @override fn visitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { self.emitLoadArray(dest, arr, idx); }

    fn emitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = ArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = BoundsCheck(idxInst, arrayLengthInst);
        self.current().appendInst(boundsCheckInst);

        let arrayGetInst = ArrayGet(arrInst, idxInst, Type::Int32);
        self.current().appendInst(arrayGetInst);

        self.writeVariable(dest, self.current(), arrayGetInst);
    }

    @override fn visitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) { self.emitStoreArray(src, arr, idx); }

    fn emitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = ArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = BoundsCheck(idxInst, arrayLengthInst);
        self.current().appendInst(boundsCheckInst);

        let arraySetInst = ArraySet(arrInst, idxInst, srcInst);
        self.current().appendInst(arraySetInst);
    }

    @override fn visitRetVoid() {
        let inst = ReturnVoidInst();
        self.current().appendInst(inst);
        self.markBlockTerminated();
    }

    @override fn visitRet(opnd: BytecodeRegister) {
        let ty = self.bc.registers(opnd.value.toInt64());
        let ty = Type::fromBytecodeType(ty);
        self.emitRet(opnd, ty);
    }

    fn emitRet(opnd: BytecodeRegister, ty: Type) {
        let value = self.readVariable(opnd, self.current());
        let inst = ReturnInst(value, ty);
        self.current().appendInst(inst);
        self.markBlockTerminated();
    }
}
