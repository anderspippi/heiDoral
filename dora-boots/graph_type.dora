let typeUnit: Type = Type(TypeKind::Unit);
let typeBool: Type = Type(TypeKind::Bool);
let typeByte: Type = Type(TypeKind::UInt8);
let typeChar: Type = Type(TypeKind::Char);
let typeInt: Type = Type(TypeKind::Int);
let typeLong: Type = Type(TypeKind::Long);
let typeFloat: Type = Type(TypeKind::Float);
let typeDouble: Type = Type(TypeKind::Double);
let typePtr: Type = Type(TypeKind::Ptr);


class Type(let kind: TypeKind) {
    @static fun unit() -> Type { return typeUnit; }
    @static fun bool() -> Type { return typeBool; }
    @static fun byte() -> Type { return typeByte; }
    @static fun char() -> Type { return typeChar; }
    @static fun int() -> Type { return typeInt; }
    @static fun long() -> Type { return typeLong; }
    @static fun float() -> Type { return typeFloat; }
    @static fun double() -> Type { return typeDouble; }
    @static fun ptr() -> Type { return typePtr; }

    @static fun fromBytecodeType(ty: BytecodeType) -> Type {
        if ty.isBool() {
            Type::bool()
        } else if ty.isByte() {
            Type::byte()
        } else if ty.isChar() {
            Type::char()
        } else if ty.isInt() {
            Type::int()
        } else if ty.isLong() {
            Type::long()
        } else if ty.isFloat() {
            Type::float()
        } else if ty.isDouble() {
            Type::double()
        } else if ty.isPtr() {
            Type::ptr()
        } else {
            unreachable();
            Type::unit()
        }
    }

    fun is_unit() -> Bool { return self.kind == TypeKind::Unit; }
    fun is_byte() -> Bool { return self.kind == TypeKind::UInt8; }
    fun is_int() -> Bool { return self.kind == TypeKind::Int; }
    fun is_long() -> Bool { return self.kind == TypeKind::Long; }
    fun is_float() -> Bool { return self.kind == TypeKind::Float; }
    fun is_double() -> Bool { return self.kind == TypeKind::Double; }
    fun is_ptr() -> Bool { return self.kind == TypeKind::Ptr; }

    fun is_any_float() -> Bool {
        return self.kind == TypeKind::Float || self.kind == TypeKind::Double;
    }
}

impl Stringable for Type {
    fun toString() -> String {
        self.kind.toString()
    }
}

enum TypeKind {
    Unit, Bool, UInt8, Char, Int, Long, Float, Double, Ptr
}

impl TypeKind {
    fun toString() -> String {
        if self == TypeKind::Unit {
            "Unit"
        } else if self == TypeKind::Bool {
            "Bool"
        } else if self == TypeKind::UInt8 {
            "UInt8"
        } else if self == TypeKind::Int {
            "Int"
        } else if self == TypeKind::Long {
            "Long"
        } else if self == TypeKind::Float {
            "Float"
        } else if self == TypeKind::Double {
            "Double"
        } else if self == TypeKind::Ptr {
            "Ptr"
        } else {
            unreachable();
            ""
        }
    }
}