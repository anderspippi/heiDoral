@Test
fn testSsaGenRetVoid() {
    let writer = BytecodeBuilder();
    writer.emitRetVoid();
    let fct = writer.generate();

    bytecodeDump(fct);
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Ret.Void
");
}

@Test
fn testSsaGenRetIntConst() {
    let writer = BytecodeBuilder();
    let r0 = writer.addRegister(BytecodeType::Int32);
    writer.emitConstInt32(r0, 4711I);
    writer.emitRet(r0);
    let fct = writer.generate();

    let graph = createGraph(fct);
    assertGraph(graph, "
@0:
  %0: Const.Int32(#4711) [%1]
  %1: Ret.Int32 %0
");
}

@Test
fn testSsaGenRetInt64Const() {
    let writer = BytecodeBuilder();
    let r0 = writer.addRegister(BytecodeType::Int64);
    writer.emitConstInt64(r0, 4711);
    writer.emitRet(r0);
    let fct = writer.generate();

    let graph = createGraph(fct);
    assertGraph(graph, "
@0:
  %0: Const.Int64(#4711) [%1]
  %1: Ret.Int64 %0
");
}

fn bcSsaGenRetInt64Const(): Int64 = 4711L;

@Test
fn testSsaGenIdInt() {
    let fct = getBytecodeFunctionByName("bcSsaGenIdInt");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%1]
  %1: Ret.Int32 %0
");
}

fn bcSsaGenIdInt(x: Int32): Int32 = x;

@Test
fn testSsaGenAddIntArguments() {
    let fct = getBytecodeFunctionByName("bcSsaGenAddIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%2]
  %1: Arg.Int32(1) [%2]
  %2: Add.Int32 %0, %1 [%3]
  %3: Ret.Int32 %2
");
}

fn bcSsaGenAddIntArguments(a: Int32, b: Int32): Int32 = a + b;

@Test
fn testSsaGenAddFloat32Arguments() {
    let fct = getBytecodeFunctionByName("bcSsaGenAddFloat32Arguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Float32(0) [%2]
  %1: Arg.Float32(1) [%2]
  %2: Add.Float32 %0, %1 [%3]
  %3: Ret.Float32 %2
");
}

fn bcSsaGenAddFloat32Arguments(a: Float32, b: Float32): Float32 = a + b;

@Test
fn testSsaGenMultipleAssignments() {
    let fct = getBytecodeFunctionByName("bcSsaGenMultipleAssignments");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%5]
  %1: Const.Int32(#42) [%2, %2]
  %2: Add.Int32 %1, %1 [%4]
  %3: Const.Int32(#23) [%4]
  %4: Add.Int32 %2, %3 [%5, %6]
  %5: Add.Int32 %4, %0 [%6]
  %6: Add.Int32 %4, %5 [%7]
  %7: Ret.Int32 %6
");
}

fn bcSsaGenMultipleAssignments(d: Int32): Int32 {
    var a = 42I;
    var b = a;
    var c = a + b;

    a = c + 23I;
    c = a + d;

    a + c
}

@Test
fn testSsaGenSubIntArguments() {
    let fct = getBytecodeFunctionByName("bcSsaGenSubIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%2]
  %1: Arg.Int32(1) [%2]
  %2: Sub.Int32 %0, %1 [%3]
  %3: Ret.Int32 %2
")
}

fn bcSsaGenSubIntArguments(a: Int32, b: Int32): Int32 = a - b;

@Test
fn testSsaGenNegIntArgument() {
    let fct = getBytecodeFunctionByName("bcSsaGenNegIntArgument");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%1]
  %1: Neg.Int32 %0 [%2]
  %2: Ret.Int32 %1
");
}

fn bcSsaGenNegIntArgument(a: Int32): Int32 = -a;

@Test
fn testSsaGenMulIntArguments() {
    let fct = getBytecodeFunctionByName("bcSsaGenMulIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%2]
  %1: Arg.Int32(1) [%2]
  %2: Mul.Int32 %0, %1 [%3]
  %3: Ret.Int32 %2
");
}

fn bcSsaGenMulIntArguments(a: Int32, b: Int32): Int32 = a * b;

@Test
fn testSsaGenSimpleIf() {
    let fct = getBytecodeFunctionByName("bcSsaGenSimpleIf");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0: succ = [@2, @1]
  %0: Arg.Bool(0) [%2]
  %1: Const.Int32(#1) [%5]
  %2: If(@1, @2) %0
@1: pred = [@0] succ = [@2]
  %3: Const.Int32(#10) [%5]
  %4: Goto(@2)
@2: pred = [@0, @1]
  %5: Phi %1, %3 [%6]
  %6: Ret.Int32 %5
");
}

fn bcSsaGenSimpleIf(a: Bool): Int32 {
    var result = 1I;
    if a { result = 10I; }
    return result;
}

@Test
fn testSsaGenIfReturnInBothBranches() {
    let fct = getBytecodeFunctionByName("bcSsaGenIfReturnInBothBranches");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0: succ = [@2, @1]
  %0: Arg.Bool(0) [%1]
  %1: If(@1, @2) %0
@1: pred = [@0]
  %2: Const.Int32(#1) [%3]
  %3: Ret.Int32 %2
@2: pred = [@0]
  %4: Const.Int32(#2) [%5]
  %5: Ret.Int32 %4
");
}

fn bcSsaGenIfReturnInBothBranches(a: Bool): Int32 {
    if a { return 1; } else { return 2; }
}

@Test
fn testSsaGenIfWithConditionalAssignment() {
    let fct = getBytecodeFunctionByName("bcSsaGenIfWithConditionalAssignment");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0: succ = [@2, @1]
  %0: Arg.Bool(0) [%3]
  %1: Const.Int32(#1) [%6]
  %2: Const.Int32(#27) [%8]
  %3: If(@1, @2) %0
@1: pred = [@0] succ = [@2]
  %4: Const.Int32(#4) [%6]
  %5: Goto(@2)
@2: pred = [@0, @1]
  %6: Phi %1, %4 [%8]
  %8: Add.Int32 %6, %2 [%9]
  %9: Ret.Int32 %8
");
}

fn bcSsaGenIfWithConditionalAssignment(a: Bool): Int32 {
    var x = 1I;
    var y = 27I;
    if a { x = 4I; }
    x + y
}

@Test
fn testSsaGenWhileCountDown() {
    let fct = getBytecodeFunctionByName("bcSsaGenWhileCountDown");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0: succ = [@1]
  %0: Arg.Int32(0) [%3]
  %1: Goto(@1)
@1: pred = [@0, @2] succ = [@3, @2]
  %3: Phi %0, %7 [%4, %7, %9]
  %2: Const.Int32(#0) [%4]
  %4: Greater.Int32 %3, %2 [%5]
  %5: If(@2, @3) %4
@2: pred = [@1] succ = [@1]
  %6: Const.Int32(#1) [%7]
  %7: Sub.Int32 %3, %6 [%3]
  %8: Goto(@1)
@3: pred = [@1]
  %9: Ret.Int32 %3
");
}

fn bcSsaGenWhileCountDown(x: Int32): Int32 {
    var x = x;
    while x > 0I { x = x - 1I; }
    x
}

@Test
fn testSsaGenWhileCountDownWithSum() {
    let fct = getBytecodeFunctionByName("bcSsaGenWhileCountDownWithSum");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0: succ = [@1]
  %0: Arg.Int32(0) [%4]
  %1: Const.Int32(#0) [%9]
  %2: Goto(@1)
@1: pred = [@0, @2] succ = [@3, @2]
  %4: Phi %0, %8 [%5, %8]
  %9: Phi %1, %10 [%10, %12]
  %3: Const.Int32(#0) [%5]
  %5: Greater.Int32 %4, %3 [%6]
  %6: If(@2, @3) %5
@2: pred = [@1] succ = [@1]
  %7: Const.Int32(#1) [%8]
  %8: Sub.Int32 %4, %7 [%10, %4]
  %10: Add.Int32 %9, %8 [%9]
  %11: Goto(@1)
@3: pred = [@1]
  %12: Ret.Int32 %9
");
}

fn bcSsaGenWhileCountDownWithSum(x: Int32): Int32 {
    var x = x;
    var sum = 0I;
    while x > 0I {
        x = x - 1I;
        sum = sum + x;
    }
    sum
}

@Test
fn testSsaGenLoadArrayElementInt32() {
    let fct = getBytecodeFunctionByName("bcSsaGenLoadArrayElementInt32");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Ptr(0) [%2, %4]
  %1: Arg.Int64(1) [%3, %4]
  %2: ArrayLength %0 [%3]
  %3: BoundsCheck %1, %2
  %4: ArrayGet.Int32 %0, %1 [%5]
  %5: Ret.Int32 %4
");
}

fn bcSsaGenLoadArrayElementInt32(x: Array[Int32], idx: Int64): Int32 {
    x(idx)
}

@Test
fn testSsaGenStoreArrayElementInt32() {
    let fct = getBytecodeFunctionByName("bcSsaGenStoreArrayElementInt32");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Ptr(0) [%3, %5]
  %1: Arg.Int64(1) [%4, %5]
  %2: Arg.Int32(2) [%5]
  %3: ArrayLength %0 [%4]
  %4: BoundsCheck %1, %3
  %5: ArraySet %0, %1, %2
  %6: Ret.Void
");
}

fn bcSsaGenStoreArrayElementInt32(x: Array[Int32], idx: Int64, value: Int32) {
    x(idx) = value;
}

@Test
fn testSsaGenDivInt32() {
    let fct = getBytecodeFunctionByName("bcSsaGenDivInt32");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int32(0) [%3]
  %1: Arg.Int32(1) [%2, %3]
  %2: DivZeroCheck %1
  %3: Div.Int32 %0, %1 [%4]
  %4: Ret.Int32 %3
");
}

fn bcSsaGenDivInt32(lhs: Int32, rhs: Int32): Int32 = lhs / rhs;

@Test
fn testSsaGenDivInt64() {
    let fct = getBytecodeFunctionByName("bcSsaGenDivInt64");
    let graph = createGraph(fct);

    assertGraph(graph, "
@0:
  %0: Arg.Int64(0) [%3]
  %1: Arg.Int64(1) [%2, %3]
  %2: DivZeroCheck %1
  %3: Div.Int64 %0, %1 [%4]
  %4: Ret.Int64 %3
");
}

fn bcSsaGenDivInt64(lhs: Int64, rhs: Int64): Int64 = lhs / rhs;
