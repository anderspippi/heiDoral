@test fun testSsaGenRetVoid(_x: Testing) {
    let fct = bytecode("bcSsaGenRetVoid");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  1: Ret.Void
");
}

fun bcSsaGenRetVoid() {}

@test fun testSsaGenRetIntConst(_x: Testing) {
    let fct = bytecode("bcSsaGenRetIntConst");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  1: Int(4711) [2]
  2: Ret.Int 1
");
}

fun bcSsaGenRetIntConst() -> Int { 4711 }

@test fun testSsaGenRetLongConst(_x: Testing) {
    let fct = bytecode("bcSsaGenRetLongConst");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  1: Long(4711) [2]
  2: Ret.Long 1
");
}

fun bcSsaGenRetLongConst() -> Long { 4711L }

@test fun testSsaGenIdInt(_x: Testing) {
    let fct = bytecode("bcSsaGenIdInt");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [2]
  1: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  2: Ret.Int 0
");
}

fun bcSsaGenIdInt(x: Int) -> Int { x }

@test fun testSsaGenAddIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenAddIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [3]
  1: Arg.Int(1) [3]
  2: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  3: Add.Int 0, 1 [4]
  4: Ret.Int 3
");
}

fun bcSsaGenAddIntArguments(a: Int, b: Int) -> Int { a + b }

@test fun testSsaGenAddFloatArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenAddFloatArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Float(0) [3]
  1: Arg.Float(1) [3]
  2: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  3: Add.Float 0, 1 [4]
  4: Ret.Float 3
");
}

fun bcSsaGenAddFloatArguments(a: Float, b: Float) -> Float { a + b }

@test fun testSsaGenMultipleAssignments(_x: Testing) {
    let fct = bytecode("bcSsaGenMultipleAssignments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [6]
  1: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  2: Int(42) [3]
  3: Add.Int 2, 2 [5]
  4: Int(23) [5]
  5: Add.Int 3, 4 [6]
  6: Add.Int 5, 0 [7]
  7: Add.Int 5, 6 [8]
  8: Ret.Int 7
");
}

fun bcSsaGenMultipleAssignments(d: Int) -> Int {
    var a = 42;
    var b = a;
    var c = a + b;

    a = c + 23;
    c = a + d;

    a + c
}

@test fun testSsaGenSubIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenSubIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [3]
  1: Arg.Int(1) [3]
  2: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  3: Sub.Int 0, 1 [4]
  4: Ret.Int 3
")
}

fun bcSsaGenSubIntArguments(a: Int, b: Int) -> Int { a - b }

@test fun testSsaGenNegIntArgument(_x: Testing) {
    let fct = bytecode("bcSsaGenNegIntArgument");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [2]
  1: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  2: Neg.Int 0 [3]
  3: Ret.Int 2
");
}

fun bcSsaGenNegIntArgument(a: Int) -> Int { -a }

@test fun testSsaGenMulIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenMulIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Int(0) [3]
  1: Arg.Int(1) [3]
  2: Goto(2)
Block 1: pred = [2]
Block 2: pred = [0] succ = [1]
  3: Mul.Int 0, 1 [4]
  4: Ret.Int 3
");
}

fun bcSsaGenMulIntArguments(a: Int, b: Int) -> Int { a * b }

@test fun testSsaGenSimpleIf(_x: Testing) {
    let fct = bytecode("bcSsaGenSimpleIf");
    bytecodeDump(fct);
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0: succ = [2]
  0: Arg.Bool(0) [3]
  1: Goto(2)
Block 1: pred = [3]
Block 2: pred = [0] succ = [3, 4]
  2: Int(1)
  3: If(4, 3) 0
Block 3: pred = [2, 4] succ = [1]
  6: Phi 2, 4 [7]
  7: Ret.Int 6
Block 4: pred = [2] succ = [3]
  4: Int(10)
  5: Goto(3)
");
}

fun bcSsaGenSimpleIf(a: Bool) -> Int {
    var result = 1;
    if a { result = 10; }
    return result;
}
