@test fun testSsaGenRetVoid(_x: Testing) {
    let fct = bytecode("bcSsaGenRetVoid");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
Block 1:
Block 2:
  0: Ret.Void
");
}

fun bcSsaGenRetVoid() {}

@test fun testSsaGenRetIntConst(_x: Testing) {
    let fct = bytecode("bcSsaGenRetIntConst");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
Block 1: pred = [2]
Block 2: succ = [1]
  0: Int(4711) [1]
  1: Ret.Int 0
");
}

fun bcSsaGenRetIntConst() -> Int { 4711 }

@test fun testSsaGenRetLongConst(_x: Testing) {
    let fct = bytecode("bcSsaGenRetLongConst");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
Block 1: pred = [2]
Block 2: succ = [1]
  0: Long(4711) [1]
  1: Ret.Long 0
");
}

fun bcSsaGenRetLongConst() -> Long { 4711L }

@test fun testSsaGenIdInt(_x: Testing) {
    let fct = bytecode("bcSsaGenIdInt");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
Block 1: pred = [2]
Block 2: succ = [1]
  1: Phi [2]
  2: Ret.Int 1
");
}

fun bcSsaGenIdInt(x: Int) -> Int { x }

@test fun testSsaGenAddIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenAddIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
  1: Arg.Int(1)
Block 1: pred = [2]
Block 2: succ = [1]
  2: Phi [4]
  3: Phi [4]
  4: Add.Int 2, 3 [5]
  5: Ret.Int 4
");
}

fun bcSsaGenAddIntArguments(a: Int, b: Int) -> Int { a + b }

@test fun testSsaGenAddFloatArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenAddFloatArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Float(0)
  1: Arg.Float(1)
Block 1: pred = [2]
Block 2: succ = [1]
  2: Phi [4]
  3: Phi [4]
  4: Add.Float 2, 3 [5]
  5: Ret.Float 4
");
}

fun bcSsaGenAddFloatArguments(a: Float, b: Float) -> Float { a + b }

@test fun testSsaGenMultipleAssignments(_x: Testing) {
    let fct = bytecode("bcSsaGenMultipleAssignments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
Block 1: pred = [2]
Block 2: succ = [1]
  5: Phi [6]
  1: Int(42) [2]
  2: Add.Int 1, 1 [4]
  3: Int(23) [4]
  4: Add.Int 2, 3 [6]
  6: Add.Int 4, 5 [7]
  7: Add.Int 4, 6 [8]
  8: Ret.Int 7
");
}

fun bcSsaGenMultipleAssignments(d: Int) -> Int {
    var a = 42;
    var b = a;
    var c = a + b;

    a = c + 23;
    c = a + d;

    a + c
}

@test fun testSsaGenSubIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenSubIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
  1: Arg.Int(1)
Block 1: pred = [2]
Block 2: succ = [1]
  2: Phi [4]
  3: Phi [4]
  4: Sub.Int 2, 3 [5]
  5: Ret.Int 4
");
}

fun bcSsaGenSubIntArguments(a: Int, b: Int) -> Int { a - b }

@test fun testSsaGenNegIntArgument(_x: Testing) {
    let fct = bytecode("bcSsaGenNegIntArgument");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
Block 1: pred = [2]
Block 2: succ = [1]
  1: Phi [2]
  2: Neg.Int 1 [3]
  3: Ret.Int 2
");
}

fun bcSsaGenNegIntArgument(a: Int) -> Int { -a }

@test fun testSsaGenMulIntArguments(_x: Testing) {
    let fct = bytecode("bcSsaGenMulIntArguments");
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Int(0)
  1: Arg.Int(1)
Block 1: pred = [2]
Block 2: succ = [1]
  2: Phi [4]
  3: Phi [4]
  4: Mul.Int 2, 3 [5]
  5: Ret.Int 4
");
}

fun bcSsaGenMulIntArguments(a: Int, b: Int) -> Int { a * b }

/*
@test fun testSsaGenSimpleIf(_x: Testing) {
    let fct = bytecode("bcSsaGenSimpleIf");
    bytecodeDump(fct);
    let graph = createGraph(fct);

    assertGraph(graph, "
Block 0:
  0: Arg.Bool(0) [2]
  1: Int(1)
  2: CondInst(1, 2) 0
Block 1:
  3: Int(10)
Block 2:
  4: Phi [5]
  5: Ret.Int 4
");
}

fun bcSsaGenSimpleIf(a: Bool) -> Int {
    var result = 1;
    if a { result = 10; }
    return result;
}
*/