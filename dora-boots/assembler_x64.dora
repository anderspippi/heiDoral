let RAX: Register = Register(0);
let RCX: Register = Register(1);
let RDX: Register = Register(2);
let RBX: Register = Register(3);
let RSP: Register = Register(4);
let RBP: Register = Register(5);
let RSI: Register = Register(6);
let RDI: Register = Register(7);

let R8: Register = Register(8);
let R9: Register = Register(9);
let R10: Register = Register(10);
let R11: Register = Register(11);
let R12: Register = Register(12);
let R13: Register = Register(13);
let R14: Register = Register(14);
let R15: Register = Register(15);

class AssemblerX64: Assembler {
    let buffer: AssemblerBuffer = AssemblerBuffer();

    fun pushqr(reg: Register) {
        self.emitRexOptional(reg);
        self.emitByte((0x50 + reg.lowBits()).toByte());
    }

    fun popqr(reg: Register) {
        self.emitRexOptional(reg);
        self.emitByte((0x58 + reg.lowBits()).toByte());
    }

    fun addqri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b000, 0x05Y);
    }

    fun subqri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b101, 0x2dY);
    }

    fun addqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x01Y);
        self.emitModRmReg(src, dest);
    }

    fun addlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x01Y);
        self.emitModRmReg(src, dest);
    }

    fun subqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x29Y);
        self.emitModRmReg(src, dest);
    }

    fun sublrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x29Y);
        self.emitModRmReg(src, dest);
    }

    fun movqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x89Y);
        self.emitModRmReg(src, dest);
    }

    fun movlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x89Y);
        self.emitModRmReg(src, dest);
    }

    fun orlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x09Y);
        self.emitModRmReg(src, dest);
    }

    fun orqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x09Y);
        self.emitModRmReg(src, dest);
    }

    fun andlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x21Y);
        self.emitModRmReg(src, dest);
    }

    fun andqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x21Y);
        self.emitModRmReg(src, dest);
    }

    fun xorlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x31Y);
        self.emitModRmReg(src, dest);
    }

    fun xorqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x31Y);
        self.emitModRmReg(src, dest);
    }

    fun cmplrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x39Y);
        self.emitModRmReg(src, dest);
    }

    fun cmpqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x39Y);
        self.emitModRmReg(src, dest);
    }

    fun imullrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xAFY);
        self.emitModRmReg(dest, src);
    }

    fun imulqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xAFY);
        self.emitModRmReg(dest, src);
    }

    fun idivlr(src: Register) {
        self.emitRex32RmFieldOptional(src);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b111, src);
    }

    fun idivqr(src: Register) {
        self.emitRex64RmField(src);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b111, src);
    }

    fun retq() {
        self.emitByte(0xC3Y);
    }

    fun nop() {
        self.emitByte(0x90Y);
    }

    fun cdq() {
        self.emitByte(0x99Y);
    }

    fun cqo() {
        self.emitRex64();
        self.emitByte(0x99Y);
    }

    fun emitAlu64Imm(reg: Register, imm: Immediate, modrm_reg: Int, rax_opcode: Byte) {
        assert(imm.isInt());
        self.emitRex64RmField(reg);

        if imm.isInt8() {
            self.emitByte(0x83Y);
            self.emitModRm(0b11, modrm_reg, reg.lowBits());
            self.emitByte(imm.toByte());
        } else if reg == RAX {
            self.emitByte(rax_opcode);
            self.emitInt(imm.toInt());
        } else {
            self.emitByte(0x81Y);
            self.emitModRm(0b11, modrm_reg, reg.lowBits());
            self.emitInt(imm.toInt());
        }
    }

    fun emitRexOptional(reg: Register) {
        if reg.needsRexBit() {
            self.emitRex(false, false, false, true);
        }
    }

    fun emitRex64RmField(modrm_rm: Register) {
        self.emitRex(true, false, false, modrm_rm.needsRexBit());
    }

    fun emitRex64ModRm(modrm_reg: Register, modrm_rm: Register) {
        self.emitRex(true, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
    }

    fun emitRex32ModRmOptional(modrm_reg: Register, modrm_rm: Register) {
        if modrm_reg.needsRexBit() || modrm_rm.needsRexBit() {
            self.emitRex(false, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
        }
    }

    fun emitRex32RmFieldOptional(reg: Register) {
        if reg.needsRexBit() {
            self.emitRex(false, false, false, reg.needsRexBit());
        }
    }

    fun emitRex64() {
        self.emitRex(true, false, false, false);
    }

    fun emitRex(w: Bool, r: Bool, x: Bool, b: Bool) {
        // w - 64-bit width
        // r - extension of modrm-reg field
        // x - extension of sib index field
        // b - extension of modrm-rm/sib base/opcode reg field
        let opcode = 0x40 | w.toInt() << 3 | r.toInt() << 2 | x.toInt() << 1 | b.toInt();
        self.emitByte(opcode.toByte());
    }

    fun emitModRmReg(reg: Register, rm: Register) {
        self.emitModRm(0b11, reg.lowBits(), rm.lowBits());
    }

    fun emitModRmOpcode(opcode: Int, rm: Register) {
        self.emitModRm(0b11, opcode, rm.lowBits());
    }

    fun emitModRm(mode: Int, reg: Int, rm: Int) {
        assert(mode < 4 && reg < 8 && rm < 8);
        self.emitByte((mode << 6 | reg << 3 | rm).toByte());
    }

    fun emitSib(scale: Int, index: Int, base: Int) {
        assert(scale < 4);
        assert(index < 8);
        assert(base < 8);
        self.emitByte((scale << 6 | index << 3 | base).toByte());
    }

    fun emitByte(value: Byte) {
        self.buffer.emitByte(value);
    }

    fun emitInt(value: Int) {
        self.buffer.emitInt(value);
    }

    fun finalize() -> Array[Byte] {
        self.buffer.toArray()
    }
}

impl Register {
    fun lowBits() -> Int {
        self.value & 0b111
    }

    fun needsRexBit() -> Bool {
        self.value > 7
    }
}

@test fun testAsmRegisters() {
    assert(RAX.lowBits() == 0 && !RAX.needsRexBit());
    assert(RCX.lowBits() == 1 && !RCX.needsRexBit());
    assert(RDX.lowBits() == 2 && !RDX.needsRexBit());
    assert(RBX.lowBits() == 3 && !RBX.needsRexBit());
    assert(RSP.lowBits() == 4 && !RSP.needsRexBit());
    assert(RBP.lowBits() == 5 && !RBP.needsRexBit());
    assert(RSI.lowBits() == 6 && !RSI.needsRexBit());
    assert(RDI.lowBits() == 7 && !RDI.needsRexBit());

    assert(R8.lowBits() == 0 && R8.needsRexBit());
    assert(R9.lowBits() == 1 && R9.needsRexBit());
    assert(R10.lowBits() == 2 && R10.needsRexBit());
    assert(R11.lowBits() == 3 && R11.needsRexBit());
    assert(R12.lowBits() == 4 && R12.needsRexBit());
    assert(R13.lowBits() == 5 && R13.needsRexBit());
    assert(R14.lowBits() == 6 && R14.needsRexBit());
    assert(R15.lowBits() == 7 && R15.needsRexBit());
}

@test fun testAsmPushqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.pushqr(RAX);
    asm.pushqr(RSP);
    asm.pushqr(R8);
    asm.pushqr(R15);
    let buffer = asm.finalize();
    asm1(buffer, 0, 0x50Y);
    asm1(buffer, 1, 0x54Y);
    asm2(buffer, 2, 0x41Y, 0x50Y);
    asm2(buffer, 4, 0x41Y, 0x57Y);
    assert(buffer.length() == 6);
}

@test fun testAsmPopqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.popqr(RAX);
    asm.popqr(RSP);
    asm.popqr(R8);
    asm.popqr(R15);
    let buffer = asm.finalize();
    asm1(buffer, 0, 0x58Y);
    asm1(buffer, 1, 0x5CY);
    asm2(buffer, 2, 0x41Y, 0x58Y);
    asm2(buffer, 4, 0x41Y, 0x5FY);
    assert(buffer.length() == 6);
}

@test fun testAsmMovqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqrr(R15, RAX);
    asm.movqrr(RAX, R15);
    let buffer = asm.finalize();
    asm3(buffer, 0, 0x49Y, 0x89Y, 0xC7Y);
    asm3(buffer, 3, 0x4CY, 0x89Y, 0xF8Y);
    assert(buffer.length() == 6);
}

@test fun testAsmMovlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlrr(R15, RAX);
    asm.movlrr(RAX, R15);
    asm.movlrr(RCX, RAX);
    let buffer = asm.finalize();
    asm3(buffer, 0, 0x41Y, 0x89Y, 0xC7Y);
    asm3(buffer, 3, 0x44Y, 0x89Y, 0xF8Y);
    asm2(buffer, 6, 0x89Y, 0xC1Y);
    assert(buffer.length() == 8);
}

@test fun testAsmAddqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addqrr(RAX, RBX);
    asm.addqrr(RAX, R12);
    asm.addqrr(R12, RAX);
    asm.addqrr(R15, RSP);
    let buffer = asm.finalize();
    asm3(buffer, 0, 0x48Y, 0x01Y, 0xD8Y);
    asm3(buffer, 3, 0x4CY, 0x01Y, 0xE0Y);
    asm3(buffer, 6, 0x49Y, 0x01Y, 0xC4Y);
    asm3(buffer, 9, 0x49Y, 0x01Y, 0xE7Y);
    assert(buffer.length() == 12);
}

@test fun testAsmAddlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addlrr(RAX, RBX);
    asm.addlrr(RCX, R15);
    let buffer = asm.finalize();
    asm2(buffer, 0, 0x01Y, 0xD8Y);
    asm3(buffer, 2, 0x44Y, 0x01Y, 0xF9Y);
    assert(buffer.length() == 5);
}

@test fun testAsmAddqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.addqri(RAX, Immediate(0x11L));
    asm.addqri(R15, Immediate(0x11L));
    asm.addqri(RAX, Immediate(0x2211L));
    asm.addqri(RCX, Immediate(0x2211L));
    asm.addqri(R15, Immediate(0x2211L));
    let buffer = asm.finalize();
    asm4(buffer, 0, 0x48Y, 0x83Y, 0xC0Y, 0x11Y);
    asm4(buffer, 4, 0x49Y, 0x83Y, 0xC7Y, 0x11Y);
    asm2(buffer, 8, 0x48Y, 0x05Y);
    asmInt(buffer, 10, 0x2211);
    asm3(buffer, 14, 0x48Y, 0x81Y, 0xC1Y);
    asmInt(buffer, 17, 0x2211);
    asm3(buffer, 21, 0x49Y, 0x81Y, 0xC7Y);
    asmInt(buffer, 24, 0x2211);
    assert(buffer.length() == 28);
}

@test fun testAsmSubqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.subqrr(RAX, RBX);
    asm.subqrr(RCX, R15);
    let buffer = asm.finalize();
    asm3(buffer, 0, 0x48Y, 0x29Y, 0xD8Y);
    asm3(buffer, 3, 0x4CY, 0x29Y, 0xF9Y);
    assert(buffer.length() == 6);
}

@test fun testAsmSubqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.subqri(RAX, Immediate(0x11L));
    asm.subqri(R15, Immediate(0x11L));
    asm.subqri(RAX, Immediate(0x2211L));
    asm.subqri(RCX, Immediate(0x2211L));
    asm.subqri(R15, Immediate(0x2211L));
    let buffer = asm.finalize();
    asm4(buffer, 0, 0x48Y, 0x83Y, 0xE8Y, 0x11Y);
    asm4(buffer, 4, 0x49Y, 0x83Y, 0xEFY, 0x11Y);
    asm2(buffer, 8, 0x48Y, 0x2DY);
    asmInt(buffer, 10, 0x2211);
    asm3(buffer, 14, 0x48Y, 0x81Y, 0xE9Y);
    asmInt(buffer, 17, 0x2211);
    asm3(buffer, 21, 0x49Y, 0x81Y, 0xEFY);
    asmInt(buffer, 24, 0x2211);
    assert(buffer.length() == 28);
}

@test fun testAsmRetq(_x: Testing) {
    let asm = AssemblerX64();
    asm.retq();
    let buffer = asm.finalize();
    asm1(buffer, 0, 0xC3Y);
    assert(buffer.length() == 1);
}

@test fun testAsmNop(_x: Testing) {
    let asm = AssemblerX64();
    asm.nop();
    let buffer = asm.finalize();
    asm1(buffer, 0, 0x90Y);
    assert(buffer.length() == 1);
}

@test fun testAsmCdqCqo(_x: Testing) {
    let asm = AssemblerX64();
    asm.cdq();
    asm.cqo();
    let buffer = asm.finalize();
    asm1(buffer, 0, 0x99Y);
    assert(buffer.length() == 3);
}

@test fun testAsmOrlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.orlrr(RAX, R15);
    asm.orlrr(RAX, RCX);
    asm.orlrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x44Y, 0x09Y, 0xF8Y);
    asm2(buffer, 3, 0x09Y, 0xc8Y);
    asm3(buffer, 5, 0x41Y, 0x09Y, 0xC7Y);
    assert(buffer.length() == 8);
}

@test fun testAsmOrqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.orqrr(RAX, R15);
    asm.orqrr(RAX, RCX);
    asm.orqrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x4CY, 0x09Y, 0xF8Y);
    asm3(buffer, 3, 0x48Y, 0x09Y, 0xC8Y);
    asm3(buffer, 6, 0x49Y, 0x09Y, 0xC7Y);
    assert(buffer.length() == 9);
}

@test fun testAsmAndlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.andlrr(RAX, R15);
    asm.andlrr(RAX, RCX);
    asm.andlrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x44Y, 0x21Y, 0xF8Y);
    asm2(buffer, 3, 0x21Y, 0xC8Y);
    asm3(buffer, 5, 0x41Y, 0x21Y, 0xC7Y);
    assert(buffer.length() == 8);
}

@test fun testAsmAndqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.andqrr(RAX, R15);
    asm.andqrr(RAX, RCX);
    asm.andqrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x4CY, 0x21Y, 0xF8Y);
    asm3(buffer, 3, 0x48Y, 0x21Y, 0xC8Y);
    asm3(buffer, 6, 0x49Y, 0x21Y, 0xC7Y);
    assert(buffer.length() == 9);
}

@test fun testAsmXorlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorlrr(RAX, R15);
    asm.xorlrr(RAX, RCX);
    asm.xorlrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x44Y, 0x31Y, 0xF8Y);
    asm2(buffer, 3, 0x31Y, 0xC8Y);
    asm3(buffer, 5, 0x41Y, 0x31Y, 0xC7Y);
    assert(buffer.length() == 8);
}

@test fun testAsmXorqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorqrr(RAX, R15);
    asm.xorqrr(RAX, RCX);
    asm.xorqrr(R15, RAX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x4CY, 0x31Y, 0xF8Y);
    asm3(buffer, 3, 0x48Y, 0x31Y, 0xC8Y);
    asm3(buffer, 6, 0x49Y, 0x31Y, 0xC7Y);
    assert(buffer.length() == 9);
}

@test fun testAsmCmplrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmplrr(RAX, R15);
    asm.cmplrr(R15, RBX);
    asm.cmplrr(RAX, RBX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x44Y, 0x39Y, 0xF8Y);
    asm3(buffer, 3, 0x41Y, 0x39Y, 0xDFY);
    asm2(buffer, 6, 0x39Y, 0xD8Y);
    assert(buffer.length() == 8);
}

@test fun testAsmCmpqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpqrr(RAX, R15);
    asm.cmpqrr(R15, RBX);
    asm.cmpqrr(RAX, RBX);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x4CY, 0x39Y, 0xF8Y);
    asm3(buffer, 3, 0x49Y, 0x39Y, 0xDFY);
    asm3(buffer, 6, 0x48Y, 0x39Y, 0xD8Y);
    assert(buffer.length() == 9);
}

@test fun testAsmImullrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.imullrr(RAX, RBX);
    asm.imullrr(RCX, R15);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x0FY, 0xAFY, 0xC3Y);
    asm4(buffer, 3, 0x41Y, 0x0FY, 0xAFY, 0xCFY);
    assert(buffer.length() == 7);
}

@test fun testAsmImulqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.imulqrr(RAX, RBX);
    asm.imulqrr(RCX, R15);
    let buffer = asm.finalize();

    asm4(buffer, 0, 0x48Y, 0x0FY, 0xAFY, 0xC3Y);
    asm4(buffer, 4, 0x49Y, 0x0FY, 0xAFY, 0xCFY);
    assert(buffer.length() == 8);
}

@test fun testAsmIdivlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.idivlr(RAX);
    asm.idivlr(R15);
    let buffer = asm.finalize();

    asm2(buffer, 0, 0xF7Y, 0xF8Y);
    asm3(buffer, 2, 0x41Y, 0xF7Y, 0xFFY);
    assert(buffer.length() == 5);
}

@test fun testAsmIdivqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.idivqr(RAX);
    asm.idivqr(R15);
    let buffer = asm.finalize();

    asm3(buffer, 0, 0x48Y, 0xF7Y, 0xF8Y);
    asm3(buffer, 3, 0x49Y, 0xF7Y, 0xFFY);
    assert(buffer.length() == 6);
}
