let RAX: Register = Register(0I);
let RCX: Register = Register(1I);
let RDX: Register = Register(2I);
let RBX: Register = Register(3I);
let RSP: Register = Register(4I);
let RBP: Register = Register(5I);
let RSI: Register = Register(6I);
let RDI: Register = Register(7I);

let R8: Register = Register(8I);
let R9: Register = Register(9I);
let R10: Register = Register(10I);
let R11: Register = Register(11I);
let R12: Register = Register(12I);
let R13: Register = Register(13I);
let R14: Register = Register(14I);
let R15: Register = Register(15I);

let XMM0: XmmRegister = XmmRegister(0I);
let XMM1: XmmRegister = XmmRegister(1I);
let XMM2: XmmRegister = XmmRegister(2I);
let XMM3: XmmRegister = XmmRegister(3I);
let XMM4: XmmRegister = XmmRegister(4I);
let XMM5: XmmRegister = XmmRegister(5I);
let XMM6: XmmRegister = XmmRegister(6I);
let XMM7: XmmRegister = XmmRegister(7I);

let XMM8: XmmRegister = XmmRegister(8I);
let XMM9: XmmRegister = XmmRegister(9I);
let XMM10: XmmRegister = XmmRegister(10I);
let XMM11: XmmRegister = XmmRegister(11I);
let XMM12: XmmRegister = XmmRegister(12I);
let XMM13: XmmRegister = XmmRegister(13I);
let XMM14: XmmRegister = XmmRegister(14I);
let XMM15: XmmRegister = XmmRegister(15I);

class XmmRegister(let value: Int32) {
    fn lowBits(): Int32 = self.value & 0b111I;
    fn needsRexBit(): Bool = self.value > 7I;
}

enum JumpDistance {
    Near,
    Far,
}

class AssemblerX64: Assembler {
    let buffer: AssemblerBuffer = AssemblerBuffer();
    let jumps: Vec[(Int64, Label, JumpDistance)] = Vec();

    fn createLabel(): Label {
        self.buffer.createLabel()
    }

    fn bindLabel(lbl: Label) {
        self.buffer.bindLabel(lbl);
    }

    fn createAndBindLabel(): Label {
        self.buffer.createAndBindLabel()
    }

    fn addlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x01Y);
        self.emitModRmReg(src, dest);
    }

    fn addqri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b000I, 0x05Y);
    }

    fn addqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x01Y);
        self.emitModRmReg(src, dest);
    }

    fn addssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x58Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn addsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x58Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn andlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x21Y);
        self.emitModRmReg(src, dest);
    }

    fn andqri(lhs: Register, imm: Immediate) {
        self.emitAlu64Imm(lhs, imm, 0b100I, 0x25Y);
    }

    fn andqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x21Y);
        self.emitModRmReg(src, dest);
    }

    fn callr(src: Register) {
        self.emitRex32RmFieldOptional(src);
        self.emitByte(0xFFY);
        self.emitModRmOpcode(0b010I, src);
    }

    fn cdq() {
        self.emitByte(0x99Y);
    }

    fn cmovl(condition: Condition, dest: Register, src: Register) {
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte((0x40I + condition.toInt32()).toUInt8());
        self.emitModRmReg(dest, src);
    }

    fn cmovq(condition: Condition, dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte((0x40I + condition.toInt32()).toUInt8());
        self.emitModRmReg(dest, src);
    }

    fn cmpbai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt8() || rhs.isUInt8());
        self.emitRex32AddressOptional(lhs);
        self.emitByte(0x80Y);
        self.emitAddress(0b111I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn cmpbar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressByteOptional(rhs, lhs);
        self.emitByte(0x38Y);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmplai(lhs: Address, imm: Immediate) {
        assert(imm.isInt32() || imm.isUInt32());
        self.emitRex32AddressOptional(lhs);

        if imm.isInt8() {
            self.emitByte(0x83Y);
            self.emitAddress(0b111I, lhs);
            self.emitByte(imm.toUInt8());
        } else {
            self.emitByte(0x81Y);
            self.emitAddress(0b111I, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn cmplar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressOptional(rhs, lhs);
        self.emitByte(0x39Y);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmplri(lhs: Register, imm: Immediate) {
        self.emitAlu32Imm(lhs, imm, 0b111I, 0x3DY);
    }

    fn cmpqai(lhs: Address, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex64Address(lhs);

        if imm.isInt8() {
            self.emitByte(0x83Y);
            self.emitAddress(0b111I, lhs);
            self.emitByte(imm.toUInt8());
        } else {
            self.emitByte(0x81Y);
            self.emitAddress(0b111I, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn cmpqar(lhs: Address, rhs: Register) {
        self.emitRex64ModRmAddress(rhs, lhs);
        self.emitByte(0x39Y);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmplrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x39Y);
        self.emitModRmReg(src, dest);
    }

    fn cmpqri(lhs: Register, imm: Immediate) {
        self.emitAlu64Imm(lhs, imm, 0b111I, 0x3DY);
    }

    fn cmpqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x39Y);
        self.emitModRmReg(src, dest);
    }

    fn cqo() {
        self.emitRex64();
        self.emitByte(0x99Y);
    }

    fn cvtsd2ssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5AY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn cvtsi2ssdrr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2AY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2ssqrr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2AY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2sddrr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF2Y);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2AY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2sdqrr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF2Y);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2AY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvtss2sdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5AY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn cvttsd2sidrr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2CY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvttsd2siqrr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2CY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvttss2sidrr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2CY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn cvttss2siqrr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x2CY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn divssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5EY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn divsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5EY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn idivlr(src: Register) {
        self.emitRex32RmFieldOptional(src);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b111I, src);
    }

    fn idivqr(src: Register) {
        self.emitRex64RmField(src);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b111I, src);
    }

    fn imullrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xAFY);
        self.emitModRmReg(dest, src);
    }

    fn imulqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xAFY);
        self.emitModRmReg(dest, src);
    }

    fn int3() {
        self.emitByte(0xCCY);
    }

    fn jcc(condition: Condition, dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2L);
            assert(distance <= -2L);

            if distance >= -128L {
                self.emitByte((0x70I + condition.toInt32()).toUInt8());
                self.emitByte(distance.toUInt8());
            } else {
                let distance = dest.offset - (self.size() + 6L);
                assert(distance.toInt32().toInt64() == distance);
                self.emitByte(0x0FY);
                self.emitByte((0x80I + condition.toInt32()).toUInt8());
                self.emitInt32(distance.toInt32());
            }
        } else {
            // forward jump - conservatively assume far jump
            self.emitByte(0x0FY);
            self.emitByte((0x80I + condition.toInt32()).toUInt8());
            self.emitJump(dest, JumpDistance::Far);
            self.emitInt32(0I);
        }
    }

    fn jccNear(condition: Condition, dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2L);
            assert(-128L <= distance && distance <= -2L);
            self.emitByte((0x70I + condition.toInt32()).toUInt8());
            self.emitByte(distance.toUInt8());
        } else {
            // forward jump
            self.emitByte((0x70I + condition.toInt32()).toUInt8());
            self.emitJump(dest, JumpDistance::Near);
            self.emitByte(0Y);
        }
    }

    fn jmpr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xFFY);
        self.emitModRmOpcode(0b100I, reg);
    }

    fn jmp(dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2L);
            assert(distance <= -2L);

            if distance >= -128L {
                self.emitByte(0xEBY);
                self.emitByte(distance.toUInt8());
            } else {
                let distance = dest.offset - (self.size() + 5L);
                assert(distance.toInt32().toInt64() == distance);
                self.emitByte(0xE9Y);
                self.emitInt32(distance.toInt32());
            }
        } else {
            // forward jump - conservatively assume far jump
            self.emitByte(0xE9Y);
            self.emitJump(dest, JumpDistance::Far);
            self.emitInt32(0I);
        }
    }

    fn jmpNear(dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2L);
            assert(-128L <= distance && distance <= -2L);
            self.emitByte(0xEBY);
            self.emitByte(distance.toUInt8());
        } else {
            // forward jump
            self.emitByte(0xEBY);
            self.emitJump(dest, JumpDistance::Near);
            self.emitByte(0Y);
        }
    }

    fn lea(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x8DY);
        self.emitAddress(dest.lowBits(), src);
    }

    fn lzcntlrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBDY);
        self.emitModRmReg(dest, src);
    }

    fn lzcntqrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBDY);
        self.emitModRmReg(dest, src);
    }

    fn movbai(dest: Address, src: Immediate) {
        assert(src.isInt8() || src.isUInt8());
        self.emitRex32AddressOptional(dest);
        self.emitByte(0xC6Y);
        self.emitAddress(0b000I, dest);
        self.emitByte(src.toUInt8());
    }

    fn movbar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressByteOptional(src, dest);
        self.emitByte(0x88Y);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movdrx(dest: Register, src: XmmRegister) {
        self.emitByte(0x66Y);
        self.emitRexOptional(false, src.needsRexBit(), false, dest.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x7EY);
        self.emitModRm(0b11I, src.lowBits(), dest.lowBits());
    }

    fn movdxr(dest: XmmRegister, src: Register) {
        self.emitByte(0x66Y);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x6EY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn movlai(dest: Address, imm: Immediate) {
        assert(imm.isInt32() || imm.isUInt32());
        self.emitRex32AddressOptional(dest);
        self.emitByte(0xC7Y);
        self.emitAddress(0b000I, dest);
        self.emitInt32(imm.toInt32());
    }

    fn movlar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressOptional(src, dest);
        self.emitByte(0x89Y);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movlra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x8BY);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movlri(dest: Register, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex32RmFieldOptional(dest);
        self.emitByte((0xB8I + dest.lowBits()).toUInt8());
        self.emitInt32(imm.toInt32());
    }

    fn movlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x89Y);
        self.emitModRmReg(src, dest);
    }

    fn movqar(dest: Address, src: Register) {
        self.emitRex64ModRmAddress(src, dest);
        self.emitByte(0x89Y);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movqai(dest: Address, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex64Address(dest);
        self.emitByte(0xC7Y);
        self.emitAddress(0b000I, dest);
        self.emitInt32(imm.toInt32());
    }

    fn movqra(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x8BY);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movqri(dest: Register, imm: Immediate) {
        if imm.isInt32() {
            self.emitRex64RmField(dest);
            self.emitByte(0xC7Y);
            self.emitModRmOpcode(0I, dest);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitRex64RmField(dest);
            self.emitByte((0xB8I + dest.lowBits()).toUInt8());
            self.emitInt64(imm.toInt64());
        }
    }

    fn movqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x89Y);
        self.emitModRmReg(src, dest);
    }

    fn movqrx(dest: Register, src: XmmRegister) {
        self.emitByte(0x66Y);
        self.emitRexOptional(true, src.needsRexBit(), false, dest.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x7EY);
        self.emitModRm(0b11I, src.lowBits(), dest.lowBits());
    }

    fn movqxr(dest: XmmRegister, src: Register) {
        self.emitByte(0x66Y);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0FY);
        self.emitByte(0x6EY);
        self.emitModRm(0b11I, dest.lowBits(), src.lowBits());
    }

    fn movsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x10Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn movsdra(dest: XmmRegister, src: Address) {
        self.emitByte(0xF2Y);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x10Y);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsdar(dest: Address, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseAddressOptional(src, dest);
        self.emitByte(0x0FY);
        self.emitByte(0x11Y);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movssar(dest: Address, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseAddressOptional(src, dest);
        self.emitByte(0x0FY);
        self.emitByte(0x11Y);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x10Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn movssra(dest: XmmRegister, src: Address) {
        self.emitByte(0xF3Y);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x10Y);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsxblra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBEY);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsxblrr(dest: Register, src: Register) {
        self.emitRex32ModRmByteOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBEY);
        self.emitModRmReg(dest, src);
    }

    fn movsxbqra(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBEY);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsxbqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBEY);
        self.emitModRmReg(dest, src);
    }

    fn movsxlqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x63Y);
        self.emitModRmReg(dest, src);
    }

    fn movzxbrr(dest: Register, src: Register) {
        self.emitRex32ModRmByteOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xB6Y);
        self.emitModRmReg(dest, src);
    }

    fn movzxbra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xB6Y);
        self.emitAddress(dest.lowBits(), src);
    }

    fn mulssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x59Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn mulsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x59Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn neglr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b011I, reg);
    }

    fn negqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b011I, reg);
    }

    fn nop() {
        self.emitByte(0x90Y);
    }

    fn notlr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b010I, reg);
    }

    fn notqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xF7Y);
        self.emitModRmOpcode(0b010I, reg);
    }

    fn orlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x09Y);
        self.emitModRmReg(src, dest);
    }

    fn orqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x09Y);
        self.emitModRmReg(src, dest);
    }

    fn pushqr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte((0x50I + reg.lowBits()).toUInt8());
    }

    fn popcntlrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xB8Y);
        self.emitModRmReg(dest, src);
    }

    fn popcntqrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xB8Y);
        self.emitModRmReg(dest, src);
    }

    fn popqr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte((0x58I + reg.lowBits()).toUInt8());
    }

    fn pxorrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0x66Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xEFY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn retq() {
        self.emitByte(0xC3Y);
    }

    fn rollr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b000I, reg);
    }

    fn rolqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b000I, reg);
    }

    fn rorlr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b001I, reg);
    }

    fn rorqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b001I, reg);
    }

    fn sarlr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b111I, reg);
    }

    fn sarlri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b111I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn sarqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b111I, reg);
    }

    fn sarqri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b111I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn setccr(condition: Condition, dest: Register) {
        if dest.needsRexBit() || dest.lowBits() > 3I {
            self.emitRex(false, false, false, dest.needsRexBit());
        }

        self.emitByte(0x0FY);
        self.emitByte((0x90I + condition.toInt32()).toUInt8());
        self.emitModRmOpcode(0I, dest);
    }

    fn shllr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b100I, reg);
    }

    fn shllri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b100I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shlqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b100I, reg);
    }

    fn shlqri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b100I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shrlr(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b101I, reg);
    }

    fn shrlri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b101I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shrqr(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3Y);
        self.emitModRmOpcode(0b101I, reg);
    }

    fn shrqri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1Y);
        self.emitModRmOpcode(0b101I, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn sqrtssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x51Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn sqrtsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x51Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn sublrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x29Y);
        self.emitModRmReg(src, dest);
    }

    fn subqri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b101I, 0x2DY);
    }

    fn subqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x29Y);
        self.emitModRmReg(src, dest);
    }

    fn subssrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5CY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn subsdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x5CY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn testlrr(lhs: Register, rhs: Register) {
        self.emitRex32ModRmOptional(rhs, lhs);
        self.emitByte(0x85Y);
        self.emitModRmReg(rhs, lhs);
    }

    fn testlri(lhs: Register, imm: Immediate) {
        assert(imm.isInt32());

        if imm.isUInt8() {
            if lhs == RAX {
                self.emitByte(0xA8Y);
            } else if lhs.value < 4I {
                self.emitByte(0xF6Y);
                self.emitModRmOpcode(0b000I, lhs);
            } else {
                self.emitRex(false, false, false, lhs.needsRexBit());
                self.emitByte(0xF6Y);
                self.emitModRmOpcode(0b000I, lhs);
            }
            self.emitByte(imm.toUInt8());
        } else if lhs == RAX {
            self.emitByte(0xA9Y);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0xF7Y);
            self.emitModRmOpcode(0b000I, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn testlar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressOptional(rhs, lhs);
        self.emitByte(0x85Y);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn testlai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt32());
        self.emitRex32AddressOptional(lhs);
        self.emitByte(0xF7Y);
        self.emitAddress(0b000I, lhs);
        self.emitInt32(rhs.toInt32());
    }

    fn testqrr(lhs: Register, rhs: Register) {
        self.emitRex64ModRm(rhs, lhs);
        self.emitByte(0x85Y);
        self.emitModRmReg(rhs, lhs);
    }

    fn testqai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt32());
        self.emitRex64Address(lhs);
        self.emitByte(0xF7Y);
        self.emitAddress(0b000I, lhs);
        self.emitInt32(rhs.toInt32());
    }

    fn testqar(lhs: Address, rhs: Register) {
        self.emitRex64ModRmAddress(rhs, lhs);
        self.emitByte(0x85Y);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn tzcntlrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBCY);
        self.emitModRmReg(dest, src);
    }

    fn tzcntqrr(dest: Register, src: Register) {
        self.emitByte(0xF3Y);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0xBCY);
        self.emitModRmReg(dest, src);
    }

    fn ucomissrr(dest: XmmRegister, src: XmmRegister) {
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x2EY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn ucomisdrr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0x66Y);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x2EY);
        self.emitModRmSseRegisters(dest, src);
    }

    fn xorlrr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x31Y);
        self.emitModRmReg(src, dest);
    }

    fn xorlri(lhs: Register, rhs: Immediate) {
        self.emitAlu32Imm(lhs, rhs, 0b110I, 0x35Y);
    }

    fn xorpdra(dest: XmmRegister, src: Address) {
        self.emitByte(0x66Y);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x57Y);
        self.emitAddress(dest.lowBits(), src);
    }

    fn xorpsra(dest: XmmRegister, src: Address) {
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x57Y);
        self.emitAddress(dest.lowBits(), src);
    }

    fn xorpsrr(dest: XmmRegister, src: XmmRegister) {
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0FY);
        self.emitByte(0x57Y);
        self.emitModRmSseRegisters(dest, src);
    }

    fn xorqrr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x31Y);
        self.emitModRmReg(src, dest);
    }

    fn emitAlu64Imm(reg: Register, imm: Immediate, modrm_reg: Int32, rax_opcode: UInt8) {
        assert(imm.isInt32());
        self.emitRex64RmField(reg);

        if imm.isInt8() {
            self.emitByte(0x83Y);
            self.emitModRm(0b11I, modrm_reg, reg.lowBits());
            self.emitByte(imm.toUInt8());
        } else if reg == RAX {
            self.emitByte(rax_opcode);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0x81Y);
            self.emitModRm(0b11I, modrm_reg, reg.lowBits());
            self.emitInt32(imm.toInt32());
        }
    }

    fn emitAlu32Imm(reg: Register, imm: Immediate, modrm_reg: Int32, rax_opcode: UInt8) {
        assert(imm.isInt32());
        self.emitRex32RmFieldOptional(reg);

        if imm.isInt8() {
            self.emitByte(0x83Y);
            self.emitModRmOpcode(modrm_reg, reg);
            self.emitByte(imm.toUInt8());
        } else if reg == RAX {
            self.emitByte(rax_opcode);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0x81Y);
            self.emitModRmOpcode(modrm_reg, reg);
            self.emitInt32(imm.toInt32());
        }
    }

    fn emitRex32RmFieldOptional(reg: Register) {
        if reg.needsRexBit() {
            self.emitRex(false, false, false, true);
        }
    }

    fn emitRex64RmField(modrm_rm: Register) {
        self.emitRex(true, false, false, modrm_rm.needsRexBit());
    }

    fn emitRex64ModRm(modrm_reg: Register, modrm_rm: Register) {
        self.emitRex(true, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
    }

    fn emitRex32ModRmOptional(modrm_reg: Register, modrm_rm: Register) {
        if modrm_reg.needsRexBit() || modrm_rm.needsRexBit() {
            self.emitRex(false, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
        }
    }

    fn emitRex32ModRmByteOptional(modrm_reg: Register, modrm_rm: Register) {
        if modrm_reg.needsRexBit() || modrm_rm.needsRexBit() || modrm_rm.value > 3I {
            self.emitRex(false, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
        }
    }

    fn emitRex32ModRmAddressOptional(reg: Register, address: Address) {
        if address.rex != 0Y || reg.needsRexBit() {
            let rex = 0x40I | address.rex.toInt32() | if reg.needsRexBit() { 0x04I } else { 0I };
            self.emitByte(rex.toUInt8());
        };
    }

    fn emitRex32ModRmAddressByteOptional(reg: Register, address: Address) {
        if address.rex != 0Y || reg.value > 3I {
            let rex = 0x40I | address.rex.toInt32() | if reg.needsRexBit() { 0x04I } else { 0I };
            self.emitByte(rex.toUInt8());
        };
    }

    fn emitRex32AddressOptional(address: Address) {
        if address.rex != 0Y {
            self.emitByte((0x40I | address.rex.toInt32()).toUInt8());
        }
    }

    fn emitRex64ModRmAddress(reg: Register, address: Address) {
        let rex = 0x48I | address.rex.toInt32() | if reg.needsRexBit() { 0x04I } else { 0I };
        self.emitByte(rex.toUInt8());
    }

    fn emitRex64Address(address: Address) {
        self.emitByte((0x48I | address.rex.toInt32()).toUInt8());
    }

    fn emitRex64() {
        self.emitRex(true, false, false, false);
    }

    fn emitRexSseModRmOptional(reg: XmmRegister, rm: XmmRegister) {
        if reg.needsRexBit() || rm.needsRexBit() {
            self.emitRex(false, reg.needsRexBit(), false, rm.needsRexBit());
        }
    }

    fn emitRexSseAddressOptional(reg: XmmRegister, address: Address) {
        if reg.needsRexBit() || address.rex != 0Y {
            let value = 0x40I | address.rex.toInt32() | if reg.needsRexBit() { 0x04I } else { 0I };
            self.emitByte(value.toUInt8());
        }
    }

    fn emitRexOptional(w: Bool, r: Bool, x: Bool, b: Bool) {
        if w || r || x || b {
            self.emitRex(w, r, x, b);
        }
    }

    fn emitRex(w: Bool, r: Bool, x: Bool, b: Bool) {
        // w - 64-bit width
        // r - extension of modrm-reg field
        // x - extension of sib index field
        // b - extension of modrm-rm/sib base/opcode reg field
        let opcode = 0x40I | w.toInt32() << 3I | r.toInt32() << 2I | x.toInt32() << 1I | b.toInt32();
        self.emitByte(opcode.toUInt8());
    }

    fn emitAddress(reg_or_opcode: Int32, address: Address) {
        assert(reg_or_opcode < 8I);

        self.emitByte((reg_or_opcode << 3I | address.bytes(0L).toInt32()).toUInt8());

        var i = 1L;

        while i < address.length {
            self.emitByte(address.bytes(i));
            i = i + 1L;
        }
    }

    fn emitModRmReg(reg: Register, rm: Register) {
        self.emitModRm(0b11I, reg.lowBits(), rm.lowBits());
    }

    fn emitModRmOpcode(opcode: Int32, rm: Register) {
        self.emitModRm(0b11I, opcode, rm.lowBits());
    }

    fn emitModRmSseRegisters(reg: XmmRegister, rm: XmmRegister) {
        self.emitModRm(0b11I, reg.lowBits(), rm.lowBits());
    }

    fn emitModRm(mode: Int32, reg: Int32, rm: Int32) {
        assert(mode < 4I && reg < 8I && rm < 8I);
        self.emitByte((mode << 6I | reg << 3I | rm).toUInt8());
    }

    fn emitSib(scale: Int32, index: Int32, base: Int32) {
        assert(scale < 4I);
        assert(index < 8I);
        assert(base < 8I);
        self.emitByte((scale << 6I | index << 3I | base).toUInt8());
    }

    fn emitByte(value: UInt8) {
        self.buffer.emitByte(value);
    }

    fn emitInt32(value: Int32) {
        self.buffer.emitInt32(value);
    }

    fn emitInt64(value: Int64) {
        self.buffer.emitInt64(value);
    }

    fn emitJump(lbl: Label, kind: JumpDistance) {
        let pc = self.buffer.size();
        self.jumps.push((pc, lbl, kind));
    }

    fn size(): Int64 {
        self.buffer.size()
    }

    fn finalize(): Array[UInt8] {
        self.resolveJumps();
        while self.buffer.size() % 16 != 0 {
            self.int3();
        }
        self.buffer.toArray()
    }

    fn finalizeTesting(): MachineCode {
        self.resolveJumps();
        MachineCode(self.buffer.toArray())
    }

    fn resolveJumps() {
        for (pc, lbl, distance) in self.jumps {
            assert(lbl.isBound());

            if distance == JumpDistance::Near {
                let distance = lbl.offset - (pc + 1L);
                assert(-128L <= distance && distance <= 127L);
                self.buffer.patchUInt8(pc, distance.toUInt8());
            } else {
                assert(distance == JumpDistance::Far);
                let distance = lbl.offset - (pc + 4L);
                assert(distance.toInt32().toInt64() == distance);
                self.buffer.patchInt32(pc, distance.toInt32());
            }
        }

        self.jumps.clear();
    }
}

enum Condition {
    Overflow,
    NoOverflow,
    Below,
    NeitherAboveNorEqual,
    NotBelow,
    AboveOrEqual,
    Equal,
    Zero,
    NotEqual,
    NotZero,
    BelowOrEqual,
    NotAbove,
    NeitherBelowNorEqual,
    Above,
    Sign,
    NoSign,
    Parity,
    ParityEven,
    NoParity,
    ParityOdd,
    Less,
    NeitherGreaterNorEqual,
    NotLess,
    GreaterOrEqual,
    LessOrEqual,
    NotGreater,
    NeitherLessNorEqual,
    Greater,
}

impl Condition {
    fn toInt32(): Int32 {
        if self == Condition::Overflow {
            0b0000I
        } else if self == Condition::NoOverflow {
            0b0001I
        } else if self == Condition::Below {
            0b0010I
        } else if self == Condition::NeitherAboveNorEqual {
            0b0010I
        } else if self == Condition::NotBelow {
            0b0011I
        } else if self == Condition::AboveOrEqual {
            0b0011I
        } else if self == Condition::Equal {
            0b0100I
        } else if self == Condition::Zero {
            0b0100I
        } else if self == Condition::NotEqual {
            0b0101I
        } else if self == Condition::NotZero {
            0b0101I
        } else if self == Condition::BelowOrEqual {
            0b0110I
        } else if self == Condition::NotAbove {
            0b0110I
        } else if self == Condition::NeitherBelowNorEqual {
            0b0111I
        } else if self == Condition::Above {
            0b0111I
        } else if self == Condition::Sign {
            0b1000I
        } else if self == Condition::NoSign {
            0b1001I
        } else if self == Condition::Parity {
            0b1010I
        } else if self == Condition::ParityEven {
            0b1010I
        } else if self == Condition::NoParity {
            0b1011I
        } else if self == Condition::ParityOdd {
            0b1011I
        } else if self == Condition::Less {
            0b1100I
        } else if self == Condition::NeitherGreaterNorEqual {
            0b1100I
        } else if self == Condition::NotLess {
            0b1101I
        } else if self == Condition::GreaterOrEqual {
            0b1101I
        } else if self == Condition::LessOrEqual {
            0b1110I
        } else if self == Condition::NotGreater {
            0b1110I
        } else if self == Condition::NeitherLessNorEqual {
            0b1111I
        } else if self == Condition::Greater {
            0b1111I
        } else {
            unreachable[Int32]()
        }
    }
}

class Immediate(let value: Int64) {
    fn isInt8(): Bool {
        let limit = 1L << 7I;
        -limit <= self.value && self.value < limit
    }

    fn isUInt8(): Bool {
        0L <= self.value && self.value < 256L
    }

    fn isInt32(): Bool {
        let limit = 1L << 32I;
        -limit <= self.value && self.value < limit
    }

    fn isUInt32(): Bool {
        let limit = 1L << 32I;
        0L <= self.value && self.value < limit
    }

    fn toUInt8(): UInt8 {
        self.value.toUInt8()
    }

    fn toInt32(): Int32 {
        self.value.toInt32()
    }

    fn toInt64(): Int64 {
        self.value
    }
}

enum ScaleFactor {
    One,
    Two,
    Four,
    Eight,
}

impl ScaleFactor {
    fn value(): Int32 {
        if self == ScaleFactor::One {
            0I
        } else if self == ScaleFactor::Two {
            1I
        } else if self == ScaleFactor::Four {
            2I
        } else if self == ScaleFactor::Eight {
            3I
        } else {
            unreachable[Int32]()
        }
    }
}

class Address {
    var rex: UInt8 = 0Y;
    var length: Int64 = 0L;
    let bytes: Array[UInt8] = Array[UInt8]::zero(6L);

    fn set_modrm(mode: Int32, reg: Register) {
        assert(self.length == 0L);
        assert(0I <= mode && mode < 4I);

        if reg.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x41I).toUInt8();
        }

        self.bytes(0L) = (mode << 6I | reg.lowBits()).toUInt8();
        self.length = self.length + 1L;
    }

    fn set_sib(scale: ScaleFactor, index: Register, base: Register) {
        assert(self.length == 1L);

        if base.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x41I).toUInt8();
        }

        if base.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x42I).toUInt8();
        }

        self.bytes(1L) = (scale.value() << 6I | index.lowBits() << 3I | base.lowBits()).toUInt8();
        self.length = self.length + 1L;
    }

    fn set_disp8(imm: Int32) {
        assert(self.length == 1L || self.length == 2L);
        self.bytes(self.length) = imm.toUInt8();
        self.length = self.length + 1L;
    }

    fn set_disp32(imm: Int32) {
        assert(self.length == 1L || self.length == 2L);
        self.bytes(self.length) = imm.toUInt8();
        self.bytes(self.length + 1L) = (imm >> 8I).toUInt8();
        self.bytes(self.length + 2L) = (imm >> 16I).toUInt8();
        self.bytes(self.length + 3L) = (imm >> 24I).toUInt8();
        self.length = self.length + 4L;
    }

    @static fn offset(base: Register, offset: Int32): Address {
        let address = Address();

        let mode = if offset == 0I && base != RBP {
            0b00I
        } else if -128I <= offset && offset < 128I {
            0b01I
        } else {
            0b10I
        };

        address.set_modrm(mode, base);

        if base == RSP {
            address.set_sib(ScaleFactor::One, RSP, base);
        }

        if mode == 0b00I {
            // nothing to do
        } else if mode == 0b01I {
            address.set_disp8(offset);
        } else if mode == 0b10I {
            address.set_disp32(offset);
        } else {
            unreachable[()]();
        }

        address
    }

    @static fn index(index: Register, factor: ScaleFactor, disp: Int32): Address {
        let address = Address();

        address.set_modrm(0b00I, RSP);
        assert(index != RSP);

        address.set_sib(factor, index, RBP);
        address.set_disp32(disp);

        address
    }

    @static fn array(base: Register, index: Register, factor: ScaleFactor, disp: Int32): Address {
        let address = Address();

        let mode = if disp == 0I && base != RBP {
            0b00I
        } else if -128I <= disp && disp < 128I {
            0b01I
        } else {
            0b10I
        };

        address.set_modrm(mode, RSP);
        assert(index != RSP);

        address.set_sib(factor, index, base);

        if mode == 0b00I {
            // nothing to do
        } else if mode == 0b01I {
            address.set_disp8(disp);
        } else if mode == 0b10I {
            address.set_disp32(disp);
        } else {
            unreachable[()]();
        }

        address
    }

    @static fn rip(disp: Int32): Address {
        let address = Address();

        address.set_modrm(0b00I, RBP);
        address.set_disp32(disp);

        address
    }
}

@test fn testConditionCodes() {
    assert(Condition::Overflow.toInt32() == 0b0000I);

    assert(Condition::NoOverflow.toInt32() == 0b0001I);

    assert(Condition::Below.toInt32() == 0b0010I);
    assert(Condition::NeitherAboveNorEqual.toInt32() == 0b0010I);

    assert(Condition::NotBelow.toInt32() == 0b0011I);
    assert(Condition::AboveOrEqual.toInt32() == 0b0011I);

    assert(Condition::Equal.toInt32() == 0b0100I);
    assert(Condition::Zero.toInt32() == 0b0100I);

    assert(Condition::NotEqual.toInt32() == 0b0101I);
    assert(Condition::NotZero.toInt32() == 0b0101I);

    assert(Condition::BelowOrEqual.toInt32() == 0b0110I);
    assert(Condition::NotAbove.toInt32() == 0b0110I);

    assert(Condition::NeitherBelowNorEqual.toInt32() == 0b0111I);
    assert(Condition::Above.toInt32() == 0b0111I);

    assert(Condition::Sign.toInt32() == 0b1000I);

    assert(Condition::NoSign.toInt32() == 0b1001I);

    assert(Condition::Parity.toInt32() == 0b1010I);
    assert(Condition::ParityEven.toInt32() == 0b1010I);

    assert(Condition::NoParity.toInt32() == 0b1011I);
    assert(Condition::ParityOdd.toInt32() == 0b1011I);

    assert(Condition::Less.toInt32() == 0b1100I);
    assert(Condition::NeitherGreaterNorEqual.toInt32() == 0b1100I);

    assert(Condition::NotLess.toInt32() == 0b1101I);
    assert(Condition::GreaterOrEqual.toInt32() == 0b1101I);

    assert(Condition::LessOrEqual.toInt32() == 0b1110I);
    assert(Condition::NotGreater.toInt32() == 0b1110I);

    assert(Condition::NeitherLessNorEqual.toInt32() == 0b1111I);
    assert(Condition::Greater.toInt32() == 0b1111I);

}

impl Register {
    fn lowBits(): Int32 = self.value & 0b111I;

    fn needsRexBit(): Bool = self.value > 7I;
}

@test fn testAsmRegisters() {
    assert(RAX.lowBits() == 0I && !RAX.needsRexBit());
    assert(RCX.lowBits() == 1I && !RCX.needsRexBit());
    assert(RDX.lowBits() == 2I && !RDX.needsRexBit());
    assert(RBX.lowBits() == 3I && !RBX.needsRexBit());
    assert(RSP.lowBits() == 4I && !RSP.needsRexBit());
    assert(RBP.lowBits() == 5I && !RBP.needsRexBit());
    assert(RSI.lowBits() == 6I && !RSI.needsRexBit());
    assert(RDI.lowBits() == 7I && !RDI.needsRexBit());

    assert(R8.lowBits() == 0I && R8.needsRexBit());
    assert(R9.lowBits() == 1I && R9.needsRexBit());
    assert(R10.lowBits() == 2I && R10.needsRexBit());
    assert(R11.lowBits() == 3I && R11.needsRexBit());
    assert(R12.lowBits() == 4I && R12.needsRexBit());
    assert(R13.lowBits() == 5I && R13.needsRexBit());
    assert(R14.lowBits() == 6I && R14.needsRexBit());
    assert(R15.lowBits() == 7I && R15.needsRexBit());
}

@test fn testAsmPushqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.pushqr(RAX);
    asm.pushqr(RSP);
    asm.pushqr(R8);
    asm.pushqr(R15);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x50Y);
    assertAsm(buffer, 0x54Y);
    assertAsm(buffer, 0x41Y, 0x50Y);
    assertAsm(buffer, 0x41Y, 0x57Y);
    assertAsmEnd(buffer);
}

@test fn testAsmPopqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.popqr(RAX);
    asm.popqr(RSP);
    asm.popqr(R8);
    asm.popqr(R15);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x58Y);
    assertAsm(buffer, 0x5CY);
    assertAsm(buffer, 0x41Y, 0x58Y);
    assertAsm(buffer, 0x41Y, 0x5FY);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqrr(R15, RAX);
    asm.movqrr(RAX, R15);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x49Y, 0x89Y, 0xC7Y);
    assertAsm(buffer, 0x4CY, 0x89Y, 0xF8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlrr(R15, RAX);
    asm.movlrr(RAX, R15);
    asm.movlrr(RCX, RAX);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x41Y, 0x89Y, 0xC7Y);
    assertAsm(buffer, 0x44Y, 0x89Y, 0xF8Y);
    assertAsm(buffer, 0x89Y, 0xC1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAddqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addqrr(RAX, RBX);
    asm.addqrr(RAX, R12);
    asm.addqrr(R12, RAX);
    asm.addqrr(R15, RSP);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x48Y, 0x01Y, 0xD8Y);
    assertAsm(buffer, 0x4CY, 0x01Y, 0xE0Y);
    assertAsm(buffer, 0x49Y, 0x01Y, 0xC4Y);
    assertAsm(buffer, 0x49Y, 0x01Y, 0xE7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAddlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addlrr(RAX, RBX);
    asm.addlrr(RCX, R15);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x01Y, 0xD8Y);
    assertAsm(buffer, 0x44Y, 0x01Y, 0xF9Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAddqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.addqri(RAX, Immediate(0x11L));
    asm.addqri(R15, Immediate(0x11L));
    asm.addqri(RAX, Immediate(0x2211L));
    asm.addqri(RCX, Immediate(0x2211L));
    asm.addqri(R15, Immediate(0x2211L));
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x48Y, 0x83Y, 0xC0Y, 0x11Y);
    assertAsm(buffer, 0x49Y, 0x83Y, 0xC7Y, 0x11Y);
    assertAsm(buffer, 0x48Y, 0x05Y, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsm(buffer, 0x48Y, 0x81Y, 0xC1Y, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0x81Y, 0xC7Y, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSubqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.subqrr(RAX, RBX);
    asm.subqrr(RCX, R15);
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x48Y, 0x29Y, 0xD8Y);
    assertAsm(buffer, 0x4CY, 0x29Y, 0xF9Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSubqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.subqri(RAX, Immediate(0x11L));
    asm.subqri(R15, Immediate(0x11L));
    asm.subqri(RAX, Immediate(0x2211L));
    asm.subqri(RCX, Immediate(0x2211L));
    asm.subqri(R15, Immediate(0x2211L));
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x48Y, 0x83Y, 0xE8Y, 0x11Y);
    assertAsm(buffer, 0x49Y, 0x83Y, 0xEFY, 0x11Y);
    assertAsm(buffer, 0x48Y, 0x2DY, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsm(buffer, 0x48Y, 0x81Y, 0xE9Y, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0x81Y, 0xEFY, 0x11Y, 0x22Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmRetq(_x: Testing) {
    let asm = AssemblerX64();
    asm.retq();
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0xC3Y);
    assertAsmEnd(buffer);
}

@test fn testAsmNop(_x: Testing) {
    let asm = AssemblerX64();
    asm.nop();
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x90Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCdqCqo(_x: Testing) {
    let asm = AssemblerX64();
    asm.cdq();
    asm.cqo();
    let buffer = asm.finalizeTesting();
    assertAsm(buffer, 0x99Y);
    assertAsm(buffer, 0x48Y, 0x99Y);
    assertAsmEnd(buffer);
}

@test fn testAsmOrlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.orlrr(RAX, R15);
    asm.orlrr(RAX, RCX);
    asm.orlrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x44Y, 0x09Y, 0xF8Y);
    assertAsm(buffer, 0x09Y, 0xC8Y);
    assertAsm(buffer, 0x41Y, 0x09Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmOrqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.orqrr(RAX, R15);
    asm.orqrr(RAX, RCX);
    asm.orqrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x4CY, 0x09Y, 0xF8Y);
    assertAsm(buffer, 0x48Y, 0x09Y, 0xC8Y);
    assertAsm(buffer, 0x49Y, 0x09Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAndlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.andlrr(RAX, R15);
    asm.andlrr(RAX, RCX);
    asm.andlrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x44Y, 0x21Y, 0xF8Y);
    assertAsm(buffer, 0x21Y, 0xC8Y);
    assertAsm(buffer, 0x41Y, 0x21Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAndqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.andqrr(RAX, R15);
    asm.andqrr(RAX, RCX);
    asm.andqrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x4CY, 0x21Y, 0xF8Y);
    assertAsm(buffer, 0x48Y, 0x21Y, 0xC8Y);
    assertAsm(buffer, 0x49Y, 0x21Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmXorlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorlrr(RAX, R15);
    asm.xorlrr(RAX, RCX);
    asm.xorlrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x44Y, 0x31Y, 0xF8Y);
    assertAsm(buffer, 0x31Y, 0xC8Y);
    assertAsm(buffer, 0x41Y, 0x31Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmXorqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorqrr(RAX, R15);
    asm.xorqrr(RAX, RCX);
    asm.xorqrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x4CY, 0x31Y, 0xF8Y);
    assertAsm(buffer, 0x48Y, 0x31Y, 0xC8Y);
    assertAsm(buffer, 0x49Y, 0x31Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmplrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmplrr(RAX, R15);
    asm.cmplrr(R15, RBX);
    asm.cmplrr(RAX, RBX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x44Y, 0x39Y, 0xF8Y);
    assertAsm(buffer, 0x41Y, 0x39Y, 0xDFY);
    assertAsm(buffer, 0x39Y, 0xD8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpqrr(RAX, R15);
    asm.cmpqrr(R15, RBX);
    asm.cmpqrr(RAX, RBX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x4CY, 0x39Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0x39Y, 0xDFY);
    assertAsm(buffer, 0x48Y, 0x39Y, 0xD8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmImullrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.imullrr(RAX, RBX);
    asm.imullrr(RCX, R15);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0xAFY, 0xC3Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0xAFY, 0xCFY);
    assertAsmEnd(buffer);
}

@test fn testAsmImulqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.imulqrr(RAX, RBX);
    asm.imulqrr(RCX, R15);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x0FY, 0xAFY, 0xC3Y);
    assertAsm(buffer, 0x49Y, 0x0FY, 0xAFY, 0xCFY);
    assertAsmEnd(buffer);
}

@test fn testAsmIdivlr(_x: Testing) {
    let asm = AssemblerX64();
    asm.idivlr(RAX);
    asm.idivlr(R15);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF7Y, 0xF8Y);
    assertAsm(buffer, 0x41Y, 0xF7Y, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmIdivqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.idivqr(RAX);
    asm.idivqr(R15);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xF7Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0xF7Y, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmSetccr(_x: Testing) {
    let asm = AssemblerX64();
    asm.setccr(Condition::Equal, RAX);
    asm.setccr(Condition::NotEqual, R15);
    asm.setccr(Condition::GreaterOrEqual, RCX);
    asm.setccr(Condition::Greater, RDX);
    asm.setccr(Condition::LessOrEqual, RSI);
    asm.setccr(Condition::Less, RDI);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0x94Y, 0xC0Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0x95Y, 0xC7Y);
    assertAsm(buffer, 0x0FY, 0x9DY, 0xC1Y);
    assertAsm(buffer, 0x0FY, 0x9FY, 0xC2Y);
    assertAsm(buffer, 0x40Y, 0x0FY, 0x9EY, 0xC6Y);
    assertAsm(buffer, 0x40Y, 0x0FY, 0x9CY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCallr(_x: Testing) {
    let asm = AssemblerX64();
    asm.callr(RAX);
    asm.callr(R15);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xFFY, 0xD0Y);
    assertAsm(buffer, 0x41Y, 0xFFY, 0xD7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmovl(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmovl(Condition::Equal, R15, RAX);
    asm.cmovl(Condition::NotEqual, RAX, R13);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x44Y, 0x0FY, 0x44Y, 0xF8Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0x45Y, 0xC5Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmovq(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmovq(Condition::Greater, RAX, RCX);
    asm.cmovq(Condition::Equal, R15, RAX);
    asm.cmovq(Condition::NotEqual, RAX, R13);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x0FY, 0x4FY, 0xC1Y);
    assertAsm(buffer, 0x4CY, 0x0FY, 0x44Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0x0FY, 0x45Y, 0xC5Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovlri(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlri(RAX, Immediate(2L));
    asm.movlri(R14, Immediate(3L));
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xB8Y, 2Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x41Y, 0xBEY, 3Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqri(RAX, Immediate(1L));
    asm.movqri(R15, Immediate(-1L));
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xC7Y, 0xC0Y, 1Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0xC7Y, 0xC7Y, 0xFFY, 0xFFY, 0xFFY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testTestlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.testlrr(RAX, RAX);
    asm.testlrr(RSI, RAX);
    asm.testlrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x85Y, 0xC0Y);
    assertAsm(buffer, 0x85Y, 0xC6Y);
    assertAsm(buffer, 0x41Y, 0x85Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testTestqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.testqrr(RAX, RAX);
    asm.testqrr(RSI, RAX);
    asm.testqrr(R15, RAX);
    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x85Y, 0xC0Y);
    assertAsm(buffer, 0x48Y, 0x85Y, 0xC6Y);
    assertAsm(buffer, 0x49Y, 0x85Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqra(RAX, Address::offset(RSP, 0I));
    asm.movqra(RAX, Address::offset(RSP, 1I));

    asm.movqra(R15, Address::offset(RSP, 0I));
    asm.movqra(R15, Address::offset(RSP, 1I));

    asm.movqra(R15, Address::offset(RSP, 127I));
    asm.movqra(R15, Address::offset(RSP, -128I));

    asm.movqra(R15, Address::offset(RSP, 128I));
    asm.movqra(R15, Address::offset(RSP, -129I));

    asm.movqra(RAX, Address::offset(RBP, 0I));
    asm.movqra(RAX, Address::offset(RBP, 1I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x8BY, 0x04Y, 0x24Y);
    assertAsm(buffer, 0x48Y, 0x8BY, 0x44Y, 0x24Y, 1Y);

    assertAsm(buffer, 0x4CY, 0x8BY, 0x3CY, 0x24Y);
    assertAsm(buffer, 0x4CY, 0x8BY, 0x7CY, 0x24Y, 1Y);

    assertAsm(buffer, 0x4CY, 0x8BY, 0x7CY, 0x24Y, 0x7FY);
    assertAsm(buffer, 0x4CY, 0x8BY, 0x7CY, 0x24Y, 0x80Y);

    assertAsm(buffer, 0x4CY, 0x8BY, 0xBCY, 0x24Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x4CY, 0x8BY, 0xBCY, 0x24Y, 0x7FY, 0xFFY, 0xFFY, 0xFFY);

    assertAsm(buffer, 0x48Y, 0x8BY, 0x45Y, 0Y);
    assertAsm(buffer, 0x48Y, 0x8BY, 0x45Y, 1Y);

    assertAsmEnd(buffer);
}

@test fn testAsmMovqar(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqar(Address::offset(RBP, 0I), RAX);
    asm.movqar(Address::array(RAX, RBP, ScaleFactor::Four, 1I), RAX);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x89Y, 0x45Y, 0Y);
    assertAsm(buffer, 0x48Y, 0x89Y, 0x44Y, 0xA8Y, 1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovlra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlra(RAX, Address::offset(RBP, 0I));
    asm.movlra(RAX, Address::rip(0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x8BY, 0x45Y, 0Y);
    assertAsm(buffer, 0x8BY, 0x05Y, 0Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovlar(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlar(Address::offset(RBP, 0I), RAX);
    asm.movlar(Address::offset(RBP, 0I), R15);
    asm.movlar(Address::offset(R8, 0I), R15);
    asm.movlar(Address::array(R8, R9, ScaleFactor::Four, 0I), R15);
    asm.movlar(Address::array(RAX, RBP, ScaleFactor::Four, 1I), RAX);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x89Y, 0x45Y, 0Y);
    assertAsm(buffer, 0x44Y, 0x89Y, 0x7DY, 0Y);
    assertAsm(buffer, 0x45Y, 0x89Y, 0x38Y);
    assertAsm(buffer, 0x47Y, 0x89Y, 0x3CY, 0x88Y);
    assertAsm(buffer, 0x89Y, 0x44Y, 0xA8Y, 1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmLea(_x: Testing) {
    let asm = AssemblerX64();
    asm.lea(RAX, Address::offset(RAX, 0I));
    asm.lea(RAX, Address::offset(RAX, 1I));
    asm.lea(RAX, Address::offset(R8, 0I));
    asm.lea(R8, Address::offset(RAX, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x8DY, 0x00Y);
    assertAsm(buffer, 0x48Y, 0x8DY, 0x40Y, 1Y);
    assertAsm(buffer, 0x49Y, 0x8DY, 0x00Y);
    assertAsm(buffer, 0x4CY, 0x8DY, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovbar(_x: Testing) {
    let asm = AssemblerX64();
    asm.movbar(Address::offset(RSP, 0I), RAX);
    asm.movbar(Address::offset(RSP, 0I), RSI);
    asm.movbar(Address::offset(RSP, 0I), R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x88Y, 0x04Y, 0x24Y);
    assertAsm(buffer, 0x40Y, 0x88Y, 0x34Y, 0x24Y);
    assertAsm(buffer, 0x44Y, 0x88Y, 0x04Y, 0x24Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovbai(_x: Testing) {
    let asm = AssemblerX64();
    asm.movbai(Address::offset(RAX, 0I), Immediate(1L));
    asm.movbai(Address::offset(RAX, 0I), Immediate(127L));
    asm.movbai(Address::offset(RAX, 0I), Immediate(255L));
    asm.movbai(Address::offset(RAX, 0I), Immediate(-128L));
    asm.movbai(Address::offset(RAX, 0I), Immediate(128L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xC6Y, 0x00Y, 1Y);
    assertAsm(buffer, 0xC6Y, 0x00Y, 0x7FY);
    assertAsm(buffer, 0xC6Y, 0x00Y, 0xFFY);
    assertAsm(buffer, 0xC6Y, 0x00Y, 0x80Y);
    assertAsm(buffer, 0xC6Y, 0x00Y, 0x80Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqai(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqai(Address::offset(RAX, 0I), Immediate(1L));
    asm.movqai(Address::offset(R8, 0I), Immediate(Int32::maxValue().toInt64()));
    asm.movqai(Address::offset(RDI, 0I), Immediate(Int32::maxValue().toInt64()));
    asm.movqai(Address::offset(R15, 0I), Immediate(Int32::minValue().toInt64()));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xC7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0xC7Y, 0x00Y, 0xFFY, 0xFFY, 0xFFY, 0x7FY);
    assertAsm(buffer, 0x48Y, 0xC7Y, 0x07Y, 0xFFY, 0xFFY, 0xFFY, 0x7FY);
    assertAsm(buffer, 0x49Y, 0xC7Y, 0x07Y, 0Y, 0Y, 0Y, 0x80Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovlai(_x: Testing) {
    let asm = AssemblerX64();
    asm.movlai(Address::offset(RAX, 0I), Immediate(1L));
    asm.movlai(Address::offset(R8, 0I), Immediate((1L << 32I) - 1L));
    asm.movlai(Address::offset(RDI, 0I), Immediate(Int32::maxValue().toInt64()));
    asm.movlai(Address::offset(R15, 0I), Immediate(Int32::minValue().toInt64()));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xC7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x41Y, 0xC7Y, 0x00Y, 0xFFY, 0xFFY, 0xFFY, 0xFFY);
    assertAsm(buffer, 0xC7Y, 0x07Y, 0xFFY, 0xFFY, 0xFFY, 0x7FY);
    assertAsm(buffer, 0x41Y, 0xC7Y, 0x07Y, 0Y, 0Y, 0Y, 0x80Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTestlri(_x: Testing) {
    let asm = AssemblerX64();
    asm.testlri(RAX, Immediate(1L));
    asm.testlri(RCX, Immediate(255L));
    asm.testlri(RDX, Immediate(1L));
    asm.testlri(RBX, Immediate(1L));

    asm.testlri(RSI, Immediate(1L));
    asm.testlri(RDI, Immediate(1L));
    asm.testlri(R8, Immediate(1L));
    asm.testlri(R15, Immediate(1L));

    asm.testlri(RAX, Immediate(256L));
    asm.testlri(RDI, Immediate(256L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xA8Y, 1Y);
    assertAsm(buffer, 0xF6Y, 0xC1Y, 255Y);
    assertAsm(buffer, 0xF6Y, 0xC2Y, 1Y);
    assertAsm(buffer, 0xF6Y, 0xC3Y, 1Y);

    assertAsm(buffer, 0x40Y, 0xF6Y, 0xC6Y, 1Y);
    assertAsm(buffer, 0x40Y, 0xF6Y, 0xC7Y, 1Y);
    assertAsm(buffer, 0x41Y, 0xF6Y, 0xC0Y, 1Y);
    assertAsm(buffer, 0x41Y, 0xF6Y, 0xC7Y, 1Y);

    assertAsm(buffer, 0xA9Y, 0Y, 1Y, 0Y, 0Y);
    assertAsm(buffer, 0xF7Y, 0xC7Y, 0Y, 1Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTestlar(_x: Testing) {
    let asm = AssemblerX64();
    asm.testlar(Address::offset(RDI, 1I), RAX);
    asm.testlar(Address::offset(RDI, 0I), RAX);

    asm.testlar(Address::offset(R8, 0I), RAX);
    asm.testlar(Address::offset(R8, 1I), RAX);
    asm.testlar(Address::offset(R8, 0I), R15);

    asm.testlar(Address::offset(RAX, 0I), R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x85Y, 0x47Y, 1Y);
    assertAsm(buffer, 0x85Y, 0x07Y);

    assertAsm(buffer, 0x41Y, 0x85Y, 0x00Y);
    assertAsm(buffer, 0x41Y, 0x85Y, 0x40Y, 1Y);
    assertAsm(buffer, 0x45Y, 0x85Y, 0x38Y);

    assertAsm(buffer, 0x44Y, 0x85Y, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTestlai(_x: Testing) {
    let asm = AssemblerX64();
    asm.testlai(Address::offset(RAX, 0I), Immediate(1L));
    asm.testlai(Address::offset(RAX, 1I), Immediate(1L));

    asm.testlai(Address::offset(R8, 0I), Immediate(1L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0xF7Y, 0x40Y, 1Y, 1Y, 0Y, 0Y, 0Y);

    assertAsm(buffer, 0x41Y, 0xF7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTestqai(_x: Testing) {
    let asm = AssemblerX64();
    asm.testqai(Address::offset(RAX, 0I), Immediate(1L));
    asm.testqai(Address::offset(RAX, 1I), Immediate(1L));

    asm.testqai(Address::offset(R8, 0I), Immediate(1L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xF7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x48Y, 0xF7Y, 0x40Y, 1Y, 1Y, 0Y, 0Y, 0Y);

    assertAsm(buffer, 0x49Y, 0xF7Y, 0x00Y, 1Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTestqar(_x: Testing) {
    let asm = AssemblerX64();
    asm.testqar(Address::offset(RDI, 1I), RAX);
    asm.testqar(Address::offset(R8, 0I), R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x85Y, 0x47Y, 1Y);
    assertAsm(buffer, 0x4DY, 0x85Y, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovzxbrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movzxbrr(RAX, RAX);
    asm.movzxbrr(RAX, RDI);
    asm.movzxbrr(RDI, RAX);
    asm.movzxbrr(RAX, R15);
    asm.movzxbrr(R15, RBX);
    asm.movzxbrr(RCX, RSI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0xB6Y, 0xC0Y);
    assertAsm(buffer, 0x40Y, 0x0FY, 0xB6Y, 0xC7Y);
    assertAsm(buffer, 0x0FY, 0xB6Y, 0xF8Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0xB6Y, 0xC7Y);
    assertAsm(buffer, 0x44Y, 0x0FY, 0xB6Y, 0xFBY);
    assertAsm(buffer, 0x40Y, 0x0FY, 0xB6Y, 0xCEY);
    assertAsmEnd(buffer);
}

@test fn testAsmMovzxbra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movzxbra(RAX, Address::offset(RAX, 0I));
    asm.movzxbra(R8, Address::offset(RAX, 0I));
    asm.movzxbra(RAX, Address::offset(R8, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0xB6Y, 0x00Y);
    assertAsm(buffer, 0x44Y, 0x0FY, 0xB6Y, 0x00Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0xB6Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsxblrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsxblrr(RAX, RAX);
    asm.movsxblrr(RAX, R8);
    asm.movsxblrr(RSP, RAX);
    asm.movsxblrr(R15, RAX);

    asm.movsxblrr(RAX, RBX);
    asm.movsxblrr(RAX, RSP);
    asm.movsxblrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0xBEY, 0xC0Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0xBEY, 0xC0Y);
    assertAsm(buffer, 0x0FY, 0xBEY, 0xE0Y);
    assertAsm(buffer, 0x44Y, 0x0FY, 0xBEY, 0xF8Y);

    assertAsm(buffer, 0x0FY, 0xBEY, 0xC3Y);
    assertAsm(buffer, 0x40Y, 0x0FY, 0xBEY, 0xC4Y);
    assertAsm(buffer, 0x40Y, 0x0FY, 0xBEY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testasmMovsxblra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsxblra(RAX, Address::offset(RAX, 0I));
    asm.movsxblra(R8, Address::offset(RAX, 0I));
    asm.movsxblra(RSP, Address::offset(RAX, 0I));
    asm.movsxblra(RDI, Address::offset(RAX, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0xBEY, 0x00Y);
    assertAsm(buffer, 0x44Y, 0x0FY, 0xBEY, 0x00Y);
    assertAsm(buffer, 0x0FY, 0xBEY, 0x20Y);
    assertAsm(buffer, 0x0FY, 0xBEY, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsxbqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsxbqrr(RAX, RAX);
    asm.movsxbqrr(RAX, R8);
    asm.movsxbqrr(RSP, RAX);
    asm.movsxbqrr(R15, RAX);

    asm.movsxbqrr(RAX, RBX);
    asm.movsxbqrr(RAX, RSP);
    asm.movsxbqrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0xC0Y);
    assertAsm(buffer, 0x49Y, 0x0FY, 0xBEY, 0xC0Y);
    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0xE0Y);
    assertAsm(buffer, 0x4CY, 0x0FY, 0xBEY, 0xF8Y);

    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0xC3Y);
    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0xC4Y);
    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsxbqra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsxbqra(RAX, Address::offset(RAX, 0I));
    asm.movsxbqra(R8, Address::offset(RAX, 0I));
    asm.movsxbqra(RSP, Address::offset(RAX, 0I));
    asm.movsxbqra(RDI, Address::offset(RAX, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0x00Y);
    assertAsm(buffer, 0x4CY, 0x0FY, 0xBEY, 0x00Y);
    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0x20Y);
    assertAsm(buffer, 0x48Y, 0x0FY, 0xBEY, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsxlqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsxlqrr(R15, RAX);
    asm.movsxlqrr(RAX, R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x4CY, 0x63Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0x63Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movssrr(XMM0, XMM1);
    asm.movssrr(XMM8, XMM1);
    asm.movssrr(XMM0, XMM9);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovssra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movssra(XMM0, Address::offset(RAX, 0I));
    asm.movssra(XMM8, Address::offset(RAX, 0I));

    asm.movssra(XMM0, Address::offset(R8, 0I));
    asm.movssra(XMM8, Address::offset(R15, 0I));

    asm.movssra(XMM9, Address::offset(RAX, 0I));
    asm.movssra(XMM15, Address::offset(RAX, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x10Y, 0x00Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x10Y, 0x00Y);

    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x10Y, 0x00Y);
    assertAsm(buffer, 0xF3Y, 0x45Y, 0x0FY, 0x10Y, 0x07Y);

    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x10Y, 0x08Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x10Y, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovssar(_x: Testing) {
    let asm = AssemblerX64();
    asm.movssar(Address::offset(RAX, 0I), XMM0);
    asm.movssar(Address::offset(RAX, 0I), XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x11Y, 0x00Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x11Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsdrr(XMM0, XMM1);
    asm.movsdrr(XMM8, XMM1);
    asm.movsdrr(XMM0, XMM9);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x10Y, 0xC1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsdra(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsdra(XMM0, Address::offset(RAX, 0I));
    asm.movsdra(XMM8, Address::offset(RAX, 0I));

    asm.movsdra(XMM0, Address::offset(R8, 0I));
    asm.movsdra(XMM8, Address::offset(R15, 0I));

    asm.movsdra(XMM9, Address::offset(RAX, 0I));
    asm.movsdra(XMM15, Address::offset(RAX, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x10Y, 0x00Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x10Y, 0x00Y);

    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x10Y, 0x00Y);
    assertAsm(buffer, 0xF2Y, 0x45Y, 0x0FY, 0x10Y, 0x07Y);

    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x10Y, 0x08Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x10Y, 0x38Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovsdar(_x: Testing) {
    let asm = AssemblerX64();
    asm.movsdar(Address::offset(RAX, 0I), XMM0);
    asm.movsdar(Address::offset(RAX, 0I), XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x11Y, 0x00Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x11Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAddssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addssrr(XMM0, XMM1);
    asm.addssrr(XMM3, XMM15);
    asm.addssrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x58Y, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x58Y, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x58Y, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmAddsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.addsdrr(XMM0, XMM1);
    asm.addsdrr(XMM3, XMM15);
    asm.addsdrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x58Y, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x58Y, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x58Y, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSubssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.subssrr(XMM0, XMM1);
    asm.subssrr(XMM3, XMM15);
    asm.subssrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x5CY, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x5CY, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x5CY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSubsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.subsdrr(XMM0, XMM1);
    asm.subsdrr(XMM3, XMM15);
    asm.subsdrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x5CY, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x5CY, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x5CY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMulssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.mulssrr(XMM0, XMM1);
    asm.mulssrr(XMM3, XMM15);
    asm.mulssrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x59Y, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x59Y, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x59Y, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMulsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.mulsdrr(XMM0, XMM1);
    asm.mulsdrr(XMM3, XMM15);
    asm.mulsdrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x59Y, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x59Y, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x59Y, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmDivssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.divssrr(XMM0, XMM1);
    asm.divssrr(XMM3, XMM15);
    asm.divssrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x5EY, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x5EY, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x5EY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmDivsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.divsdrr(XMM0, XMM1);
    asm.divsdrr(XMM3, XMM15);
    asm.divsdrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x5EY, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x5EY, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x5EY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmUcomissrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.ucomissrr(XMM1, XMM0);
    asm.ucomissrr(XMM15, XMM3);
    asm.ucomissrr(XMM4, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0x2EY, 0xC8Y);
    assertAsm(buffer, 0x44Y, 0x0FY, 0x2EY, 0xFBY);
    assertAsm(buffer, 0x41Y, 0x0FY, 0x2EY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmUcomisdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.ucomisdrr(XMM1, XMM0);
    asm.ucomisdrr(XMM15, XMM3);
    asm.ucomisdrr(XMM4, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x0FY, 0x2EY, 0xC8Y);
    assertAsm(buffer, 0x66Y, 0x44Y, 0x0FY, 0x2EY, 0xFBY);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x2EY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmPxorrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.pxorrr(XMM1, XMM0);
    asm.pxorrr(XMM15, XMM3);
    asm.pxorrr(XMM4, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x0FY, 0xEFY, 0xC8Y);
    assertAsm(buffer, 0x66Y, 0x44Y, 0x0FY, 0xEFY, 0xFBY);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0xEFY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSqrtssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.sqrtssrr(XMM1, XMM0);
    asm.sqrtssrr(XMM15, XMM3);
    asm.sqrtssrr(XMM4, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x51Y, 0xC8Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x51Y, 0xFBY);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x51Y, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSqrtsdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.sqrtsdrr(XMM1, XMM0);
    asm.sqrtsdrr(XMM15, XMM3);
    asm.sqrtsdrr(XMM4, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x51Y, 0xC8Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x51Y, 0xFBY);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x51Y, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTzcntlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.tzcntlrr(RDI, RAX);
    asm.tzcntlrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0xBCY, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x0FY, 0xBCY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmTzcntqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.tzcntqrr(RDI, RAX);
    asm.tzcntqrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xBCY, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xBCY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmLzcntlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.lzcntlrr(RDI, RAX);
    asm.lzcntlrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0xBDY, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x0FY, 0xBDY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmLzcntqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.lzcntqrr(RDI, RAX);
    asm.lzcntqrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xBDY, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xBDY, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmPopcntlrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.popcntlrr(RDI, RAX);
    asm.popcntlrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0xB8Y, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x0FY, 0xB8Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmPopcntqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.popcntqrr(RDI, RAX);
    asm.popcntqrr(RAX, RDI);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xB8Y, 0xF8Y);
    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0xB8Y, 0xC7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtss2sdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtss2sdrr(XMM0, XMM1);
    asm.cvtss2sdrr(XMM3, XMM15);
    asm.cvtss2sdrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x5AY, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x5AY, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x5AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtsd2ssrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtsd2ssrr(XMM0, XMM1);
    asm.cvtsd2ssrr(XMM3, XMM15);
    asm.cvtsd2ssrr(XMM8, XMM4);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x5AY, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x5AY, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x5AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmMovdrx(_x: Testing) {
    let asm = AssemblerX64();
    asm.movdrx(RDI, XMM0);
    asm.movdrx(R8, XMM0);
    asm.movdrx(R8, XMM7);
    asm.movdrx(R8, XMM8);
    asm.movdrx(R8, XMM15);
    asm.movdrx(R15, XMM0);
    asm.movdrx(R15, XMM7);
    asm.movdrx(R15, XMM8);
    asm.movdrx(R15, XMM15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x7EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x7EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x7EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x7EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x7EY, 0xFFY);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x7EY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmMovdxr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movdxr(XMM0, RAX);
    asm.movdxr(XMM0, R8);
    asm.movdxr(XMM7, R8);
    asm.movdxr(XMM8, R8);
    asm.movdxr(XMM15, R8);
    asm.movdxr(XMM0, R15);
    asm.movdxr(XMM7, R15);
    asm.movdxr(XMM8, R15);
    asm.movdxr(XMM15, R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x6EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x6EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x6EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x41Y, 0x0FY, 0x6EY, 0xFFY);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x6EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x6EY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqrx(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqrx(RDI, XMM0);
    asm.movqrx(R8, XMM0);
    asm.movqrx(R8, XMM7);
    asm.movqrx(R8, XMM8);
    asm.movqrx(R8, XMM15);
    asm.movqrx(R15, XMM0);
    asm.movqrx(R15, XMM7);
    asm.movqrx(R15, XMM8);
    asm.movqrx(R15, XMM15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x48Y, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x7EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x7EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x7EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x7EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x7EY, 0xFFY);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x7EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x7EY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmMovqxr(_x: Testing) {
    let asm = AssemblerX64();
    asm.movqxr(XMM0, RAX);
    asm.movqxr(XMM0, R8);
    asm.movqxr(XMM7, R8);
    asm.movqxr(XMM8, R8);
    asm.movqxr(XMM15, R8);
    asm.movqxr(XMM0, R15);
    asm.movqxr(XMM7, R15);
    asm.movqxr(XMM8, R15);
    asm.movqxr(XMM15, R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x48Y, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x6EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x6EY, 0xC0Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x6EY, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x6EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x49Y, 0x0FY, 0x6EY, 0xFFY);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x6EY, 0xC7Y);
    assertAsm(buffer, 0x66Y, 0x4DY, 0x0FY, 0x6EY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmXorpsra(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorpsra(XMM0, Address::offset(RBP, -8I));
    asm.xorpsra(XMM8, Address::offset(R8, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0x57Y, 0x45Y, 0xF8Y);
    assertAsm(buffer, 0x45Y, 0x0FY, 0x57Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmXorpsrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorpsrr(XMM0, XMM1);
    asm.xorpsrr(XMM7, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0x57Y, 0xC1Y);
    assertAsm(buffer, 0x41Y, 0x0FY, 0x57Y, 0xF8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmXorpdra(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorpdra(XMM0, Address::offset(RBP, -8I));
    asm.xorpdra(XMM8, Address::offset(R8, 0I));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x66Y, 0x0FY, 0x57Y, 0x45Y, 0xF8Y);
    assertAsm(buffer, 0x66Y, 0x45Y, 0x0FY, 0x57Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmXorlri(_x: Testing) {
    let asm = AssemblerX64();
    asm.xorlri(RAX, Immediate(1L));
    asm.xorlri(R8, Immediate(127L));
    asm.xorlri(R15, Immediate(-128L));

    asm.xorlri(RAX, Immediate(128L));
    asm.xorlri(R8, Immediate(-129L));
    asm.xorlri(R15, Immediate(128L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x83Y, 0xF0Y, 1Y);
    assertAsm(buffer, 0x41Y, 0x83Y, 0xF0Y, 0x7FY);
    assertAsm(buffer, 0x41Y, 0x83Y, 0xF7Y, 0x80Y);

    assertAsm(buffer, 0x35Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x41Y, 0x81Y, 0xF0Y, 0x7FY, 0xFFY, 0xFFY, 0xFFY);
    assertAsm(buffer, 0x41Y, 0x81Y, 0xF7Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpbar(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpbar(Address::offset(RAX, 0I), RAX);
    asm.cmpbar(Address::offset(RAX, 0I), RBX);
    asm.cmpbar(Address::offset(RAX, 0I), RSP);
    asm.cmpbar(Address::offset(RAX, 0I), RDI);
    asm.cmpbar(Address::offset(RAX, 0I), R8);
    asm.cmpbar(Address::offset(R8, 0I), RAX);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x38Y, 0x00Y);
    assertAsm(buffer, 0x38Y, 0x18Y);
    assertAsm(buffer, 0x40Y, 0x38Y, 0x20Y);
    assertAsm(buffer, 0x40Y, 0x38Y, 0x38Y);
    assertAsm(buffer, 0x44Y, 0x38Y, 0x00Y);
    assertAsm(buffer, 0x41Y, 0x38Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpbai(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpbai(Address::offset(RAX, 0I), Immediate(1L));
    asm.cmpbai(Address::offset(RAX, 0I), Immediate(127L));
    asm.cmpbai(Address::offset(RAX, 0I), Immediate(-128L));
    asm.cmpbai(Address::offset(RAX, 0I), Immediate(255L));
    asm.cmpbai(Address::offset(R8, 0I), Immediate(255L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x80Y, 0x38Y, 1Y);
    assertAsm(buffer, 0x80Y, 0x38Y, 0x7FY);
    assertAsm(buffer, 0x80Y, 0x38Y, 0x80Y);
    assertAsm(buffer, 0x80Y, 0x38Y, 0xFFY);
    assertAsm(buffer, 0x41Y, 0x80Y, 0x38Y, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmCmplri(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmplri(RAX, Immediate(0L));
    asm.cmplri(R15, Immediate(0L));
    asm.cmplri(R9, Immediate(0L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x83Y, 0xF8Y, 0Y);
    assertAsm(buffer, 0x41Y, 0x83Y, 0xFFY, 0Y);
    assertAsm(buffer, 0x41Y, 0x83Y, 0xF9Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmplai(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmplai(Address::offset(RAX, 0I), Immediate(127L));
    asm.cmplai(Address::offset(RAX, 0I), Immediate(-128L));
    asm.cmplai(Address::offset(RAX, 0I), Immediate(128L));
    asm.cmplai(Address::offset(R8, 0I), Immediate(128L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x83Y, 0x38Y, 0x7FY);
    assertAsm(buffer, 0x83Y, 0x38Y, 0x80Y);
    assertAsm(buffer, 0x81Y, 0x38Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x41Y, 0x81Y, 0x38Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmplar(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmplar(Address::offset(RBX, 1I), RAX);
    asm.cmplar(Address::offset(RBX, 1I), R10);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x39Y, 0x43Y, 1Y);
    assertAsm(buffer, 0x44Y, 0x39Y, 0x53Y, 1Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpqai(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpqai(Address::offset(RAX, 0I), Immediate(127L));
    asm.cmpqai(Address::offset(RAX, 0I), Immediate(-128L));
    asm.cmpqai(Address::offset(RAX, 0I), Immediate(128L));
    asm.cmpqai(Address::offset(R8, 0I), Immediate(128L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x83Y, 0x38Y, 0x7FY);
    assertAsm(buffer, 0x48Y, 0x83Y, 0x38Y, 0x80Y);
    assertAsm(buffer, 0x48Y, 0x81Y, 0x38Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0x81Y, 0x38Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpqar(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpqar(Address::offset(RBX, 1I), RAX);
    asm.cmpqar(Address::offset(RBX, 256I), RAX);
    asm.cmpqar(Address::offset(RDI, 1I), RAX);
    asm.cmpqar(Address::offset(R9, 1I), RAX);
    asm.cmpqar(Address::offset(RDI, 1I), R10);
    asm.cmpqar(Address::rip(1I), RAX);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x39Y, 0x43Y, 1Y);
    assertAsm(buffer, 0x48Y, 0x39Y, 0x83Y, 0Y, 1Y, 0Y, 0Y);
    assertAsm(buffer, 0x48Y, 0x39Y, 0x47Y, 1Y);
    assertAsm(buffer, 0x49Y, 0x39Y, 0x41Y, 1Y);
    assertAsm(buffer, 0x4CY, 0x39Y, 0x57Y, 1Y);
    assertAsm(buffer, 0x48Y, 0x39Y, 0x05Y, 1Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCmpqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.cmpqri(RAX, Immediate(127L));
    asm.cmpqri(R15, Immediate(-128L));
    asm.cmpqri(R9, Immediate(0L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x83Y, 0xF8Y, 0x7FY);
    assertAsm(buffer, 0x49Y, 0x83Y, 0xFFY, 0x80Y);
    assertAsm(buffer, 0x49Y, 0x83Y, 0xF9Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmNotlr(_x: Testing) {
    let asm = AssemblerX64();
    asm.notlr(RAX);
    asm.notlr(R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF7Y, 0xD0Y);
    assertAsm(buffer, 0x41Y, 0xF7Y, 0xD7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmNotqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.notqr(RAX);
    asm.notqr(R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xF7Y, 0xD0Y);
    assertAsm(buffer, 0x49Y, 0xF7Y, 0xD7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmNeglr(_x: Testing) {
    let asm = AssemblerX64();
    asm.neglr(RAX);
    asm.neglr(R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF7Y, 0xD8Y);
    assertAsm(buffer, 0x41Y, 0xF7Y, 0xDFY);
    assertAsmEnd(buffer);
}

@test fn testAsmNegqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.negqr(RAX);
    asm.negqr(R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xF7Y, 0xD8Y);
    assertAsm(buffer, 0x49Y, 0xF7Y, 0xDFY);
    assertAsmEnd(buffer);
}

@test fn testAsmAndqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.andqri(RAX, Immediate(-8L));
    asm.andqri(RAX, Immediate(128L));
    asm.andqri(R9, Immediate(-8L));
    asm.andqri(R9, Immediate(128L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0x83Y, 0xE0Y, 0xF8Y);
    assertAsm(buffer, 0x48Y, 0x25Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsm(buffer, 0x49Y, 0x83Y, 0xE1Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0x81Y, 0xE1Y, 0x80Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpr(_x: Testing) {
    let asm = AssemblerX64();
    asm.jmpr(RAX);
    asm.jmpr(RDI);
    asm.jmpr(R8);
    asm.jmpr(R15);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xFFY, 0xE0Y);
    assertAsm(buffer, 0xFFY, 0xE7Y);
    assertAsm(buffer, 0x41Y, 0xFFY, 0xE0Y);
    assertAsm(buffer, 0x41Y, 0xFFY, 0xE7Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShrlri(_x: Testing) {
    let asm = AssemblerX64();
    asm.shrlri(RAX, Immediate(2L));
    asm.shrlri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xC1Y, 0xE8Y, 2Y);
    assertAsm(buffer, 0x41Y, 0xC1Y, 0xE8Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShrlr(_x: Testing) {
    let asm = AssemblerX64();
    asm.shrlr(RAX);
    asm.shrlr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xD3Y, 0xE8Y);
    assertAsm(buffer, 0x41Y, 0xD3Y, 0xE8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShrqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.shrqri(RAX, Immediate(2L));
    asm.shrqri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xC1Y, 0xE8Y, 2Y);
    assertAsm(buffer, 0x49Y, 0xC1Y, 0xE8Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShrqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.shrqr(RAX);
    asm.shrqr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xD3Y, 0xE8Y);
    assertAsm(buffer, 0x49Y, 0xD3Y, 0xE8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSarlri(_x: Testing) {
    let asm = AssemblerX64();
    asm.sarlri(RAX, Immediate(2L));
    asm.sarlri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xC1Y, 0xF8Y, 2Y);
    assertAsm(buffer, 0x41Y, 0xC1Y, 0xF8Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSarlr(_x: Testing) {
    let asm = AssemblerX64();
    asm.sarlr(RAX);
    asm.sarlr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xD3Y, 0xF8Y);
    assertAsm(buffer, 0x41Y, 0xD3Y, 0xF8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSarqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.sarqri(RAX, Immediate(2L));
    asm.sarqri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xC1Y, 0xF8Y, 2Y);
    assertAsm(buffer, 0x49Y, 0xC1Y, 0xF8Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmSarqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.sarqr(RAX);
    asm.sarqr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xD3Y, 0xF8Y);
    assertAsm(buffer, 0x49Y, 0xD3Y, 0xF8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShllri(_x: Testing) {
    let asm = AssemblerX64();
    asm.shllri(RAX, Immediate(2L));
    asm.shllri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xC1Y, 0xE0Y, 2Y);
    assertAsm(buffer, 0x41Y, 0xC1Y, 0xE0Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShllr(_x: Testing) {
    let asm = AssemblerX64();
    asm.shllr(RAX);
    asm.shllr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xD3Y, 0xE0Y);
    assertAsm(buffer, 0x41Y, 0xD3Y, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShlqri(_x: Testing) {
    let asm = AssemblerX64();
    asm.shlqri(RAX, Immediate(2L));
    asm.shlqri(R8, Immediate(2L));

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xC1Y, 0xE0Y, 2Y);
    assertAsm(buffer, 0x49Y, 0xC1Y, 0xE0Y, 2Y);
    assertAsmEnd(buffer);
}

@test fn testAsmShlqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.shlqr(RAX);
    asm.shlqr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xD3Y, 0xE0Y);
    assertAsm(buffer, 0x49Y, 0xD3Y, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmRollr(_x: Testing) {
    let asm = AssemblerX64();
    asm.rollr(RAX);
    asm.rollr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xD3Y, 0xC0Y);
    assertAsm(buffer, 0x41Y, 0xD3Y, 0xC0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmRolqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.rolqr(RAX);
    asm.rolqr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xD3Y, 0xC0Y);
    assertAsm(buffer, 0x49Y, 0xD3Y, 0xC0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmRorlr(_x: Testing) {
    let asm = AssemblerX64();
    asm.rorlr(RAX);
    asm.rorlr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xD3Y, 0xC8Y);
    assertAsm(buffer, 0x41Y, 0xD3Y, 0xC8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmRorqr(_x: Testing) {
    let asm = AssemblerX64();
    asm.rorqr(RAX);
    asm.rorqr(R8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x48Y, 0xD3Y, 0xC8Y);
    assertAsm(buffer, 0x49Y, 0xD3Y, 0xC8Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtsi2ssdrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtsi2ssdrr(XMM0, RCX);
    asm.cvtsi2ssdrr(XMM3, R15);
    asm.cvtsi2ssdrr(XMM8, RSP);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x2AY, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x2AY, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x2AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtsi2ssqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtsi2ssqrr(XMM0, RCX);
    asm.cvtsi2ssqrr(XMM3, R15);
    asm.cvtsi2ssqrr(XMM8, RSP);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0x2AY, 0xC1Y);
    assertAsm(buffer, 0xF3Y, 0x49Y, 0x0FY, 0x2AY, 0xDFY);
    assertAsm(buffer, 0xF3Y, 0x4CY, 0x0FY, 0x2AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtsi2sddrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtsi2sddrr(XMM0, RCX);
    asm.cvtsi2sddrr(XMM3, R15);
    asm.cvtsi2sddrr(XMM8, RSP);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x2AY, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x2AY, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x2AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvtsi2sdqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvtsi2sdqrr(XMM0, RCX);
    asm.cvtsi2sdqrr(XMM3, R15);
    asm.cvtsi2sdqrr(XMM8, RSP);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x48Y, 0x0FY, 0x2AY, 0xC1Y);
    assertAsm(buffer, 0xF2Y, 0x49Y, 0x0FY, 0x2AY, 0xDFY);
    assertAsm(buffer, 0xF2Y, 0x4CY, 0x0FY, 0x2AY, 0xC4Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvttss2sidrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvttss2sidrr(RCX, XMM0);
    asm.cvttss2sidrr(R15, XMM3);
    asm.cvttss2sidrr(RSP, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x0FY, 0x2CY, 0xC8Y);
    assertAsm(buffer, 0xF3Y, 0x44Y, 0x0FY, 0x2CY, 0xFBY);
    assertAsm(buffer, 0xF3Y, 0x41Y, 0x0FY, 0x2CY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvttss2siqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvttss2siqrr(RCX, XMM0);
    asm.cvttss2siqrr(R15, XMM3);
    asm.cvttss2siqrr(RSP, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF3Y, 0x48Y, 0x0FY, 0x2CY, 0xC8Y);
    assertAsm(buffer, 0xF3Y, 0x4CY, 0x0FY, 0x2CY, 0xFBY);
    assertAsm(buffer, 0xF3Y, 0x49Y, 0x0FY, 0x2CY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvttsd2sidrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvttsd2sidrr(RCX, XMM0);
    asm.cvttsd2sidrr(R15, XMM3);
    asm.cvttsd2sidrr(RSP, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x0FY, 0x2CY, 0xC8Y);
    assertAsm(buffer, 0xF2Y, 0x44Y, 0x0FY, 0x2CY, 0xFBY);
    assertAsm(buffer, 0xF2Y, 0x41Y, 0x0FY, 0x2CY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmCvttsd2siqrr(_x: Testing) {
    let asm = AssemblerX64();
    asm.cvttsd2siqrr(RCX, XMM0);
    asm.cvttsd2siqrr(R15, XMM3);
    asm.cvttsd2siqrr(RSP, XMM8);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xF2Y, 0x48Y, 0x0FY, 0x2CY, 0xC8Y);
    assertAsm(buffer, 0xF2Y, 0x4CY, 0x0FY, 0x2CY, 0xFBY);
    assertAsm(buffer, 0xF2Y, 0x49Y, 0x0FY, 0x2CY, 0xE0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpBackwardNear(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    asm.jmp(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xEBY, 0xFEY);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpBackwardStillNear(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    for x in range(0I, 126I) {
        asm.nop();
    }
    asm.jmp(lbl);

    let buffer = asm.finalizeTesting();

    assertAsmNop(buffer, 126L);
    assertAsm(buffer, 0xEBY, 0x80Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpBackwardAlreadyFar(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    for x in range(0I, 127I) {
        asm.nop();
    }
    asm.jmp(lbl);

    let buffer = asm.finalizeTesting();

    assertAsmNop(buffer, 127L);
    assertAsm(buffer, 0xE9Y, 0x7CY, 0xFFY, 0xFFY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpForward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createLabel();
    asm.jmp(lbl);
    asm.bindLabel(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xE9Y, 0Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpNearForward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createLabel();
    asm.jmpNear(lbl);
    asm.bindLabel(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xEBY, 0Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJmpNearBackward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    asm.jmpNear(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0xEBY, 0xFEY);
    assertAsmEnd(buffer);
}

@test fn testAsmJccNearBackward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    asm.jccNear(Condition::Overflow, lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x70Y, 0xFEY);
    assertAsmEnd(buffer);
}

@test fn testAsmJccNearForward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createLabel();
    asm.jccNear(Condition::Overflow, lbl);
    asm.bindLabel(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x70Y, 0x00Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJccBackwardNear(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    asm.jcc(Condition::Overflow, lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x70Y, 0xFEY);
    assertAsmEnd(buffer);
}

@test fn testAsmJccBackwardStillNear(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    for x in range(0I, 126I) {
        asm.nop();
    }
    asm.jcc(Condition::Overflow, lbl);

    let buffer = asm.finalizeTesting();

    assertAsmNop(buffer, 126L);
    assertAsm(buffer, 0x70Y, 0x80Y);
    assertAsmEnd(buffer);
}

@test fn testAsmJccBackwardAlreadyFar(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createAndBindLabel();
    for x in range(0I, 127I) {
        asm.nop();
    }
    asm.jcc(Condition::Overflow, lbl);

    let buffer = asm.finalizeTesting();

    assertAsmNop(buffer, 127L);
    assertAsm(buffer, 0x0FY, 0x80Y, 0x7BY, 0xFFY, 0xFFY, 0xFFY);
    assertAsmEnd(buffer);
}

@test fn testAsmJccForward(_x: Testing) {
    let asm = AssemblerX64();
    let lbl = asm.createLabel();
    asm.jcc(Condition::Overflow, lbl);
    asm.bindLabel(lbl);

    let buffer = asm.finalizeTesting();

    assertAsm(buffer, 0x0FY, 0x80Y, 0Y, 0Y, 0Y, 0Y);
    assertAsmEnd(buffer);
}

fn assertAsmNop(code: MachineCode, length: Int64) {
    assert(length > 0L);

    var idx = 0L;
    while idx < length {
        assert(0x90Y == code.bytes(code.start + idx));
        idx = idx + 1L;
    }

    code.start = code.start + length;
}
