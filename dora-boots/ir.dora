class Function {
    var start: Block;
    var end: Block;

    var blocks: Vec[Block];

    fun create_block() -> Block {
        let block = Block();
        self.blocks.push(block);
        return block;
    }
}

class Block {
    var instructions: Vec[Inst];

    fun create_inst(inst: Inst) -> Inst {
        self.instructions.push(inst);
        return inst;
    }
}

@abstract @open class Value

@abstract @open class Const: Value
class IntConst(let value: Int): Value
class FloatConst(let value: Float): Value
class DoubleConst(let value: Double): Value
class LongConst(let value: Long): Value

@abstract @open class Inst: Value

class PrologInst: Inst
class EpilogInst: Inst
class UnaryInst(let op: UnOp, let opnd: Value): Inst
class BinaryInst(let op: BinOp, let lhs: Value, let rhs: Value): Inst
class ArgInst(let idx: Int): Inst

class PhiInst(let inputs: Vec[PhiArg]): Inst
class PhiArg(let value: Value, let block: Block)

@abstract @open class Terminator: Inst

class ReturnInst(let value: Value): Terminator
class ReturnVoidInst: Terminator
class CondInst(let cond: Value, let true_succ: Block, let false_succ: Block): Terminator
class GotoInst(let succ: Block): Terminator

class Type(let kind: TypeKind) {
    @static fun unit() -> Type { return Type(TypeKind::Unit); }
    @static fun int() -> Type { return Type(TypeKind::Int); }
    @static fun long() -> Type { return Type(TypeKind::Long); }
    @static fun float() -> Type { return Type(TypeKind::Float); }
    @static fun double() -> Type { return Type(TypeKind::Double); }
    @static fun ptr() -> Type { return Type(TypeKind::Ptr); }

    fun is_unit() -> Bool { return self.kind == TypeKind::Unit; }
    fun is_int() -> Bool { return self.kind == TypeKind::Int; }
    fun is_long() -> Bool { return self.kind == TypeKind::Long; }
    fun is_float() -> Bool { return self.kind == TypeKind::Float; }
    fun is_double() -> Bool { return self.kind == TypeKind::Double; }
    fun is_ptr() -> Bool { return self.kind == TypeKind::Ptr; }
}

enum TypeKind {
    Unit, Int, Long, Float, Double, Ptr
}

enum BinOp {
    Add, Sub, Mul, Div, Mod,
    FAdd, FSub, FMul, FDiv,
}

enum UnOp {
    Neg, FNeg, Not,
}