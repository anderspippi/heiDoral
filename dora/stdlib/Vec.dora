@pub class Vec[T](values: T...) {
  var array: Array[T] = values;
  var len: Int64 = values.size();

  @pub fn get(idx: Int64): T {
    if idx < 0i64 || idx >= self.len {
      fatalError("index out of bounds for vector");
    }

    return self.array(idx);
  }

  @pub fn set(idx: Int64, val: T) {
    if idx < 0i64 || idx >= self.len {
      fatalError("index out of bounds for vector");
    }

    self.array.set(idx, val);
  }

  @pub fn reserve(newcap: Int64) {
    assert(newcap >= 0i64);

    if self.capacity() >= newcap {
      return;
    }

    let newarray = Array[T]::unsafeNew(newcap);
    Array[T]::copy(self.array, 0i64, newarray, 0i64, self.len);
    self.array = newarray;
  }

  @pub fn push(val: T) {
    let currentCapacity = self.capacity();

    if self.len == currentCapacity {
      let newCapacity = self.newCapacity(currentCapacity);

      let newArray = Array[T]::unsafeNew(newCapacity);
      Array[T]::copy(self.array, 0i64, newArray, 0i64, self.len);
      self.array = newArray;
    }

    self.array.set(self.len, val);
    self.len = self.len + 1i64;
  }

  @pub fn insertAt(idx: Int64, val: T) {
    assert(idx <= self.len);
    if idx == self.len {
      self.push(val);
      return;
    }
    let currentCapacity = self.capacity();
    let targetArray = if self.len == currentCapacity {
      Array[T]::unsafeNew(self.newCapacity(currentCapacity))
    } else {
      self.array
    };

    if idx != 0i64 && self.array !== targetArray {
      Array[T]::copy(self.array, 0i64, targetArray, 0i64, idx);
    }

    // not Array::copy as source and target could be aliased
    var i = self.len - 1i64;
    while idx <= i {
      targetArray.set(i + 1i64, self.array.get(i));
      i = i - 1i64;
    }

    targetArray.set(idx, val);
    self.array = targetArray;
    self.len = self.len + 1i64;
  }

  fn newCapacity(currentCapacity: Int64): Int64 {
    if currentCapacity == 0i64 {
      4i64
    } else {
      currentCapacity * 2i64
    }
  }

  @pub fn toArray(): Array[T] {
    let newarray = Array[T]::unsafeNew(self.len);
    Array[T]::copy(self.array, 0i64, newarray, 0i64, self.len);
    newarray
  }

  @pub fn pop(): T {
    if self.len == 0i64 {
      fatalError("no element left to pop");
    }

    let newlength = self.len - 1i64;
    let temp = self.array(newlength);

    // set popped element to nil so that GC can collect object
    // not necessary for primitive types
    unsafeKillRefs[T](self.array, newlength);

    self.len = newlength;
    temp
  }

  @pub fn trimToLen() {
    if self.len != self.capacity() {
      if self.len == 0i64 {
        self.array = Array[T]::empty();
      } else {
        let newarray = Array[T]::unsafeNew(self.len);
        Array[T]::copy(self.array, 0i64, newarray, 0i64, self.len);
        self.array = newarray;
      }
    }
  }

  @pub fn removeItem(value: T) {
    let len = self.len;
    var destIdx = 0i64;
    var srcIdx = 0i64;

    while srcIdx < len {
      let current = self.array(srcIdx);

      if current !== value {
        self.array(destIdx) = current;
        destIdx = destIdx + 1i64;
      }

      srcIdx = srcIdx + 1i64;
    }

    self.len = destIdx;

    while destIdx < srcIdx {
      unsafeKillRefs[T](self.array, destIdx);
      destIdx = destIdx + 1i64;
    }
  }

  @pub fn removeAt(ind: Int64): T {
    var ind = ind;
    assert(ind < self.len);
    let temp = self.get(ind);
    let len = self.len;

    while ind < len - 1i64 {
      self.set(ind, self.get(ind+1i64));
      ind = ind + 1i64;
    }

    unsafeKillRefs[T](self.array, ind);
    self.len = ind;

    temp
  }

  @pub fn size(): Int64 {
    return self.len;
  }

  @pub fn isEmpty(): Bool {
    self.len == 0
  }

  @pub fn capacity(): Int64 {
    self.array.size()
  }

  @pub fn first(): Option[T] {
    if self.len == 0 {
      Option[T]::None
    } else {
      Option[T]::Some(self.array(0))
    }
  }

  @pub fn last(): Option[T] {
    if self.len == 0 {
      Option[T]::None
    } else {
      Option[T]::Some(self.array(self.len - 1i64))
    }
  }

  @pub fn clear() {
    self.len = 0;
    self.array = Array[T]::empty();
  }

  @pub fn makeIterator(): VecIter[T] {
    VecIter[T](self)
  }

  @pub fn makeReverseIterator(): ReverseVecIter[T] {
    ReverseVecIter[T](self)
  }

  @pub fn enumerate(): VecEnumerator[T] {
    VecEnumerator[T](self)
  }
}

@pub class VecEnumerator[T](let data: Vec[T]) {
  var idx: Int64 = 0;

  @pub fn next(): Option[(Int64, T)] {
    if self.idx < self.data.size() {
      let current_idx = self.idx;
      self.idx = self.idx + 1i64;
      Some[(Int64, T)]((current_idx, self.data(current_idx)))
    } else {
      None[(Int64, T)]
    }
  }
}

@pub class VecIter[T](let data: Vec[T]) {
  var idx: Int64 = 0;

  @pub fn next(): Option[T] {
    if self.idx < self.data.size() {
      let result = self.data(self.idx);
      self.idx = self.idx + 1i64;
      Some[T](result)
    } else {
      None[T]
    }
  }
}

@pub class ReverseVecIter[T](let data: Vec[T]) {
  var idx: Int64 = data.size() - 1;

  @pub fn next(): Option[T] {
    if self.idx != -1 {
      let result = self.data(self.idx);
      self.idx = self.idx - 1i64;
      Some[T](result)
    } else {
      None[T]
    }
  }
}

impl[T: Equals] Vec[T] {
  @pub fn equals(other: Vec[T]): Bool {
    if self.size() != other.size() {
      return false;
    }
    var i = 0i64;
    while i < self.size() {
      if self(i).equals(other(i)).not() {
        return false;
      }
      i = i + 1i64;
    }
    return true;
  }

  @pub fn contains(value: T): Bool {
    var i = 0i64;

    while i < self.size() {
      let x = self.get(i);
      if x.equals(value) {
        return true;
      }
      i = i + 1i64;
    }

    return false;
  }

  @pub fn removeEquals(elem: T) {
    var i = 0i64;

    while i < self.size() {
      if self(i).equals(elem) {
        self.removeAt(i);
      } else {
        i = i + 1i64;
      }
    }
  }
}

impl[T: Identity] Vec[T] {
  @pub fn has(value: T): Bool {
    var i = 0i64;

    while i < self.size() {
      if self.get(i).identicalTo(value) {
        return true;
      }
      i = i + 1i64;
    }

    return false;
  }
}

impl[T: Stringable] Vec[T] {
  @pub fn toString(): String {
    let sb = StringBuffer();
    sb.append("Vec(");
    let size = self.len;
    if size != 0i64 {
      var i = 0i64;
      while i < size - 1i64 {
        sb.append(self.array(i).toString());
        sb.append(", ");
        i = i + 1i64;
      }
      sb.append(self.array(i).toString());
    }
    sb.append(")");
    return sb.toString();
  }
}
