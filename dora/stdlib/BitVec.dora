@pub class BitVec {
    var data: Array[Int32] = Array[Int32]::empty();

    @pub fn contains(idx: Int64): Bool {
        if idx < 0i64 {
            fatalError("index out of bounds");
        }

        if idx >= self.data.size() * 32i64 {
            return false;
        }

        let entry_idx = idx / 32i64;
        let value = self.data.get(entry_idx);
        let value_idx = idx - entry_idx;

        return value & (1i32 << value_idx.toInt32()) != 0i32;
    }

    @pub fn insert(idx: Int64) {
        if idx < 0i64 {
            fatalError("index out of bounds");
        }

        self.ensureCapacity(idx+1i64);

        let entry_idx = idx / 32i64;
        var value = self.data.get(entry_idx);
        let value_idx = idx - entry_idx;

        value = value | (1i32 << value_idx.toInt32());

        self.data.set(entry_idx, value);
    }

    @pub fn remove(idx: Int64) {
        if idx < 0i64 {
            fatalError("index out of bounds");
        }

        if idx >= self.data.size() * 32i64 {
            return;
        }

        let entry_idx = idx / 32i64;
        var value = self.data.get(entry_idx);
        let value_idx = idx - entry_idx;

        value = value & !(1i32 << value_idx.toInt32());

        self.data.set(entry_idx, value);
    }

    @pub fn ensureCapacity(newcap: Int64) {
        if newcap < self.data.size() * 32i64 || newcap == 0i64 {
            return;
        }

        let newcap = (newcap + 31i64) / 32i64;

        let newarray = Array[Int32]::zero(newcap);
        Array[Int32]::copy(self.data, 0i64, newarray, 0i64, self.data.size());
        self.data = newarray;
    }

    @pub fn capacity(): Int64 {
        self.data.size() * 32i64
    }
}
