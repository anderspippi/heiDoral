@pub class StringBuffer() {
  var buf: Array[UInt8] = Array[UInt8]::empty();
  var len: Int64 = 0i64;

  @pub fn size(): Int64 {
    return self.len;
  }

  @pub fn capacity(): Int64 {
    return self.buf.size();
  }

  // reserve `elements` bytes
  // (capacity - length >= elements)
  @pub fn reserve(elements: Int64) {
    if self.capacity() - self.size() >= elements {
      return;
    }

    let newcap = self.newCapacity(elements);
    let newbuf = Array[UInt8]::zero(newcap);
    var i = 0i64;

    while i < self.buf.size() {
      newbuf.set(i, self.buf.get(i));
      i = i + 1i64;
    }

    self.buf = newbuf;
  }

  @pub fn newCapacity(reserve: Int64): Int64 {
    var len = self.len;

    if len == 0i64 {
      len = 4i64;
    }

    let c1 = (len + reserve + 7i64) & !7i64;
    let c2 = len * 2i64;

    if c1 > c2 {
      c1
    } else if c2 - c1 > 32i64 {
      c1
    } else {
      c2
    }
  }

  @pub fn appendChar(ch: Char): StringBuffer {
    let chLen = ch.lenUtf8();
    self.reserve(chLen.toInt64());
    ch.encodeUtf8(self.buf, self.len);
    self.len = self.len + chLen.toInt64();
    self
  }

  @pub fn append(value: String): StringBuffer {
    self.reserve(value.size());
    var i = 0i64;

    while i < value.size() {
      self.buf.set(self.len + i, value.getByte(i));
      i = i + 1i64;
    }

    self.len = self.len + value.size();
    self
  }

  @pub fn appendNewline(): StringBuffer {
    self.appendChar('\n')
  }

  @pub fn toString(): String = String::fromBytesPart(self.buf, 0i64, self.size()).getOrPanic();

  @pub @static fn empty(): StringBuffer = StringBuffer();
}
