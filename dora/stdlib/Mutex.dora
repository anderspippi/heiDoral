const UNLOCKED: Int32 = 0i32;
const LOCKED: Int32 = 1i32;
const SLEEPING: Int32 = 2i32;

@pub class Mutex {
    let data: AtomicInt32 = AtomicInt32(0i32);

    @pub fn lock() {
        let previous = self.data.compareExchange(UNLOCKED, LOCKED);

        if previous != UNLOCKED {
            self.lockSlow(previous);
        }
    }

    fn lockSlow(previous: Int32) {
        var previous = previous;
        var lockSuccess = false;

        while !lockSuccess {
            assert(previous == LOCKED || previous == SLEEPING);

            if self.transitionToSleepingState(previous) {
                self.wait(SLEEPING);
            }

            previous = self.data.compareExchange(UNLOCKED, SLEEPING);
            lockSuccess = previous == UNLOCKED;
        }
    }

    fn transitionToSleepingState(previous: Int32): Bool {
        if previous == SLEEPING { return true; }
        self.data.compareExchange(LOCKED, SLEEPING) != UNLOCKED
    }

    @pub fn unlock() {
        let previous = self.data.exchange(UNLOCKED);

        if previous != LOCKED {
            self.unlockSlow(previous);
        }
    }

    fn unlockSlow(previous: Int32) {
        assert(previous == SLEEPING);
        self.notify();
    }

    @internal fn wait(status: Int32);
    @internal fn notify();
}
