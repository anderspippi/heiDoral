@pub @internal struct Int64

impl Int64 {
  @pub @internal fn toUInt8(): UInt8;
  @pub fn toChar(): Option[Char] {
    if self >= 0i64 && self <= 0x10FFFFL && (self < 0xD800i64 || self > 0xDFFFL) {
      Option[Char]::Some(self.toCharUnchecked())
    } else {
      Option[Char]::None
    }
  }
  @pub @internal fn toCharUnchecked(): Char;
  @pub @internal fn toInt32(): Int32;
  @pub @internal fn toString(): String;
  @pub fn toStringHex(): String { String::hex(self) }

  @pub fn toStringBinary(): String = String::binary(self);

  @pub @internal fn toFloat32(): Float32;
  @pub @internal fn toFloat64(): Float64;

  @pub @internal fn asFloat64(): Float64;

  @pub @internal fn equals(rhs: Int64): Bool;
  @pub @internal fn compareTo(rhs: Int64): Int32;

  @pub @internal fn plus(rhs: Int64): Int64;
  @pub @internal fn minus(rhs: Int64): Int64;
  @pub @internal fn times(rhs: Int64): Int64;
  @pub @internal fn div(rhs: Int64): Int64;
  @pub @internal fn modulo(rhs: Int64): Int64;

  @pub @internal fn wrappingAdd(rhs: Int64): Int64;
  @pub @internal fn wrappingSub(rhs: Int64): Int64;
  @pub @internal fn wrappingMul(rhs: Int64): Int64;

  @pub @internal fn bitwiseOr(rhs: Int64): Int64;
  @pub @internal fn bitwiseAnd(rhs: Int64): Int64;
  @pub @internal fn bitwiseXor(rhs: Int64): Int64;

  @pub @internal fn shiftLeft(by: Int32): Int64;
  @pub @internal fn shiftRightSigned(by: Int32): Int64;
  @pub @internal fn shiftRight(by: Int32): Int64;

  @pub @internal fn rotateLeft(by: Int32): Int64;
  @pub @internal fn rotateRight(by: Int32): Int64;

  @pub @internal fn unaryPlus(): Int64;
  @pub @internal fn unaryMinus(): Int64;
  @pub @internal fn not(): Int64;
  @pub fn abs(): Int64 {
    let s = self.shiftRightSigned(63i32);
    return self.bitwiseXor(s).wrappingSub(s);
  }

  @pub @internal fn countZeroBits(): Int32 = self.not().countOneBits();
  @pub @internal fn countOneBits(): Int32 {
    var x = self;
    var c = 0i32;
    while (x != 0i64) {
      c = c + 1i32;
      x = x.bitwiseAnd(x - 1i64);
    }
    return c;
  }
  @pub @internal fn countZeroBitsLeading(): Int32 {
    if self == 0i64 {
      return Int64::bits();
    }
    var t = 1i64.shiftLeft(Int64::bits() - 1i32);
    var r = 0i32;
    while (self.bitwiseAnd(t)) == 0i64 {
      t = t.shiftRight(1i32);
      r = r + 1i32;
    }
    return r;
  }
  @pub @internal fn countOneBitsLeading(): Int32 = self.not().countZeroBitsLeading();
  @pub @internal fn countZeroBitsTrailing(): Int32 {
    if self == 0i64 {
      return Int64::bits();
    }
    var t = 1i64;
    var r = 0i32;
    while (self.bitwiseAnd(t)) == 0i64 {
      t = t.shiftLeft(1i32);
      r = r + 1i32
    }
    return r;
  }
  @pub @internal fn countOneBitsTrailing(): Int32 = self.not().countZeroBitsTrailing();

  @pub fn hash(): Int32 = self.toInt32();

  @pub @static fn bits(): Int32 = 64i32;
  @pub @static fn bytes(): Int32 = 8i32;

  @pub @static fn maxValue(): Int64 = 9223372036854775807i64;
  @pub @static fn minValue(): Int64 = -9223372036854775808i64;

  @pub @static fn min(lhs: Int64, rhs: Int64): Int64 = if lhs < rhs { lhs } else { rhs };
  @pub @static fn max(lhs: Int64, rhs: Int64): Int64 = if lhs < rhs { rhs } else { lhs };
}
