@pub class CodepointIterator(let value: String, var start: Int64) {
    @pub fn hasNext(): Bool = self.start < self.value.size();

    @pub fn next(): Char {
        var ch = self.value.getByte(self.start);

        if ch <= 0x7Fu8 {
            self.start = self.start + 1i64;
            return ch.toInt32().toCharUnchecked();
        }

        if ch <= 0xBFu8 {
            fatalError("unexpected continuation byte");
        }

        if ch <= 0xDFu8 {
            let cp = (ch.toInt32() & 0x1FI) << 6i32 | (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI);
            self.start = self.start + 2i64;
            return cp.toCharUnchecked();
        }

        if ch <= 0xEFu8 {
            let cp = (ch.toInt32() & 0xFI) << 12i32 |
                 (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI) << 6i32 |
                 (self.value.getByte(self.start + 2i64).toInt32() & 0x3FI);
            self.start = self.start + 3i64;
            return cp.toCharUnchecked();
        }

        if ch <= 0xF7u8 {
            let cp = (ch.toInt32() & 0x03i32) << 18i32 |
                 (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI) << 12i32 |
                 (self.value.getByte(self.start + 2i64).toInt32() & 0x3FI) << 6i32 |
                 (self.value.getByte(self.start + 3i64).toInt32() & 0x3FI);
            self.start = self.start + 4i64;
            return cp.toCharUnchecked();
        }

        fatalError("invalid utf8: " + ch.toInt32().toString());
        return '\0';
    }

    @pub fn peek(): Char {
        var ch = self.value.getByte(self.start);

        if ch <= 0x7Fu8 {
            return ch.toInt32().toCharUnchecked();
        }

        if ch <= 0xBFu8 {
            fatalError("unexpected continuation byte");
        }

        if ch <= 0xDFu8 {
            let cp = (ch.toInt32() & 0x1FI) << 6i32 | (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI);
            return cp.toCharUnchecked();
        }

        if ch <= 0xEFu8 {
            let cp = (ch.toInt32() & 0xFI) << 12i32 |
                 (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI) << 6i32 |
                 (self.value.getByte(self.start + 2i64).toInt32() & 0x3FI);
            return cp.toCharUnchecked();
        }

        if ch <= 0xF7u8 {
            let cp = (ch.toInt32() & 0x03i32) << 18i32 |
                 (self.value.getByte(self.start + 1i64).toInt32() & 0x3FI) << 12i32 |
                 (self.value.getByte(self.start + 2i64).toInt32() & 0x3FI) << 6i32 |
                 (self.value.getByte(self.start + 3i64).toInt32() & 0x3FI);
            return cp.toCharUnchecked();
        }

        fatalError("invalid utf8: " + ch.toInt32().toString());
        return '\0';
    }

    @pub fn size(): Int64 {
        var i = 0i64;

        while self.hasNext() {
            i = i + 1i64;
            self.next();
        }

        return i;
    }

    @pub fn toString(): String = String::fromStringPart(self.value, self.start, self.value.size() - self.start).getOrPanic();
}
