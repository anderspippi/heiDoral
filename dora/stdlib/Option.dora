@pub enum Option[T] {
  Some(T),
  None,
}

import Option::Some;
import Option::None;

impl[T] Option[T] {
  fun isNone(): Bool {
    unsafeLoadEnumVariant[Option[T]](self) == 1
  }

  fun isSome(): Bool {
    unsafeLoadEnumVariant[Option[T]](self) == 0
  }

  fun unwrap(): T {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      unsafeLoadEnumElement[Option[T], T](self, 0, 0)
    } else {
      fatalError("cannot unwrap None.");
      unreachable[T]()
    }
  }

  fun unwrapNone() {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      fatalError("cannot unwrap Some.");
      unreachable[T]()
    }
  }

  fun unwrapOr(alt: T): T {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      unsafeLoadEnumElement[Option[T], T](self, 0, 0)
    } else {
      alt
    }
  }

  fun has(val: T): Bool {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      unsafeLoadEnumElement[Option[T], T](self, 0, 0) === val
    } else {
      false
    }
  }
}

fun optionContains[T: Equals](lhs: Option[T], rhs: T): Bool {
  if lhs.isSome() {
    let lhs = lhs.unwrap();
    lhs === rhs || lhs.equals(rhs)
  } else {
    false
  }
}

fun optionEquals[T: Equals](lhs: Option[T], rhs: Option[T]): Bool {
  if lhs.isSome() {
    if rhs.isSome() {
      let lhs = lhs.unwrap();
      let rhs = rhs.unwrap();
      lhs.equals(rhs)
    } else {
      false
    }
  } else {
    rhs.isNone()
  }
}

fun optionToString[T: Stringable](lhs: Option[T]): String {
  if lhs.isSome() {
    "Some(${lhs.unwrap()})"
  } else {
    "None"
  }
}
