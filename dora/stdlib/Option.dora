@pub enum Option[T] {
  Some(T),
  None,
}

import Option::Some;
import Option::None;

impl[T] Option[T] {
  fun isNone(): Bool {
    match self {
      Some(_) => false,
      None => true
    }
  }

  fun isSome(): Bool {
    match self {
      Some(_) => true,
      None => false
    }
  }

  fun unwrap(): T {
    match self {
      Some(value) => value,
      None => {
        fatalError("cannot unwrap None.");
        unreachable[T]()
      }
    }
  }

  fun unwrapNone() {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      fatalError("cannot unwrap Some.");
      unreachable[T]()
    }
  }

  fun unwrapOr(alt: T): T {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      unsafeLoadEnumElement[Option[T], T](self, 0, 0)
    } else {
      alt
    }
  }

  fun has(val: T): Bool {
    if unsafeLoadEnumVariant[Option[T]](self) == 0 {
      unsafeLoadEnumElement[Option[T], T](self, 0, 0) === val
    } else {
      false
    }
  }
}

@pub fun optionContains[T: Equals](lhs: Option[T], rhs: T): Bool {
  if lhs.isSome() {
    let lhs = lhs.unwrap();
    lhs === rhs || lhs.equals(rhs)
  } else {
    false
  }
}

@pub fun optionEquals[T: Equals](lhs: Option[T], rhs: Option[T]): Bool {
  if lhs.isSome() {
    if rhs.isSome() {
      let lhs = lhs.unwrap();
      let rhs = rhs.unwrap();
      lhs.equals(rhs)
    } else {
      false
    }
  } else {
    rhs.isNone()
  }
}

impl[T: Stringable] Option[T] {
  @pub fun toString(): String {
    match self {
      Some(value) => "Some(${value})",
      None => "None"
    }
  }
}
