@pub class Queue[T] {
  var elements: Array[T] = Array[T]::unsafeNew(4i64);
  var front: Int64 = 0i64;
  var count: Int64 = 0i64;

  @pub fn enqueue(value: T) {
    if self.count == self.elements.size() {
      // copy into larger array
      let newelements = Array[T]::unsafeNew(self.elements.size() * 2i64);
      let len = self.elements.size() - self.front;
      Array[T]::copy(self.elements, self.front, newelements, 0i64, len);

      if len < self.count {
        Array[T]::copy(self.elements, 0i64, newelements, len, self.count - len);
      }

      self.front = 0i64;
      // self.count stays the same
      self.elements = newelements;
    }

    let end = self.getEnd();
    self.elements.set(end, value);
    self.count = self.count + 1i64;
  }

  @pub fn dequeue(): T {
    assert(self.count > 0i64);

    let value = self.elements.get(self.front);
    std::unsafeKillRefs[T](self.elements, self.front);

    self.moveFront();
    self.count = self.count - 1i64;

    return value;
  }

  fn moveFront(): Int64 {
    self.front = self.front + 1i64;

    if self.front == self.elements.size() {
      self.front = 0i64;
    }

    return self.front;
  }

  fn getEnd(): Int64 {
    let end = self.front + self.count;

    if end < self.elements.size() {
      return end;
    } else {
      return end - self.elements.size();
    }
  }

  @pub fn size(): Int64 {
    return self.count;
  }

  @pub fn isEmpty(): Bool {
    return self.count == 0i64;
  }
}
