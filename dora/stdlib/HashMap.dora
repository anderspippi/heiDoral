@pub class HashMap[K: Hash + Equals, V](entries: (K, V)...) {
    // BitSet.size == capacity * 2
    // [bit 0: inserted; bit 1: deleted] * capacity
    var inserted_and_deleted: BitSet = BitSet(0i64);
    var keys: Array[K] = Array[K]::empty();
    var values: Array[V] = Array[V]::empty();
    var entries: Int64 = 0i64;
    var cap: Int64 = 0i64;
    for entry in entries {
        self.insert(entry.0, entry.1);
    }

    @pub fn insert(key: K, value: V): Option[V] {
        self.ensureCapacity(1i64);
        assert(self.entries < self.cap);

        var hash = key.hash();
        var idx = hash.toInt64() & (self.cap - 1i64);
        var insert_idx = None[Int64];

        while true {
            if self.isLive(idx) {
                let current_key = self.keys.get(idx);

                if current_key.hash() == hash && current_key.equals(key) {
                    let old_value = self.values.get(idx);
                    self.values.set(idx, value);
                    return Some[V](old_value);
                }

            } else if self.isDeleted(idx) {
                // There might be live entries after a deleted one.

                if insert_idx.isNone() {
                    insert_idx = Some[Int64](idx);
                }

            } else {
                let insert_idx = insert_idx.unwrapOr(idx);

                self.inserted_and_deleted.insert(2i64 * insert_idx);
                self.inserted_and_deleted.remove(2i64 * insert_idx + 1i64);

                self.keys.set(insert_idx, key);
                self.values.set(insert_idx, value);

                self.entries = self.entries + 1i64;
                return None[V];
            }

            idx = (idx + 1i64) & (self.cap - 1i64);
        }

        unreachable[Option[V]]()
    }

    @pub fn contains(key: K): Bool {
        assert(self.entries <= self.cap);

        if self.entries == 0i64 {
            return false;
        }

        var hash = key.hash();
        var idx = hash.toInt64() & (self.cap - 1i64);

        while true {
            if self.isLive(idx) {
                let current_key = self.keys.get(idx);

                if current_key.hash() == hash && current_key.equals(key) {
                    return true;
                }
            } else if self.isDeleted(idx) {
                // There might be live entries after a deleted one.
            } else {
                break;
            }

            idx = (idx + 1i64) & (self.cap - 1i64);
        }

        false
    }

    @pub fn get(key: K): Option[V] {
        assert(self.entries <= self.cap);

        if self.entries == 0i64 {
            return Option[V]::None;
        }

        var hash = key.hash();
        var idx = hash.toInt64() & (self.cap - 1i64);

        while true {
            if self.isLive(idx) {
                let current_key = self.keys.get(idx);

                if current_key.hash() == hash && current_key.equals(key) {
                    return Option[V]::Some(self.values.get(idx));
                }
            } else if self.isDeleted(idx) {
                // There might be live entries after a deleted one.
            } else {
                break;
            }

            idx = (idx + 1i64) & (self.cap - 1i64);
        }

        Option[V]::None
    }

    @pub fn remove(key: K): Option[V] {
        self.shrink();

        var hash = key.hash();
        var idx = hash.toInt64() & (self.cap - 1i64);

        while true {
            if self.isLive(idx) {
                let current_key = self.keys.get(idx);

                if current_key.hash() == hash && current_key.equals(key) {
                    let value = self.values.get(idx);
                    self.inserted_and_deleted.insert(2i64 * idx + 1i64);

                    unsafeKillRefs[K](self.keys, idx);
                    unsafeKillRefs[V](self.values, idx);

                    self.entries = self.entries - 1i64;
                    return Option[V]::Some(value);
                }
            } else if self.isDeleted(idx) {
                // There might be live entries after a deleted one.
            } else {
                break;
            }

            idx = (idx + 1i64) & (self.cap - 1i64);
        }

        Option[V]::None
    }

    fn ensureCapacity(elements_to_add: Int64) {
        if self.entries + elements_to_add < self.cap {
            if self.entries <= (self.cap - (self.cap / 4i64)) {
                return;
            }
        }

        var new_capacity = 4i64;
        let old_capacity = self.cap;

        if old_capacity > 0i64 {
            new_capacity = old_capacity * 2i64;
        }

        assert(self.entries + elements_to_add < new_capacity);

        self.rehash(new_capacity);
    }

    fn shrink() {
        if self.entries > (self.cap / 4i64) {
            return;
        }

        let new_capacity = self.cap / 2i64;

        if new_capacity < 4i64 {
            return;
        }

        assert(self.entries < new_capacity);

        self.rehash(new_capacity);
    }

    fn rehash(new_capacity: Int64) {
        let old_capacity = self.cap;

        let new_map = HashMap[K, V]();
        new_map.inserted_and_deleted = BitSet(2i64 * new_capacity);
        new_map.keys = Array[K]::unsafeNew(new_capacity);
        new_map.values = Array[V]::unsafeNew(new_capacity);
        new_map.entries = 0i64;
        new_map.cap = new_capacity;

        var idx = 0i64;

        while idx < old_capacity {
            if self.isLive(idx) {
                let key = self.keys.get(idx);
                let value = self.values.get(idx);

                new_map.insert(key, value);
            }

            idx = idx + 1i64;
        }

        self.inserted_and_deleted = new_map.inserted_and_deleted;
        self.keys = new_map.keys;
        self.values = new_map.values;
        self.entries = new_map.entries;
        self.cap = new_capacity;
    }

    fn isLive(idx: Int64): Bool {
        return self.inserted_and_deleted.contains(2i64 * idx) &&
               !self.inserted_and_deleted.contains(2i64 * idx + 1i64);
    }

    fn isDeleted(idx: Int64): Bool {
        self.inserted_and_deleted.contains(2i64 * idx + 1i64)
    }

    @pub fn size(): Int64 {
        return self.entries;
    }

    @pub fn isEmpty(): Bool {
        return self.entries == 0i64;
    }

    @pub fn capacity(): Int64 {
        return self.cap;
    }

    @pub fn makeIterator(): HashMapIter[K, V] {
        HashMapIter[K, V](self)
    }
}

@pub class HashMapIter[K: Hash + Equals, V](let map: HashMap[K, V]) {
    var idx: Int64 = 0i64;

    @pub fn next(): Option[(K, V)] {
        while self.idx < self.map.capacity() {
            if self.map.isLive(self.idx) {
                let key = self.map.keys.get(self.idx);
                let value = self.map.values.get(self.idx);
                self.idx = self.idx + 1i64;
                return Some[(K, V)]((key, value));
            }

            self.idx = self.idx + 1i64;
        }

        None[(K, V)]
    }
}
