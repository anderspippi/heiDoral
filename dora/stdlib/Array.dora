@internal class Array[T](len: Int64) {

  @internal fun length() -> Int64;
  @internal fun get(idx: Int32) -> T;
  @internal fun set(idx: Int32, val: T);

  fun isEmpty() -> Bool = self.length() == 0L;

}

// The next two functions should be instance functions, but we cannot properly encode the fact that they put additional
// constraints on the existing class-level `T` of `Array`, not introduce a new function-level `T` on `contains`:
// fun contains[T : Identity + Equals](value: T) -> Bool /// wrong
// Some languages use the workaround to define a "fake" new generic parameter that subtypes the old one, like
// `[S <: T : Identity + Equals]`. I hope that a better solution can be found.

fun arrayContains[T : Identity + Equals](array: Array[T], value: T) -> Bool {
  var i = 0L;

  while i < array.length() {
    let x = array.get(i.toInt32());
    if x.identicalTo(value) || x.equals(value) {
      return true;
    }
    i = i + 1L;
  }

  return false;
}

fun arrayHas[T : Identity](array: Array[T], value: T) -> Bool {
  var i = 0L;

  while i < array.length() {
    if array.get(i.toInt32()).identicalTo(value) {
      return true;
    }
    i = i + 1L;
  }

  return false;
}

fun arrayEmpty[T]() -> Array[T] = Array[T](0L);

fun arrayFill[T](len: Int64, value: T) -> Array[T] {
  let array = Array[T](len);
  var i = 0L;

  while i < len {
    array(i.toInt32()) = value;
    i = i + 1L;
  }

  return array;
}

fun arrayNew[T: Default](len: Int64) -> Array[T] {
  let array = Array[T](len);
  var i = 0L;
  let value = T::default();

  while i < len {
    array.set(i.toInt32(), value);
    i = i + 1L;
  }

  return array;
}

fun arrayZero[T: Zero](len: Int64) -> Array[T] = return Array[T](len);

fun arrayCopy[T](src: Array[T], srcPos: Int64, dest: Array[T], destPos: Int64, len: Int64) {
  var i = 0L;

  while i < len {
    dest.set((destPos+i).toInt32(), src.get((srcPos+i).toInt32()));
    i = i + 1L;
  }
}

fun array[T](values: T...) -> Array[T] {
  values
}
